                lib     ../mach_m1/sysconfig.h                if      (NET=1)                lib     ../include/macdefs.h                lib     ../include/params.h                lib     ../include/sysdefs.h                lib     ../include/wzsock.h                lib     ../include/fio.h                lib     ../include/fio_ctrl.h                lib     ../include/fio_nwp.h                lib     ../include/nwp_codes.h                lib     ../include/sockerr.h                lib     ../include/task.h                data                global  wzsock,wskcl,wskcn,nw_int                global  wskrd,wskwr,wskop,wskbi,wskli,wskacWZPRIO          equ     -80  wz socket prio***************************************************************** wzdrvr.t driver for w5500 module via CPU09GPP* at return U = wzsock address* kernel treats this register as (pseudo) inode pointer*wzsock          equ     *                pshs    d,x,y,u                ldy     #NWP0                ldu     fio_dba,y** check if the networking device is active*                ldx     fifo_us1,u      check device active                addr    U,X             U+X>X                tst     wzmyip,x        initialized?                beq     04f                lda     wzdsta,x                beq     04f             00                coma                bne     04f             FF** prevent taking a wzsock already in use*                ldx     fifo_us0,u      first wzsock                addr    X,U             X + U -> U                clrb03              tst     wzfsta,u                beq     01f             is free                leau    WZSIZE,u                incb                cmpb    #MAX_WZ                blo     03b                bra     04f01              lda     wzfsta,u                ora     #WZBUSY                sta     wzfsta,u                stu     6,s             U = sock address** found empty wzsock,  successful return B=0*wzokrt                ldd     #0              OK return                std     0,s                puls    d,x,y,u,pc** out of wzsock's*04              ldb     #EBDEV                stb     uerror                stb     1,s                puls    d,x,y,u,pc***************************************************************** open the socket now* U = wzsock address*wskop           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_OPEN                jsr     fio_msg        wz fio handler                cmpb    #R_OPEN        matching response?                bne     02b** common return socket functions*wzskrt          tstb                    normal response                bpl     wzokrt* error return                jsr     sockerr                bra     cbexit         close on error***************************************************************** close the socket actively* U = sock address*wskcl           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_CLOSE        this will erase all info                jsr     fio_msg         tell GPP                leax    0,u                jsr     unlfdn          tell OS to drop too*** clear wzsock busy, return non -zero*cbexit          lda     wzfsta,u                anda    #(255-WZBUSY)    unbusy                sta     wzfsta,u                tstb                bpl     wzokrt                stb     1,s             B = error                puls    d,x,y,u,pc***************************************************************** do CONNECT socket* U = wzsock address* wzsock already updated with connection info by kernel*wskcn           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_CONNECT                jsr     fio_msg                cmpb    #R_CONNECT                beq     wzskrt                cmpb    #R_DISCON                bne     02b                lda     #EBADF                sta     uerror                bra     cbexit***************************************************************** U = wzsock address*wskbi           equ     *                lda     #S_BIND                bra     wskcm***************************************************************** U = sock address*wskli           equ     *                lda     #S_LISTEN                bra     wskcm***************************************************************** U = wzsock address*wskac           equ     *                lda     #S_ACCEPT                bra     wskcm***************************************************************** common error for open, connect*wskcm           lda     #EIO                sta     uerror                rts***************************************************************** wskrd, read data from socket, straight into process memory* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* U = wzsock address,*wskrd           equ     *                pshs    d,x,y,u                ldy     #NWP0           fio hardware parameters                ldd     fio_fsz,y                std     wzdma1,u        initialize for                clra                clrb                    one full transation                std     wzdma2,u*                ldd     uicnt           set max for this transaction                cmpd    fio_fsz,y                bls     01f                ldd     fio_fsz,y01              std     wzrqln,u        tell request length to GPP                lbeq     90f* check if a 4K page boundary is to be crossed                ldd     uistrt          start address in process space                anda    #$0f            4K                addd    wzrqln,u        add the amount of data                bita    #$f0            4K page overflow?                beq     00f             no, will not cross* it does cross ! cut it in two                ldd     uistrt          first part                pshs    d                negd                anda    #$0f            remaining size within 4K page                std     wzdma1,u        first part                puls    d                addd    wzrqln,u        remaining size in OTHER 4K page                anda    #$01                std     wzdma2,u* all checked, good to go00              ldb     #S_RQRD         tell GPP                jsr     fio_msg                tstb                lbmi    17f             error                cmpb    #R_CLOSE        is socket closed?                bne     16f                ldd     #0              set resulting data is 0                bra     20f*16              jsr     get_F_S         allocate slot + fifo* tell GPP I am ready collec the data and fill the fifo                ldb     #S_READ                jsr     fio_msg         data to fifo                tstb                bmi     17f* data is waiting in fifo                ldd     wzxfer,u        in one block?                cmpd    wzdma1,u                bls     07f                ldd     wzdma1,u        no, take first chunk* data in fifo07              std     -2,s            test D!                trfr    D,W                beq     20f             EOF?** W=(first) count, X, NWP0, wzsock*                pshs    d,x,y,u         save regs                ldd     uistrt         process memory address                ldu     fio_dba,y      fifo hardware base address                leau    fifo,u         fifo actual address                jsr     mapua2x        D > D offset in XBUFFER                tfr     d,x            set pointer                tfm1    U,X            block move* old U had wzsock address                ldy     6,s             old U from stack                ldd     wzdma2,y        2nd part?                trfr    D,W                beq     29f             nothing to do* W= (second) count ,(X), wzsock                ldd     0,s             first size (done)                addd    uistrt         update memory address                jsr     mapua2x        D >D in XBUFFER                tfr     d,x            set pointer again                tfm1    U,X            block move29              puls    d,x,y,u** transfer completed*20              jsr     FIFO_unlock    free the fifo for GPP                ldd     uicnt                subd    wzxfer,u                std     uicnt*90              ldy     utask                clr     tsact,y99              puls    d,x,y,u,pc* some socket error17              lda     #ESOCK                sta     uerror                puls    d,x,y,u,pc**************************************************************** wskwr, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock** U = sock addresswskwr           equ     *                pshs    d,x,y,u                ldy     #NWP000              ldd     uicnt           # to write                beq     90b             zero                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u                ldb     #S_RQWR         tell NWP we have data                jsr     fio_msg                cmpb    #E_IOERR        wrong?                beq     80f                cmpb    #R_DISCON                beq     80f             for now                cmpb    #E_SYSBSY                beq     00b*                jsr     get_F_S         allocate FIFO + transaction slot*                ldd     wzrqln,u                trfr    D,W                pshs    d,x,y,u         save regs                ldu     fio_dba,y                leau    fifo,u      fifo address                ldd     uistrt          user memory address                jsr     mapua2x                tfr     d,x                tfm1    X,U                puls    d,x,y,u*25              lda     wzenum,u        socket#                ldb     #S_WRITE                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b                jsr     FIFO_unlock                bra     90b80              lda     #EIO                sta     uerror                nop                puls    d,x,y,u,pc** nw_int, send signal to socket task*nw_int          equ     *                lda     #$ff                rts                else                data                nop                endif