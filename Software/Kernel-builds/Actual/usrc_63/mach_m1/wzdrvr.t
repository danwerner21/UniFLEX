                lib     ../mach_m1/sysconfig.h                if      (NET=1)                lib     ../include/macdefs.h                lib     ../include/params.h                lib     ../include/sysdefs.h                lib     ../include/wzsock.h                lib     ../include/fio.h                lib     ../include/fio_ctrl.h                lib     ../include/fio_nwp.h                lib     ../include/fio_codes.h                lib     ../include/nwp_codes.h                lib     ../include/sockerr.h                lib     ../include/task.h                data                global  wzsock,wskcl,wskcn,nw_int                global  wskrd,wskwr,wskop,wskbi,wskli,wskac                global  wskrecv,wsksnd                global  wzdebugWZPRIO          equ     -5  wz socket prio***************************************************************** wzdrvr.t driver for w5500 module via CPU09GPP* at return U = wzsock address* kernel treats this register as (pseudo) inode pointer*wzsock          equ     *                pshs    d,x,y,u                ldy     #NWP0                ldu     fio_dba,y** check if the networking device is active*                ldx     fifo_us1,u      check device active                addr    U,X             U+X>X                tst     wzmyip,x        initialized?                beq     04f                lda     wzdsta,x                beq     04f             00                coma                bne     04f             FF** find first free wzsock*                ldx     fifo_us0,u      first wzsock                addr    X,U             X + U -> U                clrb03              tst     wzfsta,u                beq     01f             is free                leau    WZSIZE,u                incb                cmpb    #MAX_WZ                blo     03b                bra     04f01              lda     wzfsta,u                ora     #WZBUSY                sta     wzfsta,u                stu     6,s             U = sock address* clear remainder of wzsock                leax    wzcmnd,u                leay    wztype,u                pshs    y44              clr     0,x+                cmpx    0,s                bne     44b                leas    2,s             clear stack** found empty wzsock,  successful return B=0*wzokrt                ldd     #0              OK return                std     0,s                puls    d,x,y,u,pc** out of wzsock's*04              ldb     #EBSY           busy, come back later                stb     uerror                stb     1,s                puls    d,x,y,u,pc***************************************************************** open the socket now* U = wzsock address setup by kernel    TCP and UDP*wskop           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_OPEN                jsr     fio_msg        wz fio handler                tstb                bmi     04f            abort waiting on error                cmpb    #R_OPEN        matching response?                bne     02b** common return socket functions*wzskrt          tstb                    normal response                bpl     wzokrt* error return04              jsr     sockerr                bra     cbexit         close on error***************************************************************** close the socket actively* U = sock address setup by kernel      TCP and UDP*wskcl           equ     *                pshs    d,x,y,u                ldy     #NWP0* internal closewskicl          clra                ldb     #S_CLOSE        this will erase all info                jsr     fio_msg         tell GPP                leax    0,u                jsr     unlfdn          tell OS to drop too*** clear wzsock busy, return non -zero*cbexit          lda     wzfsta,u                anda    #(255-WZBUSY)    unbusy                sta     wzfsta,u                tstb                bpl     wzokrt                stb     1,s             B = error                puls    d,x,y,u,pc***************************************************************** do CONNECT socket* U = wzsock address setup by kernel    TCP* wzsock already updated with connection info by kernel*wskcn           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_CONNECT                jsr     fio_msg                cmpb    #R_CONNECT                beq     wzskrt                cmpb    #R_DISCON                bne     02b*                lda     #EBADF                sta     uerror                bra     cbexit***************************************************************** do BIND socket                        TCP and UDP* U = wzsock address setup by kernel*wskbi           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_BIND                jsr     fio_msg                cmpb    #R_BIND                bne     01f                puls    d,x,y,u,pc*01              ldb     #S_CLOSE                jsr     fio_msg                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** do LISTEN socket                      TCP* U = sock address setup by kernel*wskli           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_LISTEN                jsr     fio_msg                cmpb    #R_LISTEN                bne     01f                puls    d,x,y,u,pc*01              cmpb    #R_CLOSE                lbeq    wskicl                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** do ACCEPT socket                      TCP* U = wzsock address setup by kernel*wskac           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_ACCEPT                jsr     fio_msg                cmpb    #R_ACCEPT                bne     01f                puls    d,x,y,u,pc*01              cmpb    #R_CLOSE                lbeq    wskicl                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** wskrd, read data from socket, straight into process memory* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* U = wzsock address, setup by kernel   TCP* uicnt holds total of transfer*wskrd           equ     *                pshs    d,x,y,u                ldy     #NWP0           fio hardware parameters** check page boundary crossing during transfer*                jsr     wzckpb          wzrqln, wzdma1, wzdma2                bcs     wzokex          zero data** all checked, good to go*                ldb     #S_RQRD         tell GPP                jsr     fio_msg                tstb                lbmi    17f             error                cmpb    #R_RQRDNB                beq     33f             non block return                cmpb    #R_CLOSE        is socket closed?                bne     16f                bra     wzrwex*33              ldd     #0              set resulting data is 0                bra     wzrwex2*16              jsr     get_F_S         allocate slot + fifo** tell GPP I am ready collec the data and fill the fifo*                ldb     #S_READ                jsr     fio_msg         data to fifo                tstb                bmi     17f** move data now*                jsr     wzff2mem        pseudo DMA*20              jsr     FIFO_unlock    free the fifo for GPP** common exit*wzrwex          ldd     uicnt         updated processed count                subd    wzxfer,uwzrwex2         std     uicnt                std     0,s           return value*wzokex          ldy     utask                clr     tsact,y99              puls    d,x,y,u,pc** some socket error*17              ldb     #SESKINI        device not active                jsr     sockerr                bra     99b**************************************************************** wskrecv,*** U = wzsock address    UDP*wskrecv         pshs    d,x,y,u                jsr     wskbi                lbmi    cbexit                ldy     #NWP0           fio hardware parameters** check page boundary crossing during transfer*                jsr     wzckpb          wzrqln, wzdma1, wzdma2                bcs     wzokex          zero data*                ldb     #S_RRDFRM       tell GPP                jsr     fio_msg                tstb                lbmi    17b             error                cmpb    #R_CLOSE        is socket closed?                bne     16f                bra     wzrwex*16              jsr     get_F_S         allocate slot + fifo** tell GPP I am ready collec the data and fill the fifo*                ldb     #S_RREAD                jsr     fio_msg         data to fifo                tstb                bmi     17b** move data now*                jsr     wzff2mem        pseudo DMA*                jsr     FIFO_unlock    free the fifo for GPP*                ldd     uistrt          update memory address                addd    wzxfer,u                std     uistrt                ldd     uicnt           update transferred                subd    wzxfer,u                std     uicnt*77              bra     wzokex          normal exit**************************************************************** wskwr, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock TCP** U = sock addresswskwr           equ     *                pshs    d,x,y,u                ldy     #NWP0** check page boundary crossing in transfer*                jsr     wzckpb                bcs     77b             zero data** all checked, good to go*                ldb     #S_RQWR         tell NWP we have data                jsr     fio_msg                tstb                bmi     80f             socket error                cmpb    #R_CLOSE                bne     16f             for now*                ldd     #0              EOF                lbra    wzrwex2*16              jsr     get_F_S         allocate FIFO + transaction slot** move data now*                jsr     wzmem2ff        data from user mem to fifo** fifo filled, now send it*25              ldb     #S_WRITE                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b** transfer completed*                jsr     FIFO_unlock*                lbra    wzrwex          + restore regs** error ?*80              lda     #ESOCK                sta     uerror                nop                puls    d,x,y,u,pc**************************************************************** wsksnd, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock UDP** U = sock addresswsksnd           equ     *                pshs    d,x,y,u                ldy     #NWP0                ldd     #0                std     wzuwrp,u        initialize                ldd     uicnt                std     wzurms,u        how big is transfer** check page boundary crossing in transfer*55              jsr     wzckpb                bcs     77b             zero data** all checked, good to go*                ldb     #S_WRQSTO       tell NWP we have data82              jsr     fio_msg                tstb                bmi     80f             socket error                cmpb    #R_CLOSE                bne     16f             for now*                ldd     #0              EOF                lbra    wzrwex2** repeat next data*81              jsr     wzckpb                lbcs    77b*                ldb     #S_WSNDTM                bra     82b*16              jsr     get_F_S         allocate FIFO + transaction slot** move data now*                jsr     wzmem2ff        data from user mem to fifo** fifo filled, now send it*25              ldb     #S_WSNDTO                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b*** transfer completed*20              jsr     FIFO_unlock                pshs    b                ldd     uistrt                addd    wzxfer,u                std     uistrt                ldd     uicnt                subd    wzxfer,u                std     uicnt* check if all data sits in socket                puls    b                cmpb    #R_SNDTOM        more data                beq     81b                ldd     wzurms,u           zero?                bne     55b*                lbra    wzokex             + restore regs** error ?*80              lda     #ESOCK                sta     uerror                nop                puls    d,x,y,u,pc***************************************************************** wzckpb, check page boundary crossing* set wzrqln, wzdma1 and wzdma2* exit: C=set when data is 0, else C=clear*wzckpb          pshs    y,u                clra                clrb                    one full transation                std     wzdma2,u*                ldd     uicnt           set max for this transaction                beq     88f             do nothing                cmpd    fio_fsz,y                bls     01f             wzrqln should NEVER exceed fio size                ldd     fio_fsz,y01              std     wzrqln,u        tell request length to GPP                std     wzdma1,u        set initial value* check if a 4K page boundary is to be crossed                ldd     uistrt          start address in process space                anda    #$0f            4K                addd    wzrqln,u        add the amount of data                bita    #$f0            4K page overflow?                beq     00f             no, will not cross* it does cross ! cut it in two                ldd     uistrt          first part                pshs    d                negd                anda    #$0f            remaining size in STARTING 4K page                std     wzdma1,u        first part                puls    d                addd    wzrqln,u        remaining size in NEXT 4K page                anda    #$01                std     wzdma2,u00              clc90              puls    y,u,pc88              sec                bra     90b***************************************************************** wzff2mem, move fifo data into user memory* X, Y=NWP0, U=wzsock*wzff2mem        pshs    d,x,y,u         save regs                ldd     wzdma1,u        U still wzsock                trfr    D,W                ldu     fio_dba,y      fifo hardware base address                leau    fifo,u         fifo actual address                ldd     uistrt         process memory address                jsr     mapua2x        D > D offset in XBUFFER                tfr     d,x            set pointer                tfm1    U,X            block move* old U had wzsock address                ldy     6,s             old U from stack                ldd     wzdma2,y        2nd part?                trfr    D,W                beq     01f             nothing to do* W= (second) count ,(X), wzsock                ldd     0,s             first size (done)                addd    uistrt         update memory address                jsr     mapua2x        D >D in XBUFFER                tfr     d,x            set pointer again                tfm1    U,X            block move01              puls    d,x,y,u,pc***************************************************************** wzmem2ff, move user memory data to fifo* X, Y=NWP0, U=wzsock*wzmem2ff        pshs    d,x,y,u         save regs                ldd     wzdma1,u        U still wzsock                trfr    D,W                ldu     fio_dba,y                leau    fifo,u          fifo address                ldd     uistrt          user memory address                jsr     mapua2x                tfr     d,x                tfm1    X,U* old U had wzsock address                ldy     6,s                ldd     wzdma2,y                trfr    D,W                beq     01f*                ldd     0,s             first size(done)                addd    uistrt                jsr     mapua2x                tfr     d,x                tfm1    X,U01              puls    d,x,y,u,pc***************************************************************** nw_int, send signal to socket task*nw_int          equ     *                lda     #$ff                rtswzdebug         pshs    d,x                ldx     #mydebug                jsr     sysmsg                puls    d,x,pcmydebug         fcb     $d,$a                fcc     "**debug**",$d,$a,0* if NET                else                data                nop* if ! NET                endif