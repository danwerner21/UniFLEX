               0001  NET       set    1                               opt    exp  0000                         absSWTPc      Intelligent I/O Proce     13:27:52  Mar 09, 2024   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100                     *EBUG_CONTROL set     %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFD8  SIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  SKPRI     equ    -60       Waiting for socket interrupt               FFBA  POLPRI    equ    -70       poliing priority                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)                                          * -- Configuration constants                                    0009  MAX_TI    equ    9         # Queued terminal interrupts                     *               0001  MAX_DEV   equ    1                     *                     SWTPc      Intelligent I/O Proce     13:27:52  Mar 09, 2024   Page    2Macro Definitions                                                                             *                     * This file contains all the standard macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                          * register references               0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000E  E         equ    14               000F  F         equ    15                                          * indexed addressing in macro's               0000  IX        equ    0               0001  IY        equ    1               0002  IU        equ    2               0003  IS        equ    3                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                          *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                     SWTPc      Intelligent I/O Proce     13:27:52  Mar 09, 2024   Page    3Macro Definitions                                                                                                  *                     * debug macro                     *                                          *dbugm macro output_character                     * lda #'&1                     * lbsr syspch                     * endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          * load W immediate                     ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          * load W direct                     *ldwd    macro                     *        fdb     $1096                     *        fcb     &1&0xff                     *        endm                                          * load W indexed                     ldwx      macro                               fdb    $10A6                               doindx &1,&2                               endm                                          * load W extended                     *ldwe    macro                     *        fdb     $10b6                     *        fdb     &1                     *        endm                                          * load E indexed                     ldex      macro                               fdb    $11a6                               doindx &1                               endm                                          ordx      macro                               fdb    $10aaSWTPc      Intelligent I/O Proce     13:27:52  Mar 09, 2024   Page    4Macro Definitions                                                                  doindx &1,&2                               endm                                          doindx    macro                               if     (&1=0)                               fcb    $84+(&2<<5)                               else                               if     (&1<16)                               fcb    (&2<<5)+(&1&$0f)                               else                               if     (&1>-16)                               fcb    (&2<<5)+($10)+(&1&$0f)                               else                               if     (&1<128)                               fcb    $88+(&2<<5),(&1&$7f)                               endif                               endif                               endif                               endif                               endm                                          * push W on system stack                     pshsw     macro                               fdb    $1038                               endm                                          * pull W from sytemstack                     pulsw     macro                               fdb    $1039                               endm                                          * memory move ++,++                     tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endm                                          * move memory++ to location                     tfm3      macro                               fdb    $113a                               fcb    &1<<4|&2                               endm                                          * move location to memory++                     tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          * logical shift left D                     lsld      macro                               fdb    $1048SWTPc      Intelligent I/O Proce     13:27:53  Mar 09, 2024   Page    5Macro Definitions                                                                  endm                                          * logical shift right D                     lsrd      macro                               fdb    $1044                               endm                                          * arithmetic shift right D                     *asrd    macro                     *        fdb     $1047                     *        endm                                          * negate D                     negd      macro                               fdb    $1040                               endm                                          * ex-or registers                     eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          * add with carry D immediate                     adcdi     macro                               fdb    $1089                               fdb    &1                               endm                                          * increment D                     incd      macro                               fdb    $104c                               endm                                          * decrement D                     decd      macro                               fdb    $104a                               endm                                          * clear D                     clrd      macro                               fdb    $104f                               endm                                          * complement D                     comd      macro                               fdb    $1043                               endm                                          * and D immediate                     anddi     macro                               fdb    $1084SWTPc      Intelligent I/O Proce     13:27:53  Mar 09, 2024   Page    6Macro Definitions                                                                  fdb    &1                               endm                                          * bit D immediate                     bitdi     macro                               fdb    $1085                               fdb    &1                               endm                                          *                     * trfr, transfer registers, allow ALL registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          * exchange, allow ALL registers                     excg      macro                               fcb    $1e                               fcb    &1<<4|&2                               endm                                          * add registers                     *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endm                                          * subtract registers                     subr      macro                               fdb    $1032                               fcb    &1<<4|&2                               endm                                          * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endm                     SWTPc      Intelligent I/O Proce     13:27:53  Mar 09, 2024   Page    7Macro Definitions                                                        * extended addressing mode                     eime      macro                               fcb    $75                               fcb    &1                               fdb    &2                               endm                                          * test immediate memory                     *timex   macro                     *        fcb     $7b                     *        fcb     &1                     *        fdb     &2                     *        endm                                          * put a LED in LIGHTS on                     LEDON     macro                               fcb    $71                               fcb    &1                               fdb    LIGHTS                               endm                                          * put a LED in LIGHTS off                     LEDOFF    macro                               fcb    $72                               fcb    255-&1                               fdb    LIGHTS                               endmSWTPc      Intelligent I/O Proce     13:27:53  Mar 09, 2024   Page    8Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc                     *  0006               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device, indexed by fifo cmnd >>3                     * should match nwp_codes.h  and MAX_S_NUM                     * wzsockdev.t                     *  0000                         org    $0000  0000               D_func0   rmb    2         0  Bad Command  0002               D_func1   rmb    2         1  0004               D_func2   rmb    2         2  0006               D_func3   rmb    2         3  0008               D_func4   rmb    2         4  000A               D_func5   rmb    2         5  000C               D_func6   rmb    2         6  000E               D_func7   rmb    2         7  0010               D_func8   rmb    2         8  0012               D_func9   rmb    2         9  0014               D_funcA   rmb    2         A  0016               D_funcB   rmb    2         B  0018               D_funcC   rmb    2         C  001A               D_funcD   rmb    2         D  001C               D_funcE   rmb    2         E  001E               D_funcF   rmb    2         F                     *  0020               D_func10  rmb    2         10  0022               D_func11  rmb    2         11  0024               D_func12  rmb    2         12  0026               D_func13  rmb    2         13                     *  0028               D_inthan  rmb    2         14 Interrupt poller/handlerSWTPc      Intelligent I/O Proce     13:27:54  Mar 09, 2024   Page    9Device     Table Structure                            002A               D_init    rmb    2         15 Device initialization  002C               D_test    rmb    2         16 Test for device present                     *  002E               D_END     rmb    0         End of common handlers                     SWTPc      Intelligent I/O Proce     13:27:54  Mar 09, 2024   Page   10History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16                     SWTPc      Intelligent I/O Proce     13:27:54  Mar 09, 2024   Page   11IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0400  RAMorg    equ    $0400     28K of RAM - Thru $6FFF               3EFF  RAMend    equ    $3EFF     $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7E00  RAMscrend equ    $7E00               7FE0  ROMstack  equ    $7FE0     High end of ROM Stack                     * BGDB uses 7FF0               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, w5500 socket device                     *Task       Structure                 13:27:54  Mar 09, 2024   Page   12IOP        Memory Layout                                                 *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    00C0  USTSIZ    equ    192       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Device for task is servicing  000F               tsagin    rmb    2         return pointer                     *  0011               usp       rmb    2         Saved User Stack Pointer  0013               umark0    rmb    2         Stack Frame Markers  0015               umark1    rmb    2  0017                         rmb    USTSIZ    space for per/process stack                                    00D7  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system task                     *                     * definition of wz5500 variables                     *                     * [*] items are initialized by the IO CPU                     * others are zeroed out                     *                                          * [*] are setup by GPP CPU                                          *                     * wzfsta bits                     *               0001  WZSLCK    equ    %00000001 sock is locked (equal to fdn)               0002  WZSKIO    equ    %00000010 io modeTask       Structure                 13:27:54  Mar 09, 2024   Page   13IOP        Memory Layout                                           0004  WZSKIS    equ    %00000100 sock is sending               0010  WZWLCK    equ    %00010000 sock task is waiting lock (equal to fdn)               0040  WZSKIP    equ    %01000000 sock interrupt pending               0080  WZBUSY    equ    %10000000 sock is busy                                          *                     * protocol values                     *               0001  SP_ICMP   equ    1         Internet Control Message Protocol               0002  SP_GMP    equ    2         Internet Group Management Protocol               0006  SP_TCP    equ    6         Transmission Control Protocol               0008  SP_EGP    equ    8         Exterior Gateway Protocol               0011  SP_UDP    equ    17        User Datagram Protocol                                          *                     * wzcmd values (w5500), private for IOP                     *               0001  WCOPEN    equ    1         open command               0002  WCLIST    equ    2         list command               0004  WCCONN    equ    4         connect command               0008  WCDISC    equ    8         disconnect               0010  WCCLOS    equ    16        close               0020  WCSEND    equ    32        send               0021  WCSNAC    equ    33        send mac               0022  WCSKEP    equ    34        send keep               0040  WCRECV    equ    64        receive               0080  WCSPEC    equ    128       special, combined commands               0081  WCRRQD    equ    128+1     read request data               0082  WCXMDR    equ    128+2     write data in fifo                                    0085  WCBIND    equ    128+5     bind  CPU<=>GPP               0086  WCACCP    equ    128+6     accpet CPU<=>GPP                     *                     * wzstat values                     *               0000  WSCLSD    equ    $00       sock closed               0013  WSINIT    equ    $13       sock init               0014  WSLIST    equ    $14       sock listen               0017  WSESTB    equ    $17       sock established               001C  WSCLWT    equ    $1c       sock close wait               0022  WSUDP     equ    $22       sock UDP               0042  WSRAW     equ    $42       sock mac raw               0015  WSSYNS    equ    $15       sock syn sent               0016  WSSYNR    equ    $16       sock syn received               0018  WSFWAI    equ    $18       sock fin wiat               001A  WSCLSG    equ    $1a       sock closing               001B  WSTIMW    equ    $1b       sock time wait               001D  WSLACK    equ    $1d       sock last ack               001E  WSRNBL    equ    $1e       sock read non block               001F  WSWNBL    equ    $1f       sock write non block               0080  WSSPEC    equ    $80       special combined commands               0081  WSRRQF    equ    $80+1     read request data in fifoTask       Structure                 13:27:55  Mar 09, 2024   Page   14IOP        Memory Layout                                           0082  WSXMDD    equ    $80+2     xmit data taken from fifo                                          *                     * miscellaneous                     *               0080  PACK_FIRST equ   $80       in non TCP packet start to receive               0001  PACK_REMAI equ   $01       in non TCP packet received               0000  PACK_COMPL equ   $00       in non TCP complete toe receive                                    0001  WFNBLK    equ    $01       in socket() call(wztype << 8)                       0000                         org    $0                     *                     * per wzsocket process and socket data                     *  0000               wzenum    rmb    1         [*] (pre=enum)  0001               wzdctr    rmb    1         [*] (pre= $00)  delay counter  0002               wzfsta    rmb    1         (pre= $00) status bits (SAME POS!! as in fdn)  0003               wzflg     rmb    1         [*] flasgs, i.e. bind                     *  0004               wzcmnd    rmb    1         command byte copy  0005               wzstat    rmb    1         status byte copy  0006               wzupkt    rmb    1         UDP packet flag  0007               wzerr     rmb    1         error code passing                     *  0008               wzxfer    rmb    2         transfer size  000A               wzrqln    rmb    2         requested size                     *  000C               wzdma1    rmb    2         if split xfer, first part  000E               wzdma2    rmb    2         if split xfer, second part                     *                     * unix socket call info                     *  0010               wzsprt    rmb    2         source port  0012               wzdprt    rmb    2         destination port  0014               wzipad    rmb    4         dest IP address  0018               wzsflg    rmb    2         flags                     *                     * udp header info                     *  001A               wzuipa    rmb    4         ip address from UDP header  001E               wzuprt    rmb    2         port number from UDP header  0020               wzurms    rmb    2         socket remained size                     * UDP write pointer  0022               wzuwrp    rmb    2         write pointer save                     *                     * open parameters                     *  0024               wzfaml    rmb    2         family            for check AF_  0026               wztype    rmb    2         type              for check SOCK_  0028               wzprot    rmb    2         protocol          for check IPPROTO_                     Task       Structure                 13:27:55  Mar 09, 2024   Page   15IOP        Memory Layout                                           002A  WZSIZE    equ    *-wzenum                       0000                         org    $0                     *                     * holds the local IP info, wzdev  net0                     * ipad, mask, gwad, macad                     *  0000               wzmyip    rmb    4         Device IP address  0004               wzsbnm    rmb    4         Subnet mask bits  0008               wzgwad    rmb    4         Gateway IP address  000C               wzhwad    rmb    6         Device Hardware address                     *  0012               wzdsta    rmb    1         up/down status  0013                         rmb    3                                    0016  WZLCSZ    equ    *-wzmyip                     *                     * this is (an attempt) to implement the Berkely                     * socket interface into the UniFLEX 6309 kernel (no 6809)                     *  0000                         org    0                                          * struct sockaddr  0000               sa_fam    rmb    2         address family  0002               sa_dat    rmb    14        protocol address               0010  SKADLN    equ    *                                          * struct sockaddr_in  0010               sin_fam   rmb    2         AF_INET  0012               sin_port  rmb    2         16 bit port  0014               sin_addr  rmb    4         32 bit netid/hostid                                          * address families               0000  AF_UNSP   equ    0         AF_UNSPEC               0001  AF_UNIX   equ    1         AF_UNIX               0002  AF_INET   equ    2         AF_INET                                          * socket types               0001  SK_STRM   equ    1         socket stream               0002  SK_DGRM   equ    2         datagram, conn less               0003  SK_RAW    equ    3         raw socket                                          * protocol families               0001  PF_UNIX   equ    AF_UNIX   same as address families               0002  PF_INET   equ    AF_INET                                          *               05C0  MAX_UDP   equ    1472      max size of UDP packet                                          FIO Simulation Structure             13:27:55  Mar 09, 2024   Page   16IOP        Memory Layout                                                                      *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         UIO                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         UIO                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************FIO Simulation Structure             13:27:56  Mar 09, 2024   Page   17IOP        Memory Layout                              0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************FIO Simulation Structure             13:27:56  Mar 09, 2024   Page   18Dual_Port RAM Structure                                                                                            *                     * this is an OVERLAY on a 1Kx8 FIFO in DPR                     *                     * the primary fifo definitions are not touched                     *                     * some locations may be re-used for this purpose                     *               0000  DPR_BASE  equ    $0000     GPP DPR at this address (GPP)  0000                         org    DPR_BASE  -- Dual port RAM address                                          *               0000  nwp_strt  equ    *         first address  of DPR RAM                     *                     ******************************************************  0000                         rmb    32        defined in fio.h                       0020                         rmb    512       fifo space                     ******************************************************               0220  WZSKOFF   equ    *                     ******************************************************  0220               wzsk8     rmb    WZSIZE    sock structure  024A               wzsk7     rmb    WZSIZE    sock  0274               wzsk6     rmb    WZSIZE    sock  029E               wzsk5     rmb    WZSIZE    sock  02C8               wzsk4     rmb    WZSIZE    sock  02F2               wzsk3     rmb    WZSIZE    sock  031C               wzsk2     rmb    WZSIZE    sock  0346               wzsk1     rmb    WZSIZE    sock                     ******************************************************               0370  WZNETOF   equ    *  0370               wlocip    rmb    WZLCSZ    network device                     ******************************************************                     *                     * fifo top                     * specified in fio.h                     *                     ******************************************************                     *                     * IOP ROM Version #                     *               0020  ROM_VERSION equ  $20       Major/Minor Version of IOP ROM                                          *                     * generic and specific transaction codes for use with fio_han                     * these are for IOP                     *                                          *                     * Error codes                     *FIO Simulation Structure             13:27:56  Mar 09, 2024   Page   19Dual_Port RAM Structure                                            0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 Socket error,                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0010  O_OPEN    equ    $10       Open device               0020  O_CLOSE   equ    $20       Close device               0030  O_RQWR    equ    $30       Request write               0040  O_WRITE   equ    $40       Write data via fifo to IOP               0050  O_RQRD    equ    $50       Request read data               0060  O_READ    equ    $60       Read data for via fifo from IOP               0070  O_INTRPT  set    $70       Interrupt all tasks on a terminal               0080  O_WR1C    equ    $80       Write single character               0090  O_TTYS    equ    $90       TTY Set               00A0  O_TTYG    equ    $A0       TTY Get                                    00D0  O_PGETD   equ    $D0       Read baudrate settings               00E0  O_PSETD   equ    $E0       Write baudrate settings                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               000F  R_RESET   equ    $0F       System reset & functioning               0001  R_OPEN    equ    $01       Device open successful               0002  R_CLOSE   equ    $02       Device close successful               0003  R_REQOK   equ    $03       Write request now granted               0004  R_WRITE   equ    $04       Write data complete               0005  R_RDOK    equ    $05       Read data now available               0006  R_READ    equ    $06       Read data in FIFO & no more data is available               0007  R_INTRPT  set    $07       Interrupt complete               0008  R_WR1C    equ    $08       Write single character               0009  R_RD1C    equ    $09       Single character available               000B  R_PDATA   equ    $0B       port data transaction succes               000C  R_READM   equ    $0C       Read data in fifo, more data waiting               000D  R_TTY     equ    $0D       TTYSET/GET complete               000E  R_CLOCK   equ    $0E       Interval Timer Tick                     *                     *                     * fio_codes.h is the leading file, here are                     * ammendments                     *                     *FIO Simulation Structure             13:27:56  Mar 09, 2024   Page   20Dual_Port RAM Structure                                            0003  R_RQWR    set    $03       [S]  Request for write               0005  R_RQRD    set    $05       [S]  Request for read               0007  R_INTRPT  set    $07       [S]  Interrupt complete               0008  R_CONNECT equ    $08       [S]  connect ok               0009  R_BIND    equ    $09       [S]  bind call ok               000A  R_LISTEN  equ    $0A       [S]  listen call ok               000B  R_ACCEPT  equ    $0B       [S]  accept call ok               000C  R_DISCON  equ    $0C       [S]  disconnect happened               000D  R_SNDMAC  equ    $0D       [S]  send mac done               000E  R_SNDKEP  equ    $0E       [S]  send keep alive done               000F  R_SPCL    equ    $0F       [S]  special call ok               0015  R_RQRDNB  equ    $15       [S]  non block return read               0013  R_RQWRNB  equ    $13       [S]  non block return write                     *               0021  R_RDFRM   equ    $21       [S]  request for data readfrom               0022  R_RRDFD   equ    $22       [S]  read data readfrom next packet               0023  R_RSNDTO  equ    $23       [S]  request write sendto               0024  R_WSNDTO  equ    $24       [S]  write data sendto               0025  R_SNDTOM  equ    $25       [S]  write data, request more                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     * Socket functions                     *               0008  S_OPEN    equ    $08       Open socket               0010  S_CLOSE   equ    $10       Close socket               0018  S_RQWR    equ    $18       request write to socket               0020  S_WRITE   equ    $20       Write data to socket               0028  S_RQRD    equ    $28       Request read data from socket               0030  S_READ    equ    $30       Read data from socket               0038  S_INTRPT  equ    $38       Interrupt socket               0038  O_INTRPT  set    S_INTRPT               0040  S_CONNECT equ    $40       Connect socket               0048  S_BIND    equ    $48       Bind socket               0050  S_LISTEN  equ    $50       Listen on socket               0058  S_ACCEPT  equ    $58       Accept connection on socket               0060  S_DISCON  equ    $60       Disconnect socket               0068  S_SNDMAC  equ    $68       Send to mac               0070  S_SNDKEP  equ    $70       Send keep alive               0078  S_SPCL    equ    $78       Special. i.e set network device                     *               0080  S_RRDFRM  equ    $80       request read readfrom               0088  S_RREAD   equ    $88       read data readfrom               0090  S_WRQSTO  equ    $90       request send ssendto               0098  S_WSNDTO  equ    $98       send data sendto               00A0  S_WSNDTM  equ    $a0       send to more data                     *               0015  MAX_S_NUM equ    21        # of supported functions (incl 0)                     *                     * definition of all interrupts in the W5500                     *                     FIO Simulation Structure             13:27:57  Mar 09, 2024   Page   21Dual_Port RAM Structure                                                  *                     * interrupts per socket (Socket registers)                     *               0001  SI_CON    equ    %00000001 Sn_IR(CON)               0002  SI_DIS    equ    %00000010 Sn_IR(DISCON)               0004  SI_RCV    equ    %00000100 Sn_IR(RECV)               0008  SI_TIM    equ    %00001000 Sn_IR(TIMEOUT)               0010  SI_SOK    equ    %00010000 Sn_IR(SEND_OK)                                          *                     * common interrupts  (Common registers)                     *               0010  CI_MP     equ    %00010000 Magic Packet               0020  CI_POC    equ    %00100000 PPoE Close               0040  CI_UNR    equ    %01000000 UNREACH               0080  CI_CFL    equ    %10000000 IP ConflictFIO Simulation Structure             13:27:57  Mar 09, 2024   Page   22Variable   Space                                                           0400                         org    RAMorg                       0400               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"                       0400               DB_iflg   rmb    1         Debug terminal initialized  0401               DB_cntrl  rmb    2         Debug control flags                     *  0403               runlst    rmb    2         Pointer to active tasks  0405               slplst    rmb    4         Pointer to waiting tasks  0409               utask     rmb    2         Currently executing task  040B               jobpri    rmb    1         Current job priority (for scheduling)  040C               chproc    rmb    1         Set if must switch users of CPU (reschedule)                     *  040D               idle      rmb    1         idle loop flag for scheduler  040E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  0444               SI_Q_ptr  rmb    2         current Q pointer  0446               FIO_lock  rmb    1         FIO in use lock  0447               int_buf   rmb    12        Current Message in  0453               int_ptr   rmb    2         Message in pointer  0455               clock_tick rmb   1         Clock tick counter  0456               spiint    rmb    1         Interrupt flag from w5500  0457               wzanyp    rmb    2         Source Port  0459               NUM_TSK   rmb    1         max tasks                       045A               hstbuf    rmb    HRECSIZ*MAXHIST  049A               hstptr    rmb    2         next "put" pointer in history queue                                          * Pointers to system tables - configuration dependent  049C               tsktab    rmb    2         Task Control Tables  049E               tskend    rmb    2         End of task table  04A0               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table                     *  04A6                         rmb    32                       04C6               SYS_TABS  rmb    0         Start of dynamic system tables                                    04C6  lstram    equ    *               3EFF  end_vars  equ    RAMend    End of System Variables                                          FIO Simulation Structure             13:27:57  Mar 09, 2024   Page   23CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 E0B0                    fdb    rom_trap  Unused  FFF2 E0A9                    fdb    rom_swi3  SWI3  FFF4 E0A2                    fdb    rom_swi2  SWI2  FFF6 E095                    fdb    rom_firq  FIRQ  FFF8 E3A4                    fdb    IRQ_han   IRQ  FFFA E09C                    fdb    rom_swi   SWI  FFFC E08F                    fdb    rom_nmi   Background debug  FFFE E071                    fdb    rom_init  Reset                     *                               info   UniFLEX Networking ROM                               info   for CPU09GPP+09NET                               info   At the start of ROM the locations for preset                               info   the network setting are reserved                               info   0000...0005  MAC ADDRESS                               info   0006...0009  IP address                               info   000A...000D  NETMASK                               info   000E...0011  GATEWAY IP address                               info   avoid any duplicate settings!                                          FIO Simulation Structure             13:27:57  Mar 09, 2024   Page   24System     RESET Code                                                      E000                         org    ROMLOorg                                          * start of ROM                     ***************************************************************                     *                     * contains the MAC ADDRESS to be used, make sure that is unique                     *                     * contains the IP address for the interface                     *                     * contains the NETMASK for the interface                     *                     * contains the IP address of the GATEWAY                     *                     **************************************************************                     *                     * REPLACE the defaults with your specific values                     *                     * mac address 6 bytes                            (E000...E005)  E000 FF FF FF FF   wzifma    fcb    $FF,$FF,$FF,$FF,$FF,$FF                     * IP addres for THIS interface (avoid duplicates!!!)  E006 FF FF FF FF   wzifip    fcb    255,255,255,255 (E006...E009)                     * NETMASK  E00A FF FF FF FF   wzifnm    fcb    255,255,255,255 (E00A...E00D)                     * GATEWAY  E00E FF FF FF FF   wzifga    fcb    255,255,255,255 (E00E...E011)                     *                     **************************************************************                       E012 0D 4E 57 50   DBmsg00   fcc    $d,'NWP ROM',0  E01B 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E03B 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E04F 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          * share settings with kernel driver code               E06C  fio_fsz   equ    *         device fifo size               E06E  fio_dsz   equ    *+2       device RAM size               E070  max_trn   equ    *+4       max transactions                     *                     * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and NWP CPU                     *  E06C 0200                    fdb    512       fio_fsz FIFO SIZE  E06E 0400                    fdb    1024      fio_dsz DEVICE SIZE  E070 08                      fcb    8         fio_mxtrn MAX_TRANSACTIONS                     *                     * declaration of offsets and settings                     *               0008  MAX_WZ    equ    8         # of sockets in w5500                                                               *FIO Simulation Structure             13:27:58  Mar 09, 2024   Page   25System     RESET Code                                                    * System RESET code                     *  E071 10CE 7FE0     rom_init  lds    #ROMstack initialize stack pointer  E075                         ldmd   3  E075 113D                    fdb    $113d  E077 03                      fcb    3                               endm                      >E078 BD   E0D1     20        jsr    stbinit   go initialize system memory                       E07B 10FE 049C     30        lds    tsktab    Task 0 Stack  E07F 32   E9 00D7            leas   TSKSIZ,s  E083 17   0155               lbsr   fio_reset  E086 BD   E62A               jsr    skdvini   set the device itself  E089 17   012C               lbsr   timerin                     *                     * Initialization complete - Start executing commands                     *  E08C               fio_start  E08C 7E   E4AD     10        jmp    rsched                                          FIO Simulation Structure             13:27:58  Mar 09, 2024   Page   26ROM        Interrupt Fielders                                              E08F 8D   26       rom_nmi   bsr    rom_int  E091 4E 4D 49 00             fcc    'NMI',0  E095 8D   20       rom_firq  bsr    rom_int  E097 46 49 52 51             fcc    'FIRQ',0  E09C 8D   19       rom_swi   bsr    rom_int  E09E 53 57 49 00             fcc    'SWI',0  E0A2 8D   13       rom_swi2  bsr    rom_int  E0A4 53 57 49 32             fcc    'SWI2',0  E0A9 8D   0C       rom_swi3  bsr    rom_int  E0AB 53 57 49 33             fcc    'SWI3',0  E0B0 8D   05       rom_trap  bsr    rom_int  E0B2 54 52 41 50             fcc    'TRAP',0                       E0B7 8E   E0C4     rom_int   ldx    #ROM_ERR  E0BA BD   F280               jsr    DB_pdata  E0BD 35   10                 puls   x  E0BF BD   F280               jsr    DB_pdata  E0C2 20   FE       rom_bad   bra    *                     *  E0C4 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0FIO Simulation Structure             13:27:58  Mar 09, 2024   Page   27Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0D1 8E   0000     stbinit   ldx    #0        s  clear all variables  E0D4 CC   0000               ldd    #0  E0D7 ED   81       10        std    ,x++  E0D9 8C   3EFF               cmpx   #end_vars done yet?  E0DC 25   F9                 blo    10b                       E0DE CC   0D04               ldd    #DEBUG  E0E1 FD   0401               std    DB_cntrl                                            E0E4 B6   E070               lda    max_trn   shared with main CPU  E0E7 48                      asla             *2  E0E8 8B   04                 adda   #4        fixed system tasks  E0EA B7   0459               sta    NUM_TSK                     * >E0ED 17   0013               lbsr   set_tables go figure out configuration, tables, etc                                          * Initialize Socket Interrupt Queue  E0F0 8E   040E     15        ldx    #SI_Q     set queue empty  E0F3 BF   0444               stx    SI_Q_ptr  E0F6 8E   0447               ldx    #int_buf  reset message in pointer  E0F9 BF   0453               stx    int_ptr                      >E0FC 17   0061     17        lbsr   tskinit   initialize tasks                       E0FF 17   119C     18        lbsr   DB_config display configuration  E102 39                      rts                                          *                     * Set up system tables                     *  E103               set_tables  E103 108E 04A0               ldy    #dev_tab  E107 8E   E5E0               ldx    #DEV_SOCK  E10A AF   22                 stx    dev_type,y  E10C AD   98 2A              jsr    [D_init,x] (skinit)                                          * Compute configuration  E10F CE   E1CA               ldu    #mod_tbl  tables with module refs  E112 AE   C4       12        ldx    mod_type,u  E114 27   09                 beq    20f       jump if end of module table  E116 AD   98 2C              jsr    [D_test,x] check for device  E119 25   04                 bcs    15f       jump if found  E11B 33   44                 leau   MOD_SIZE,u  E11D 20   F3                 bra    12b                     *FIO Simulation Structure             13:27:58  Mar 09, 2024   Page   28Table      Initialization                             E11F               15  E11F               20                     * -- All done setting up configuration                       E11F CC   04C6               ldd    #SYS_TABS start of system tables  E122 1F   03                 tfr    d,u                     * -- Task table  E124 86   D7                 lda    #TSKSIZ  E126 F6   0459               ldb    NUM_TSK  E129 3D                      mul  E12A FF   049C               stu    tsktab >E12D 17   0022               lbsr   sto_chk   check for system table space overflow  E130 FF   049E               stu    tskend                     *                     * -- All done  E133 39            90        rts                     *  E134 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E14B 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                    *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E152 33   CB       sto_chk   leau   d,u       compute new end pointer  E154 1183 3EFF               cmpu   #end_vars overflow?  E158 22   03                 bhi    10f       yes - return error  E15A 1C   FE                 clc              no         - return OK  E15C 39                      rts  E15D 1A   01       10        sec              ..         bad owies  E15F 39                      rts                                          *                     * tskinit - Initialize all tasks                     *  E160 BE   049C     tskinit   ldx    tsktab  E163 BF   0409               stx    utask  E166 F6   0459               ldb    NUM_TSK   # tasks in system  E169 34   04                 pshs   b  E16B 10BE 049C               ldy    tsktab    task 1  E16F 31   A9 00D7            leay   TSKSIZ,y  E173               10                                            E173 86   04       11        lda    #TFREE    mark all tasks free  E175 BC   049C               cmpx   tsktab    is this the system task?FIO Simulation Structure             13:27:59  Mar 09, 2024   Page   29Table      Initialization                             E178 26   02                 bne    15f  E17A 86   05                 lda    #TSYS     the system task is never free  E17C A7   04       15        sta    tsstat,x  E17E 86   FF                 lda    #$FF      not associated with a terminal  E180 A7   0D                 sta    tsdev,x  E182 A7   0E                 sta    tsdev+1,x  E184 33   89 00D7            leau   TSKSIZ,x  initialize stack  E188 CC   E328               ldd    #IO_han  E18B 34   20                 pshs   y  E18D AC   E1                 cmpx   ,s++      task 1?  E18F 26   03                 bne    20f       no - normal I/O handling task  E191 CC   E3F8               ldd    #SI_HAN   yes - special terminal interrupt handling task  E194 36   06       20        pshu   d  E196 EF   88 11              stu    usp,x  E199 EF   88 13              stu    umark0,x  E19C 30   89 00D7            leax   TSKSIZ,x  E1A0 6A   E4                 dec    0,s       done?  E1A2 26   CF                 bne    10b  E1A4 32   61                 leas   1,s       clean up stack  E1A6 CC   0000               ldd    #0        nothing running or sleeping  E1A9 FD   0403               std    runlst  E1AC FD   0405               std    slplst  E1AF FD   0407               std    slplst+tsslnk  E1B2 30   A4                 leax   0,y       start interrupt handling task  E1B4 BD   E553               jsr    makrdy  E1B7 39                      rts                                                               *                     * GPP interrupt timer                     *               8400  tim_base  equ    $8400               8401  tim_rest  equ    $8401                       E1B8 86   00       timerin   lda    #%00000000 D0      (OFF!)  E1BA B7   8400               sta    tim_base  interrupt enable  E1BD 39                      rts                                                         E1BE  timerack  equ    *  E1BE 86   01                 lda    #1  E1C0 B7   8401               sta    tim_rest  reset interrupt  E1C3 39                      rts                       E1C4 B6   8400     timerchk  lda    tim_base  E1C7 84   80                 anda   #%10000000 interrupt flag  E1C9 39                      rtsFIO Simulation Structure             13:27:59  Mar 09, 2024   Page   30IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E1CA  mod_tbl   equ    *  E1CA E5E0 E1D0               fdb    DEV_SOCK,WZ5_name  E1CE 0000                    fdb    0                     *  E1D0 57 35 35 30   WZ5_name  fcc    'W5500_SOCK',0FIO Simulation Structure             13:27:59  Mar 09, 2024   Page   31FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     * it sets the offsets to the sock array and to the device info                     *  E1DB               fio_reset                     * when here, all storage locations have been erased already                     *  E1DB 8E   0000               ldx    #0  E1DE 9F   14                 stx    fifo_get  set Q pointers  E1E0 9F   16                 stx    fifo_put  E1E2 8E   0370               ldx    #WZNETOF  E1E5 9F   1A                 stx    fifo_us1  E1E7 8E   0220               ldx    #WZSKOFF  E1EA 9F   18                 stx    fifo_us0  so that kernel CPU can see it                     * init the 8 SOCK structs  E1EC 86   08                 lda    #8  E1EE A7   84       01        sta    wzenum,x  E1F0 30   88 2A              leax   WZSIZE,x  to next  E1F3 4A                      deca  E1F4 26   F8                 bne    01b                     *  E1F6 BE   E06E               ldx    fio_dsz  E1F9 30   1E                 leax   -2,x      one from top  E1FB CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E1FE C6   FF       fio_wait  ldb    #255      Spin counter                     *  E200               00  E200 6D   84                 tst    0,x       fio_cpuF  E202 27   16                 beq    10f                     *  E204 5A                      decb  E205 26   F9                 bne    00b       jump back if not ready                     *  E207 33   5F                 leau   -1,u  E209 1183 0000               cmpu   #0  E20D 26   EF                 bne    fio_wait  E20F 8E   E04F               ldx    #CPU_down  E212 17   106B               lbsr   DB_pdata  E215 17   1062               lbsr   DB_main  E218 20   C1                 bra    fio_reset                     * reset OK  E21A 39            10        rts                                                               *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     *  E21B BE   0453     fio_irq   ldx    int_ptr   input message pointer  E21E 96   00                 lda    cpu_fio   move REQUESTFIO Simulation Structure             13:27:59  Mar 09, 2024   Page   32FIO        Simulation Routines                        E220 A7   80                 sta    ,x+  E222 DC   01                 ldd    cpu_fio1  sequence # TASK ID  E224 ED   81                 std    ,x++  E226 96   03                 lda    cpu_fio2  specific DATA  E228 A7   80                 sta    ,x+  E22A DC   04                 ldd    cpu_fio3  device major/minor  E22C ED   81                 std    ,x++                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     *  E22E FE   E06E               ldu    fio_dsz  E231 33   5F                 leau   -1,u  E233 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  E235 BF   0453               stx    int_ptr   update pointer  E238 108E 0447               ldy    #int_buf  get message from buffer  E23C A6   A4                 lda    0,y       -- Send interrupt command?  E23E 81   38                 cmpa   #S_INTRPT  E240 26   0D                 bne    30f                     *                     * special case OOB signal                     *  E242 10BF 0453               sty    int_ptr   reset pointer  E246 E6   23                 ldb    3,y       signal  E248 AE   24                 ldx    4,y       SOCK reference                     *  E24A BD   E682               jsr    sdev_sig  send device signal  E24D 20   35                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  E24F BE   049C     30        ldx    tsktab    search for an available task  E252 F6   0459               ldb    NUM_TSK   Number of tasks in system                     *  E255 A6   04       32        lda    tsstat,x  E257 81   04                 cmpa   #TFREE    looking for a "free" task  E259 27   0E                 beq    40f                     *  E25B 30   89 00D7            leax   TSKSIZ,x  E25F 5A                      decb  E260 26   F3                 bne    32b                     *  E262 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated! >E264 BD   E285               jsr    fio_msg  E267 20   1B                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     * move data over into task struct                     *  E269 108E 0447     40        ldy    #int_buf  get message from buffer  E26D 10BF 0453               sty    int_ptr   reset pointerFIO Simulation Structure             13:28:00  Mar 09, 2024   Page   33FIO        Simulation Routines                        E271 E6   A0                 ldb    ,y+       command byte  REQUEST  E273 E7   09                 stb    tscmd,x   save for task  E275 EC   A1                 ldd    ,y++      sequence #    task ID  E277 ED   0A                 std    tsseq,x  E279 E6   A0                 ldb    ,y+       command specific DATA  E27B E7   0C                 stb    tstval,x  E27D EC   A1                 ldd    ,y++      associate with terminal major/minor  E27F ED   0D                 std    tsdev,x  E281 BD   E553               jsr    makrdy    make task ready to run                     *  E284 39            fiointe   rts              exit                                          *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *  E285 34   54       fio_msg   pshs   b,x,u     save register  E287 FE   E06E               ldu    fio_dsz  E28A 33   5E                 leau   -2,u      one off top  E28C D7   09                 stb    fio_cpu   set up mailbox value                       E28E 86   FF       5         lda    #$FF      tell CPU mailbox full  E290 A7   C4                 sta    0,u       fio_cpuF  E292 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  E295 A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  E297 27   06                 beq    20f       jump if consumed                     *  E299 30   1F                 leax   -1,x      time-out yet?  E29B 26   F8                 bne    10b                     *  E29D 20   F3                 bra    05b       try again                     *  E29F 35   D4       20        puls   b,x,u,pc                     *                                          *                     * this is the normal way the IOP sends data to the host CPU                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *  E2A1 34   16       fio_response pshs d,x  E2A3 8D   18                 bsr    FIO_get   access FIO  E2A5 BE   0409               ldx    utask     task ID  E2A8 EC   0A                 ldd    tsseq,x  E2AA DD   0A                 std    fio_cpu1  E2AC EC   0D                 ldd    tsdev,x   device infoFIO Simulation Structure             13:28:00  Mar 09, 2024   Page   34FIO        Simulation Routines                        E2AE DD   0D                 std    fio_cpu3  E2B0 A6   E4                 lda    0,s       get transaction specific value (i.e. error code)  E2B2 97   0C                 sta    fio_cpu2  E2B4 E6   61                 ldb    1,s       is RESPONSE code >E2B6 BD   E285               jsr    fio_msg  E2B9 8D   17                 bsr    FIO_rel   release FIO  E2BB 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  E2BD 34   76       FIO_get   pshs   d,x,y,u   save registers  E2BF 108E 0446     10        ldy    #FIO_lock is the device locked  E2C3 6D   A4                 tst    0,y  E2C5 27   07                 beq    20f       no - go get it                     *  E2C7 C6   CE                 ldb    #FIOPRI   waiting for the FIO  E2C9 BD   E58D               jsr    sleep  E2CC 20   F1                 bra    10b       try again                     *  E2CE 6C   A4       20        inc    0,y       mark in use  E2D0 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  E2D2 34   76       FIO_rel   pshs   d,x,y,u  E2D4 108E 0446               ldy    #FIO_lock  E2D8 6F   A4                 clr    0,y  E2DA BD   E569               jsr    wakeup  E2DD 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E2DF 34   04       FIFOgeta  pshs   b  E2E1 8D   05                 bsr    FIFO_get  E2E3 35   02                 puls   a  E2E5 1E   89                 exg    a,b  E2E7 39                      rts                     *  E2E8 34   12       FIFO_get  pshs   a,x  E2EA DC   12                 ldd    fifo_cnt  any data?  E2EC 27   15                 beq    99f       no - exit                     *  E2EE                         decd   yes       - adjust count  E2EE 104A                    fdb    $104a                               endm  E2F0 DD   12                 std    fifo_cnt  E2F2 9E   14                 ldx    fifo_get  get consumer pointerFIO Simulation Structure             13:28:00  Mar 09, 2024   Page   35FIO        Simulation Routines                        E2F4 E6   88 20              ldb    fifo,x    fetch byte  E2F7 30   01                 leax   1,x       bump pointer  E2F9 BC   E06C               cmpx   fio_fsz   end of fifo?  E2FC 26   03                 bne    10f                     *  E2FE 8E   0000               ldx    #0        reset pointer                     *  E301 9F   14       10        stx    fifo_get                     *  E303 35   92       99        puls   a,x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  E305 34   04       FIFOputa  pshs   b  E307 1F   89                 tfr    a,b  E309 8D   02                 bsr    FIFO_put  E30B 35   84                 puls   b,pc                     *  E30D 34   16       FIFO_put  pshs   d,x  E30F 9E   16                 ldx    fifo_put  get consumer pointer  E311 E7   88 20              stb    fifo,x    store byte  E314 30   01                 leax   1,x       bump pointer  E316 BC   E06C               cmpx   fio_fsz   end of FIFO?  E319 26   03                 bne    10f                     *  E31B 8E   0000               ldx    #0        reset pointer  E31E 9F   16       10        stx    fifo_put                     *  E320 DC   12                 ldd    fifo_cnt  E322                         incd  E322 104C                    fdb    $104c                               endm  E324 DD   12                 std    fifo_cnt  E326 35   96       99        puls   d,x,pcFIO Simulation Structure             13:28:00  Mar 09, 2024   Page   36IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  E328               IO_han    seti   block     interrupts  E328 1A   50                 orcc   #FF|IF                               endm                     *                     * we execute the task belonging to the transaction                     *  E32A               10        clri  E32A 1C   AF                 andcc  #!(FF|IF)                               endm  E32C BE   0409               ldx    utask     get task control block address  E32F A6   09                 lda    tscmd,x   get I/O command                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab                     *  E331 44                      lsra             isolate    command  E332 44                      lsra  E333 44                      lsra                     **        lsra  E334 81   15                 cmpa   #MAX_S_NUM  E336 22   69                 bhi    bad_cmd                     *  E338 48                      lsla             --   word index on command  E339 34   10                 pshs   x  E33B 8E   04A0               ldx    #dev_tab  E33E AE   02                 ldx    dev_type,x get handler table address  E340 10AE 86                 ldy    a,x       get processor address  E343 35   10                 puls   x  E345 34   20                 pshs   y  E347 10AE 0F                 ldy    tsagin,x  if 0, d nothing  E34A 27   0A                 beq    05f       else it is target ponter  E34C 10AF E4                 sty    0,s  E34F 108E 0000               ldy    #0  E353 10AF 0F                 sty    tsagin,x  reset pointer  E356 35   20       05        puls   y         change address  E358 4F                      clra                     *  E359 8E   E386               ldx    #IO_end   interrupt handler address  E35C 34   10                 pshs   x  E35E BE   0409               ldx    utask     task pointer  E361 10EF 88 15              sts    umark1,x  E365 EE   0D                 ldu    tsdev,x   get sock refernceFIO Simulation Structure             13:28:01  Mar 09, 2024   Page   37IO         Command Handler                            E367 1E   03                 exg    d,u  E369 84   07                 anda   #%00000111 mask off address bits  E36B 1E   03                 exg    d,u                     *                     * CALL HANDLER: X=utask, Y=handler address, U=sock address                     *  E36D AD   A4                 jsr    0,y       perform operation & return status  E36F 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     *  E371 BE   0409               ldx    utask     restore task pointer  E374 108C FFFF               cmpy   #$ffff  E378 26   09                 bne    20f                     * task is NOT done yet  E37A 86   BA                 lda    #POLPRI  E37C A7   05                 sta    tsprir,x  at lower prio  E37E BD   E4A7               jsr    change  E381 20   1B                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  E383 BD   E2A1     20        jsr    fio_response                     *                     * task is done                     *  E386               IO_end    seti   mask      interrupts  E386 1A   50                 orcc   #FF|IF                               endm  E388 BE   0409               ldx    utask     restore task control block address  E38B A7   0C                 sta    tstval,x  remember transaction value sent  E38D E7   09                 stb    tscmd,x   and command response  E38F 86   04                 lda    #TFREE    mark task "terminated & free"  E391 A7   04                 sta    tsstat,x  E393 86   FF                 lda    #$FF      disassociate from any terminal  E395 A7   0D                 sta    tsdev,x  E397 A7   0E                 sta    tsdev+1,x  E399 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *  E39B BD   E4AD     90        jsr    rsched    run other tasks >E39E 16   FF87     91        lbra   IO_han                                          *                     * Illegal command                     *  E3A1               bad_cmdFIO Simulation Structure             13:28:01  Mar 09, 2024   Page   38IO         Command Handler                            E3A1 C6   81                 ldb    #E_BADCMD error code  E3A3 39                      rtsFIO Simulation Structure             13:28:01  Mar 09, 2024   Page   39Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *               E3A4  IRQ_han   equ    *                     *                     * Check for FIO Mailbox interrupt                     *  E3A4 BE   E06E     10        ldx    fio_dsz  E3A7 30   1F                 leax   -1,x  E3A9 A6   84                 lda    0,x       cpu_fioF   see if mailbox interrupt  E3AB 27   03                 beq    99f       no - move on  E3AD BD   E21B               jsr    fio_irq   call fio interrupt handler                     *                     *         lbsr    DB_main                     *  E3B0 3B            99        rti              return from interrupt                     *  E3B1 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  E3BC 2D 2D 20 4E   00        fcc    '-- No tasks!',0FIO Simulation Structure             13:28:01  Mar 09, 2024   Page   40Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E3C9 34   36       int_all   pshs   d,x,y  E3CB F6   0459               ldb    NUM_TSK  E3CE C0   02                 subb   #2  E3D0 34   04                 pshs   b  E3D2 BE   049C               ldx    tsktab  E3D5 30   89 01AE            leax   2*TSKSIZ,x                     *  E3D9 EC   61       10        ldd    1,s  E3DB 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  E3DE 26   0C                 bne    20f                     *  E3E0 BC   0409               cmpx   utask     make sure I don't get blown away  E3E3 27   07                 beq    20f                     *  E3E5 34   16                 pshs   d,x  E3E7 BD   E5C2               jsr    xmtint    interrupt task  E3EA 35   16                 puls   d,x                     *  E3EC 30   89 00D7  20        leax   TSKSIZ,x  next task  E3F0 6A   E4                 dec    0,s       more tasks?  E3F2 26   E5                 bne    10b  E3F4 32   61                 leas   1,s                     *  E3F6 35   B6                 puls   d,x,y,pc  returnFIO Simulation Structure             13:28:02  Mar 09, 2024   Page   41Terminal   Interrupt Handling Task                                                            *                     * SI_HAN Socket interrupt handler                     *  E3F8 108E 040E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  E3FC                         seti  E3FC 1A   50                 orcc   #FF|IF                               endm  E3FE FE   0444               ldu    SI_Q_ptr  get current Q ptr  E401 1183 040E               cmpu   #SI_Q     anything in Q?  E405 26   07                 bne    20f       yes - go process it                     *  E407 C6   D8                 ldb    #SIQPRI   wait for something to do  E409 BD   E58D               jsr    sleep  E40C 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  E40E E6   C2       20        ldb    0,-u      B = Interrupt #  E410 34   04                 pshs   b  E412 EC   C3                 ldd    0,--u     A = Device #  E414 34   06                 pshs   d  E416 EC   C3                 ldd    0,--u     task ID  E418 34   06                 pshs   d         save registers  E41A FF   0444               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  E41D E6   63                 ldb    3,s       set up to flush all input for this terminal  E41F                         clri   allow     interrupts  E41F 1C   AF                 andcc  #!(FF|IF)                               endm                     *  E421 BD   E2BD               jsr    FIO_get   get access to FIO  E424 EC   E1                 ldd    0,s++     task ID  E426 DD   0A                 std    fio_cpu1  E428 EC   E1                 ldd    ,s++      terminal #  E42A DD   0D                 std    fio_cpu3  terminal  E42C E6   E0                 ldb    ,s+       interrupt #  E42E D7   0C                 stb    fio_cpu2  signal  E430 C6   07                 ldb    #R_INTRPT  E432 BD   E285               jsr    fio_msg   send interrupt message  E435 BD   E2D2               jsr    FIO_rel   release access to FIO  E438 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a socket interrupt                     *   B = Interrupt #                     *   X = task struct                     *   U= wzsock                     *   jsr send_SI                     *FIO Simulation Structure             13:28:02  Mar 09, 2024   Page   42Terminal   Interrupt Handling Task                    E43A 34   76       send_SI   pshs   d,x,y,u   save registers  E43C FE   0444               ldu    SI_Q_ptr  get Q head  E43F 1183 0444               cmpu   #SI_Q_ptr check for overflow  E443 24   11                 bhs    90f       exit if so - sorry                     *  E445 34   04                 pshs   b  E447 EC   0A                 ldd    tsseq,x   task ID @ master side  E449 ED   C1                 std    0,u++  E44B EC   66                 ldd    6,s       [U]wzsock#  E44D ED   C1                 std    0,u++     place value in Queue  E44F 35   04                 puls   b  E451 E7   C0                 stb    0,u+  E453 FF   0444               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  E456 108E 040E     90        ldy    #SI_Q     wake up Queue server  E45A BD   E569               jsr    wakeup  E45D 35   F6                 puls   d,x,y,u,pc return                     FIO Simulation Structure             13:28:02  Mar 09, 2024   Page   43History    Entry Procedures                                                                   *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  E45F 34   16       H_cpu     pshs   d,x  E461 BE   049A               ldx    hstptr    get history queue pointer  E464 96   00                 lda    cpu_fio  E466 A7   84                 sta    hst_cmd,x  E468 96   01                 lda    cpu_fio1  E46A A7   01                 sta    hst_seq,x  E46C 96   04                 lda    cpu_fio3  E46E A7   02                 sta    hst_tty,x  E470 96   03                 lda    cpu_fio2  E472 A7   03                 sta    hst_val,x  E474 30   04                 leax   HRECSIZ,x  E476 8C   049A               cmpx   #hstptr   end of Queue?  E479 25   03                 blo    10f  E47B 8E   045A               ldx    #hstbuf  E47E BF   049A     10        stx    hstptr  E481 35   96                 puls   d,x,pc                                          *                     * H_fio - Place a transaction from the IOP into                     *         the history Queue.                     *  E483 34   16       H_fio     pshs   d,x  E485 BE   049A               ldx    hstptr    get history queue pointer  E488 96   09                 lda    fio_cpu  E48A A7   84                 sta    hst_cmd,x  E48C 96   0A                 lda    fio_cpu1  E48E A7   01                 sta    hst_seq,x  E490 96   0D                 lda    fio_cpu3  E492 A7   02                 sta    hst_tty,x  E494 96   0C                 lda    fio_cpu2  E496 A7   03                 sta    hst_val,x  E498 30   04                 leax   HRECSIZ,x  E49A 8C   049A               cmpx   #hstptr   end of Queue?  E49D 25   03                 blo    10f  E49F 8E   045A               ldx    #hstbuf  E4A2 BF   049A     10        stx    hstptr  E4A5 35   96                 puls   d,x,pcFIO Simulation Structure             13:28:02  Mar 09, 2024   Page   44Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E4A7 BE   0409     change    ldx    utask     point to task table entry >E4AA 17   006D               lbsr   putrun    put on ready list                     *  E4AD               rsched    seti   mask      interrupts  E4AD 1A   50                 orcc   #FF|IF                               endm  E4AF BE   0409               ldx    utask     point to current task  E4B2 10EF 88 13              sts    umark0,x  save stack pointers  E4B6 BE   049C               ldx    tsktab    point to task table  E4B9 8D   23                 bsr    swtchu    switch users  E4BB 7F   040D               clr    idle      reset idle/running flag                     *  E4BE 7F   040C     rsche2    clr    chproc    reset change flag >E4C1 17   0025               lbsr   getjob    get a new task  E4C4 26   0C                 bne    rsche3    find one?                                          ***+++                     ***---                       E4C6 86   7F       05        lda    #127      set higheset priority  E4C8 B7   040B               sta    jobpri    set as current  E4CB                         clri   clear     interrupts  E4CB 1C   AF                 andcc  #!(FF|IF)                               endm                     * idle work could go on here  E4CD 12                      nop  E4CE                         seti  E4CE 1A   50                 orcc   #FF|IF                               endm  E4D0 20   EC                 bra    rsche2    loop til find a ready one                     *  E4D2 F7   040B     rsche3    stb    jobpri    set new priority  E4D5 8D   07                 bsr    swtchu    switch users top pageFIO Simulation Structure             13:28:03  Mar 09, 2024   Page   45Scheduler  routines                                   E4D7 BE   0409               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  E4DA CC   0001               ldd    #1        return 1 to new task  E4DD 39                      rts              return                                              *                     * Switch users                     *   X - Task entry for new task                     *  E4DE 35   20       swtchu    puls   y         get return address  E4E0 BF   0409               stx    utask     set up new running task  E4E3 10EE 88 13              lds    umark0,x  reset stack                                          ***+++                     ***---                       E4E7 6E   A4                 jmp    0,y       return to caller                                          ***+++                     ***---                                                                                    ***+++                     ***---                                          FIO Simulation Structure             13:28:03  Mar 09, 2024   Page   46Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       E4E9 5F            getjob    clrb             clear      flag  E4EA BE   0403               ldx    runlst    point to head of list  E4ED 27   1F                 beq    getjo6    empty list?                     *  E4EF A6   04       getjo1    lda    tsstat,x  get status byte  E4F1 81   01                 cmpa   #TRUN     is it in run state?  E4F3 26   1B                 bne    getjo8                     *  E4F5 5D                      tstb             first      in list?  E4F6 27   06                 beq    getjo2                     *  E4F8 EC   84                 ldd    tslink,x  remove from list  E4FA ED   A4                 std    tslink,y  E4FC 20   07                 bra    getjo4                     *  E4FE 10AE 84       getjo2    ldy    tslink,x  remove from list head  E501 10BF 0403               sty    runlst    set new head                     *  E505 E6   05       getjo4    ldb    tsprir,x  get priority  E507 6F   84                 clr    tslink,x  zero out link  E509 6F   01                 clr    tslink+1,x so not run list  E50B 86   FF                 lda    #$ff      set ne status  E50D 39                      rts              return                         *  E50E 4F            getjo6    clra             set        eq status  E50F 39                      rts                     *  E510 1F   12       getjo8    tfr    x,y       save old pos  E512 AE   84                 ldx    tslink,x  follow link  E514 27   F8                 beq    getjo6                     *  E516 C6   01                 ldb    #1        set flag  E518 20   D5                 bra    getjo1    repeat loop                     FIO Simulation Structure             13:28:03  Mar 09, 2024   Page   47Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       E51A 34   01       putrun    pshs   cc        save status  E51C                         seti   mask      interrupts  E51C 1A   50                 orcc   #FF|IF                               endm  E51E 10BE 0403               ldy    runlst    point to head  E522 26   0A                 bne    putru2  E524 BF   0403               stx    runlst    set new head                     *  E527 CC   0000     putru1    ldd    #0        set last link  E52A ED   84                 std    tslink,x  E52C 35   81                 puls   cc,pc     return                     *  E52E E6   05       putru2    ldb    tsprir,x  get priority  E530 E1   25                 cmpb   tsprir,y  look for correct prior slot  E532 2F   08                 ble    putru4                     *  E534 FC   0403               ldd    runlst  E537 BF   0403               stx    runlst    set new head  E53A 20   0F                 bra    putru5    link in rest                     *  E53C 1F   23       putru4    tfr    y,u       save last look  E53E 10AE A4                 ldy    tslink,y  follow link  E541 27   0C                 beq    putru6                     *  E543 E1   25                 cmpb   tsprir,y  check priority  E545 2F   F5                 ble    putru4                     *  E547 EC   C4                 ldd    tslink,u  link into list here  E549 AF   C4                 stx    tslink,u                     *  E54B ED   84       putru5    std    tslink,x  E54D 35   81                 puls   cc,pc     return                     *  E54F AF   C4       putru6    stx    tslink,u  E551 20   D4                 bra    putru1    go zero last link                     FIO Simulation Structure             13:28:03  Mar 09, 2024   Page   48Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E553 86   01       makrdy    lda    #TRUN     set status  E555 A7   04                 sta    tsstat,x  E557 CC   0000               ldd    #0        clear events flag  E55A ED   06                 std    tsevnt,x  E55C 8D   BC                 bsr    putrun    put on ready list  E55E E6   05                 ldb    tsprir,x  get priority  E560 F1   040B               cmpb   jobpri    higher than current?  E563 2F   03                 ble    makrd6                     *  E565 7C   040C               inc    chproc    set change flag                     *  E568 39            makrd6    rts              return    FIO Simulation Structure             13:28:04  Mar 09, 2024   Page   49Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E569 34   57       wakeup    pshs   cc,d,x,u  save registers  E56B                         seti   mask      interupts  E56B 1A   50                 orcc   #FF|IF                               endm  E56D CE   0405               ldu    #slplst  E570 AE   42                 ldx    tsslnk,u  point to sleep list  E572 27   0B                 beq    wakeu4                     *  E574 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E577 27   08                 beq    wakeu5  E579 33   84                 leau   0,x       mark this entry                     *  E57B AE   02       wakeu3    ldx    tsslnk,x  follow chain  E57D 26   F5                 bne    wakeu2    end of list?                     *  E57F 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E581 34   70       wakeu5    pshs   x,y,u     save registers  E583 EC   02                 ldd    tsslnk,x  remove from list  E585 ED   42                 std    tsslnk,u  E587 8D   CA                 bsr    makrdy    put on ready list  E589 35   70                 puls   u,x,y  E58B 20   EE                 bra    wakeu3    repeat                     FIO Simulation Structure             13:28:04  Mar 09, 2024   Page   50Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  E58D 34   51       sleep     pshs   cc,x,u    save registers  E58F BE   0409               ldx    utask     point to task  E592 6D   08                 tst    tssgnl,x  any signals waiting?  E594 26   1F                 bne    sleep7                     *  E596                         seti   mask      ints  E596 1A   50                 orcc   #FF|IF                               endm  E598 E7   05                 stb    tsprir,x  set priority  E59A 10AF 06                 sty    tsevnt,x  set event  E59D 86   02                 lda    #TSLEEP   set status  E59F A7   04                 sta    tsstat,x  E5A1 FC   0407               ldd    slplst+tsslnk get head of list  E5A4 ED   02                 std    tsslnk,x  set new link  E5A6 BF   0407               stx    slplst+tsslnk set new head  E5A9 17   FF01               lbsr   rsched    reschedule cpu                       E5AC BE   0409     20        ldx    utask     get task entry  E5AF 6D   08                 tst    tssgnl,x  any signals waiting?  E5B1 26   02                 bne    sleep7                     *  E5B3 35   D1                 puls   cc,x,u,pc return                     *  E5B5 BE   0409     sleep7    ldx    utask     reset signal  E5B8 6F   08                 clr    tssgnl,x  E5BA EC   88 15              ldd    umark1,x  stack reset point  E5BD 35   51                 puls   cc,x,u    reset cc and registers  E5BF 1F   04                 tfr    d,s       change stacks  E5C1 39                      rts              returnFIO Simulation Structure             13:28:04  Mar 09, 2024   Page   51Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  E5C2 34   76       xmtint    pshs   d,x,y,u   save registers  E5C4 A6   04                 lda    tsstat,x  get task state  E5C6 81   01                 cmpa   #TRUN     running?  E5C8 26   06                 bne    10f       no - try something else                     *  E5CA 86   01                 lda    #1        set signal  E5CC A7   08                 sta    tssgnl,x  E5CE 20   0E                 bra    99f       exit                     *  E5D0 81   02       10        cmpa   #TSLEEP   task sleeping?  E5D2 26   0A                 bne    99f       no - can't send interrupt                     *  E5D4 86   01                 lda    #1        set signal  E5D6 A7   08                 sta    tssgnl,x  E5D8 10AE 06                 ldy    tsevnt,x  wake task up >E5DB 17   FF8B               lbsr   wakeup                     *  E5DE 35   F6       99        puls   d,x,y,u,pc returnFIO Simulation Structure             13:28:04  Mar 09, 2024   Page   52Sleep      and Wakeup routines                                                                *                     * the routines in this file are specific                     * for the W5500 socket device                     * they are called from "wskhan" and "wskdrv" files                     *                     * wzsocket device table                     *  E5E0               DEV_SOCK  E5E0 E3A1                    fdb    bad_cmd   0  E5E2 E6C3                    fdb    skopen    S_OPEN    1 open socket  E5E4 E75B                    fdb    skclos    S_CLOSE   2 close socket  E5E6 E95B                    fdb    skreqwr   S_RQWR    3 request write to socket  E5E8 E9A2                    fdb    sksend    S_SEND    4 write data to socket  E5EA E8EC                    fdb    skreqrd   S_RQRD    5 request read data from socket  E5EC E939                    fdb    skrecv    S_RECV    6 read data from socket  E5EE EC0A                    fdb    skintrp   S_INTRPT  7 interrupt socket  E5F0 E7A8                    fdb    skconn    S_CONNECT 8 connect socket  E5F2 E83E                    fdb    skbind    S_BIND    9 bind socket  E5F4 E883                    fdb    sklist    S_LISTEN  10 listen on socket  E5F6 E8B5                    fdb    skacpt    S_ACCEPT  11 accept connection  E5F8 EC0A                    fdb    skdisc    S_DISCON  12 disconnect socket  E5FA EC0A                    fdb    sksmac    S_SNDMAC  13 send mac  E5FC EC0A                    fdb    skskep    S_SNDKEP  14 send keep alive  E5FE EB38                    fdb    skspcl    S_SPCL    15 special command  E600 E9C4                    fdb    skurrdf   S_RRDFRM  16 request read readfrom  E602 EA37                    fdb    skurrd    S_RREAD   17 read data readfrom  E604 EA61                    fdb    skurwt    S_WRQSTO  18 request write sendto  E606 EB02                    fdb    skusnt    S_WSNDTO  19 write data sendto  E608 EAB0                    fdb    skusnm    S_WSNDTM  20 write data send more                     *  E60A E681                    fdb    skinthan  16 socket interrupt handler  E60C E610                    fdb    skinit    17 socket initialization  E60E E67E                    fdb    sktest    18 test device present                     *                     *                     * this file contains all socket handlers                     *                     * when a wzsocket is opened, all locations are effectively                     * cleared to zero, with exception of the enumeration byte                     *                                          *                     * do everything to init the system                     *               E610  skinit    equ    *  E610 BD   EC11               jsr    spinit    set SPI  E613 C6   82                 ldb    #%10000010 software reset + force ARP  E615 BD   ECE1               jsr    PCRMR  E618 BD   ECD2     01        jsr    GCRMR  E61B 5D                      tstb  E61C 2B   FA                 bmi    01bFIO Simulation Structure             13:28:05  Mar 09, 2024   Page   53wz socket interface routines                                             *  E61E C6   78                 ldb    #%01111000 power up  E620 BD   EEBF               jsr    PCRPHY    set the PHY part  E623 CC   8000               ldd    #32768  E626 FD   0457               std    wzanyp    set value for Source port  E629 39                      rts                                          *                     * check if ROM locations are preset, if not skip this here                     * else setup device with provided values                     *  E62A 108E E000     skdvini   ldy    #wzifma   where mac address is to be found  E62E EC   A1       03        ldd    0,y++  E630 1083 FFFF               cmpd   #$ffff    not set  E634 26   07                 bne    02f  E636 108C E012               cmpy   #wzifga+4 past area  E63A 25   F2                 blo    03b                     * ROM not initialized, do nothing  E63C 39                      rts                                          *                     * values present, setup device                     *  E63D 34   66       02        pshs   d,y,u  E63F DE   1A                 ldu    fifo_us1  E641 108E E006               ldy    #wzifip   source IP  E645 EC   A1                 ldd    0,y++  E647 ED   C1                 std    0,u++  E649 EC   A1                 ldd    0,y++  E64B ED   C1                 std    0,u++  E64D 108E E00A               ldy    #wzifnm   netmask  E651 EC   A1                 ldd    0,y++  E653 ED   C1                 std    0,u++  E655 EC   A1                 ldd    0,y++  E657 ED   C1                 std    0,u++  E659 108E E00E               ldy    #wzifga   gateway ip  E65D EC   A1                 ldd    0,y++  E65F ED   C1                 std    0,u++  E661 EC   A1                 ldd    0,y++  E663 ED   C1                 std    0,u++  E665 108E E000               ldy    #wzifma   mac address  E669 EC   A1                 ldd    0,y++  E66B ED   C1                 std    0,u++  E66D EC   A1                 ldd    0,y++  E66F ED   C1                 std    0,u++  E671 EC   A1                 ldd    0,y++  E673 ED   C1                 std    0,u++                     *  E675 C6   FF                 ldb    #$ff      set active  E677 E7   C4                 stb    0,u  E679 BD   EB67               jsr    wzdev     init device with settings  E67C 35   E6                 puls   d,y,u,pcFIO Simulation Structure             13:28:05  Mar 09, 2024   Page   54wz socket interface routines                                                                  *                     * test if device is present                     *  E67E 1A   01       sktest    sec              yes  E680 39                      rts                                          *                     * skinthan, fromddevice table                     *               E681  skinthan  equ    *  E681 39                      rts                                          *                     * device signal handle, from master                     *               E682  sdev_sig  equ    *  E682 39                      rts                                          *                     * get a new source port                     *  E683 FC   0457     sknewp    ldd    wzanyp    else create one  E686                         incd  E686 104C                    fdb    $104c                               endm  E688 1083 FFF0               cmpd   #$FFF0  E68C 25   03                 blo    03f  E68E CC   8000               ldd    #$8000  E691 FD   0457     03        std    wzanyp  E694 39                      rts                                                               *                     * check if W5500 is active                     * wzdevt, device test, return Z if running, NZ if not                     *  E695 34   22       wzdevt    pshs   a,y  E697 109E 1A                 ldy    fifo_us1  device info  E69A A6   A8 12              lda    wzdsta,y  E69D 81   FF                 cmpa   #$ff      open  E69F 35   A2                 puls   a,y,pc                                          *                     * skfres, socket restore info, set E register                     *  E6A1 A6   C4       skfres    lda    wzenum,u  socket #, is remembered  E6A3                         trfr   A,E  E6A3 1F                      fcb    $1f  E6A4 8E                      fcb    A<<4|E                               endm  E6A5 6F   47                 clr    wzerr,u   init resultFIO Simulation Structure             13:28:05  Mar 09, 2024   Page   55wz socket interface routines                          E6A7 39                      rts                                          *                     * skctcp, check if in TCP mode                     * return zero if in TCP mode, non-zero if not                     * U = wzsock                     *  E6A8 34   06       skctcp    pshs   d  E6AA EC   C8 26              ldd    wztype,u  SOCK_STREAM  E6AD C1   01                 cmpb   #SK_STRM  is TCP  E6AF 35   86                 puls   d,pc                                          *                     * skcudp, check if in UDP mode                     * return zero if in UDP mode, non-zero if not                     * U = wzsock                     *  E6B1 34   06       skcudp    pshs   d  E6B3 EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E6B6 C1   02                 cmpb   #SK_DGRM  is UDP  E6B8 35   86                 puls   d,pc                                          *                     * skraw, check if in RAW mode                     * return zero if in RAW mode, non-zero if not                     * U = wzsock                     *  E6BA 34   06       skcraw    pshs   d  E6BC EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E6BF C1   03                 cmpb   #SK_RAW   is RAW socket  E6C1 35   86                 puls   d,pc                                          ****************************************************************                     *                     * here the socket is opened                     * X hold the TASK table                     * U holds the sock address                     *               E6C3  skopen    equ    * >E6C3 BD   E6A1               jsr    skfres                     *                     * check if DEVICE is active                     * >E6C6 BD   E695               jsr    wzdevt  E6C9 27   06                 beq    11f  E6CB BD   E776               jsr    skclin    NO, close internal and don't start >E6CE 16   005C     04        lbra   skoper1                     *                     * retry, we do all things                     *  E6D1 A6   42       11        lda    wzfsta,u  check if allocated by OS  E6D3 2A   F9                 bpl    04b       no, do nothingFIO Simulation Structure             13:28:06  Mar 09, 2024   Page   56wz socket interface routines                                             *                     * check socket() call arguments                     *  E6D5 6F   43                 clr    wzflg,u   erase flags  E6D7 6F   41                 clr    wzdctr,u  init counter  E6D9 EC   C8 24              ldd    wzfaml,u  E6DC C1   02                 cmpb   #AF_INET  E6DE 26   EE                 bne    04b       not supported                     * wztype holds socket type AND socket flags (hibyte)  E6E0 EC   C8 26              ldd    wztype,u  E6E3 C1   01                 cmpb   #SK_STRM  SOCK_STREAM  E6E5 27   1E                 beq    01f  E6E7 C1   02                 cmpb   #SK_DGRM  SOCK_DGRAM  E6E9 27   16                 beq    21f  E6EB C1   03                 cmpb   #SK_RAW   SOCK_RAW  E6ED 26   42                 bne    skoper2                     *                     * raw socket, set protocol register first                     * UDP and TCP are handled in a different way                     *  E6EF EC   C8 28              ldd    wzprot,u  what is the protocol option?  E6F2 C1   06                 cmpb   #SP_TCP   not allowed  E6F4 27   3B                 beq    skoper2  E6F6 C1   11                 cmpb   #SP_UDP   not allowed  E6F8 27   37                 beq    skoper2  E6FA BD   F022               jsr    PSRPROT   set protocol register                     *  E6FD C6   04                 ldb    #%00000100 MACRAW  E6FF 20   06                 bra    07f                     * dgram  E701 C6   02       21        ldb    #%00000010 UDP  E703 20   02                 bra    07f                     * TCP socket  E705 C6   01       01        ldb    #%00000001 TCP set source port in connect                     *                     * set socket mode register                     *  E707 BD   EEEC     07        jsr    PSRMR     set socket mode register                     *                     * here do the real OPEN,                     *  E70A C6   01                 ldb    #WCOPEN   open the device  E70C E7   44                 stb    wzcmnd,u  copy command  E70E BD   EF0A               jsr    PSRCR  E711 108E 0000               ldy    #0        nopoll                     *                     * interrupts not expected                     *               E715  skowfo    equ    *  E715 BD   EF3E     21        jsr    GSRSR     get status  E718 E7   45                 stb    wzstat,u  E71A C1   00                 cmpb   #WSCLSD   not closed?FIO Simulation Structure             13:28:06  Mar 09, 2024   Page   57wz socket interface routines                          E71C 26   0B                 bne    22f                     *  E71E 6A   41                 dec    wzdctr,u  delay counter  E720 27   0F                 beq    skoper2  E722 108E E715               ldy    #skowfo  E726 7E   E815               jmp    polext    switch tasks                     *  E729 4F            22        clra  E72A C6   01                 ldb    #R_OPEN   response  E72C 39            99        rts                     *  E72D 86   01       skoper1   lda    #1        device not initialized  E72F 20   02                 bra    12f  E731 86   02       skoper2   lda    #2        type error  E733 C6   C0       12        ldb    #E_SOCKET  E735 20   F5                 bra    99b                                          *                     * convert number in bit position                     * B = enum, B=bit                     *  E737 34   10       num2bt    pshs   x  E739 8E   E752               ldx    #bittab  E73C 3A                      abx  E73D E6   84                 ldb    0,x  E73F 35   90                 puls   x,pc                                          *                     * bit to nummer, offset byt one, entry should NOT be 0                     *  E741 34   10       bt2num    pshs   x  E743 8E   E752               ldx    #bittab  E746 6F   E2                 clr    0,-s  E748 E1   80       02        cmpb   0,x+  E74A 27   04                 beq    01f  E74C 6C   E4                 inc    0,s  E74E 20   F8                 bra    02b  E750 35   94       01        puls   b,x,pc                                          * table  E752 00            bittab    fcb    0  E753 01 02 04 08             fcb    %00000001,%00000010,%00000100,%00001000  E757 10 20 40 80             fcb    %00010000,%00100000,%01000000,%10000000                                          ***************************************************************                     *                     * close the socket                     * X hold the task table                     * U holds the sock address                     *               E75B  skclos    equ    *  E75B BD   E6A1               jsr    skfresFIO Simulation Structure             13:28:06  Mar 09, 2024   Page   58wz socket interface routines                          E75E C6   08                 ldb    #WCDISC  E760 E7   44                 stb    wzcmnd,u  E762 BD   EF0A               jsr    PSRCR     send disconnect                     *  E765 8D   0F                 bsr    skclin  E767                         clrd  E767 104F                    fdb    $104f                               endm  E769 ED   C8 24              std    wzfaml,u  E76C ED   C8 26              std    wztype,u  E76F ED   C8 28              std    wzprot,u                     *  E772 4F                      clra  E773 C6   02                 ldb    #R_CLOSE  response  E775 39                      rts                                          *                     * wzclin, close interal                     *  E776 34   06       skclin    pshs   d  E778 C6   10                 ldb    #WCCLOS   do close  E77A E7   44                 stb    wzcmnd,u  E77C BD   EF0A               jsr    PSRCR                     *                     * erase registers in device                     *  E77F CC   0000               ldd    #0  E782 BD   EF5C               jsr    PSRPORT   source port                     *  E785 A6   42                 lda    wzfsta,u  E787 84   F9                 anda   #!(WZSKIO+WZSKIS) reset io mode and is sending  E789 A7   42                 sta    wzfsta,u  E78B CC   0000               ldd    #0  E78E ED   48                 std    wzxfer,u  clear remaining size                     *  E790 BD   EF3E     91        jsr    GSRSR  E793 E7   45                 stb    wzstat,u  stat = 0 (closed)                     *  E795 CC   0000               ldd    #0  E798 ED   C8 10              std    wzsprt,u  erase old info  E79B ED   C8 14              std    wzipad,u  E79E ED   C8 16              std    wzipad+2,u  E7A1 ED   C8 12              std    wzdprt,u  E7A4 E7   43                 stb    wzflg,u   clear flags                     *  E7A6 35   86                 puls   d,pc                                          ***************************************************************                     *                     * connect socket                     * X hold the task table                     * U holds the sock addressFIO Simulation Structure             13:28:06  Mar 09, 2024   Page   59wz socket interface routines                                             * connect() call fills in info in the sock structure                     *               E7A8  skconn    equ    *  E7A8 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E7AB BD   E695               jsr    wzdevt  E7AE 27   06                 beq    01f >E7B0 BD   E75B               jsr    skclos    NO, don't start >E7B3 16   007A     02        lbra   skcner4  E7B6 BD   E6A8     01        jsr    skctcp    not in tcp, illegal  E7B9 26   F8                 bne    02b                     *                     * check if socket has been set up                     *  E7BB BD   EF3E     11        jsr    GSRSR     status  E7BE E7   45                 stb    wzstat,u  check if properly setup  E7C0 C1   13                 cmpb   #WSINIT   SHOULD BE >E7C2 1026 005F               lbne   skcner6                     *                     * check the info from the connect call                     *  E7C6 EC   C8 14              ldd    wzipad,u  check if dest IP == null  E7C9                         ordx   wzipad+2,IU  E7C9 10AA                    fdb    $10aa  E7CB                         doindx wzipad+2,IU  E7CB C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm  E7CD 27   65                 beq    skcner1   IP address == NULL                     * IP address = 0000  E7CF EC   C8 14              ldd    wzipad,u  or FFFFFFFF  E7D2                         incd  E7D2 104C                    fdb    $104c                               endm  E7D4 26   07                 bne    01f  E7D6 EC   C8 16              ldd    wzipad+2,u  E7D9                         incd  E7D9 104C                    fdb    $104c                               endm  E7DB 27   57                 beq    skcner1   IP address = FFFFFFFF                     *                     * valid IP                     *  E7DD EC   C8 12    01        ldd    wzdprt,u  check destination port  E7E0 27   4A                 beq    skcner5   is not set, error                     *  E7E2 BD   EFE6               jsr    PSRDPOR   set destination port  E7E5 31   C8 14              leay   wzipad,u  load socket  E7E8 BD   EFC0               jsr    PSRDIP    set destination IP                     *FIO Simulation Structure             13:28:07  Mar 09, 2024   Page   60wz socket interface routines                                             * source port, create one, always unique                     *  E7EB BD   E683               jsr    sknewp    get new  E7EE ED   C8 10              std    wzsprt,u  tell us what you took  E7F1 BD   EF5C               jsr    PSRPORT   source port                     *                     * do the CONNECT here                     *  E7F4 C6   04                 ldb    #WCCONN  E7F6 E7   44                 stb    wzcmnd,u  E7F8 BD   EF0A               jsr    PSRCR     do connect                     *                     *                     *  E7FB BD   E6A1     conlb1    jsr    skfres  E7FE BD   EF3E               jsr    GSRSR     update status  E801 E7   45                 stb    wzstat,u  E803 C1   17                 cmpb   #WSESTB  E805 27   0A                 beq    90f  E807 C1   00                 cmpb   #WSCLSD  E809 27   16                 beq    skcner2  E80B 108E E7FB               ldy    #conlb1  E80F 20   04                 bra    polext                     *  E811 4F            90        clra  E812 C6   08                 ldb    #R_CONNECT  E814 39            99        rts                                          *                     * polexit, Y=where to return                     *  E815 10AF 0F       polext    sty    tsagin,x  here to restart  E818 C6   BA                 ldb    #POLPRI  E81A E7   05                 stb    tsprir,x  E81C 108E FFFF               ldy    #$ffFF  E820 39                      rts                       E821 C6   0C       skcner2   ldb    #R_DISCON  E823 20   EF                 bra    99b                       E825 BD   E776     skcner6   jsr    skclin    reset open  E828 86   0F                 lda    #15       not properly setup  E82A 20   0E                 bra    09f  E82C 86   0E       skcner5   lda    #14       destination port not set  E82E 20   0A                 bra    09f  E830 86   0A       skcner4   lda    #10       device not initialized  E832 20   06                 bra    09f  E834 86   0B       skcner1   lda    #11       IP address invalid  E836 20   02                 bra    09f  E838 86   0D       skcner3   lda    #13  E83A C6   C0       09        ldb    #E_SOCKET  E83C 20   D6                 bra    99bFIO Simulation Structure             13:28:07  Mar 09, 2024   Page   61wz socket interface routines                                                                  ***************************************************************                     *                     * bind request                     * X hold the task table                     * U holds the sock address                     * bindt() call fills in info in the sock structure                     *               E83E  skbind    equ    *  E83E BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E841 BD   E695               jsr    wzdevt  E844 1026 00EC               lbne   rdrqer1  E848 BD   E6A8               jsr    skctcp    check TCP  E84B 27   12                 beq    01f  E84D BD   E6B1               jsr    skcudp    check UDP >E850 1026 FFD1               lbne   skcner6                     *                     * go on , the bind() call sets wzipad and wzsprt, this is for                     * a server, for a client it needs to set wzdprt                     * for as server IP is local, for a client IP is remote                     *                     *  E854 BD   EF3E               jsr    GSRSR     status  E857 E7   45                 stb    wzstat,u  E859 C1   22                 cmpb   #WSUDP    check  E85B 27   0D                 beq    03f  E85D 20   07                 bra    04f                       E85F BD   EF3E     01        jsr    GSRSR     status  E862 E7   45                 stb    wzstat,u  E864 C1   13                 cmpb   #WSINIT   should be >E866 1026 FFBB     04        lbne   skcner6                     *                     * set the network connection data                     *  E86A BD   E683     03        jsr    sknewp  E86D ED   C8 12              std    wzdprt,u  E870 BD   EFE6               jsr    PSRDPOR   destination port  E873 EC   C8 10              ldd    wzsprt,u  E876 BD   EF5C               jsr    PSRPORT   source port                     *  E879 31   C8 14              leay   wzipad,u  E87C BD   EFC0               jsr    PSRDIP    source IP                     *  E87F 4F                      clra  E880 C6   09                 ldb    #R_BIND  E882 39                      rts                     *                     FIO Simulation Structure             13:28:07  Mar 09, 2024   Page   62wz socket interface routines                                             ***************************************************************                     *                     * listen request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E883  sklist    equ    *  E883 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E886 BD   E695               jsr    wzdevt  E889 1026 00A7     02        lbne   rdrqer1  E88D BD   E6A8               jsr    skctcp  E890 26   F7                 bne    02b                     *                     * go on                     *                     *  E892 BD   EF3E               jsr    GSRSR     status  E895 E7   45                 stb    wzstat,u                     *  E897 C1   00                 cmpb   #WSCLSD   closed?  E899 27   0F                 beq    80f  E89B C1   13                 cmpb   #WSINIT   opened  E89D 26   0F                 bne    90f                     *  E89F C6   02                 ldb    #WCLIST  E8A1 E7   44                 stb    wzcmnd,u  E8A3 BD   EF0A               jsr    PSRCR                     *  E8A6 4F                      clra  E8A7 C6   0A                 ldb    #R_LISTEN  E8A9 39                      rts                                          *  E8AA 4F            80        clra  E8AB C6   02                 ldb    #R_CLOSE  E8AD 39                      rts                     *  E8AE 108E E883     90        ldy    #sklist  E8B2 7E   E815               jmp    polext                                          ***************************************************************                     *                     * accept request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E8B5  skacpt    equ    *FIO Simulation Structure             13:28:08  Mar 09, 2024   Page   63wz socket interface routines                          E8B5 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E8B8 BD   E695               jsr    wzdevt >E8BB 1026 0075     02        lbne   rdrqer1  E8BF BD   E6A8               jsr    skctcp  E8C2 26   F7                 bne    02b       wrong mode                     *                     * go on                     *  E8C4 BD   EF3E               jsr    GSRSR     status  E8C7 E7   45                 stb    wzstat,u  E8C9 C1   17                 cmpb   #WSESTB   connected  E8CB 26   10                 bne    01f  E8CD BD   EFD7               jsr    GSRDPOR   fill in peer port  E8D0 ED   C8 12              std    wzdprt,u  E8D3 31   C8 14              leay   wzipad,u  E8D6 BD   EFA9               jsr    GSRDIP                     *  E8D9 4F                      clra  E8DA C6   0B                 ldb    #R_ACCEPT  E8DC 39                      rts                     *  E8DD C1   00       01        cmpb   #WSCLSD  E8DF 26   04                 bne    02f  E8E1 4F                      clra  E8E2 C6   02                 ldb    #R_CLOSE  E8E4 39                      rts                     *  E8E5 108E E8B5     02        ldy    #skacpt  E8E9 7E   E815               jmp    polext                                                               ***************************************************************                     *                     * read request  TCP only !!                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E8EC  skreqrd   equ    *  E8EC BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E8EF BD   E695               jsr    wzdevt >E8F2 1026 003E     02        lbne   rdrqer1  E8F6 BD   E6A8               jsr    skctcp    check TCP  E8F9 26   F7                 bne    02b                     *                     * go onFIO Simulation Structure             13:28:08  Mar 09, 2024   Page   64wz socket interface routines                                             *                     *  E8FB BD   EF3E               jsr    GSRSR  E8FE E7   45                 stb    wzstat,u  update status  E900 C1   00                 cmpb   #WSCLSD  E902 27   27                 beq    60f  E904 BD   F0F5               jsr    GSRRXRS   data available?  E907 ED   48                 std    wzxfer,u  E909 26   1C                 bne    70f                     *  E90B A6   C8 26              lda    wztype,u  check flags  E90E 85   01                 bita   #WFNBLK   non block  E910 26   11                 bne    75f                     *  E912 E6   45                 ldb    wzstat,u  E914 C1   17       17        cmpb   #WSESTB   still active  E916 27   04                 beq    20f                       E918 C1   1C                 cmpb   #WSCLWT  E91A 27   0F                 beq    60f                     *  E91C 108E E8EC     20        ldy    #skreqrd  E920 7E   E815               jmp    polext                                          *************************  E923 4F            75        clra  E924 C6   15                 ldb    #R_RQRDNB tell no data  E926 39                      rts                                          * data present  E927 4F            70        clra  E928 C6   05                 ldb    #R_RQRD  E92A 39                      rts                                          * close socket and return  E92B C6   01       60        ldb    #HANGS  E92D BD   E43A               jsr    send_SI   send to main CPU  E930 4F                      clra  E931 C6   02                 ldb    #R_CLOSE  E933 39                      rts                                            E934 86   82       rdrqer1   lda    #130  E936 C6   C0                 ldb    #E_SOCKET  E938 39                      rts                                          ***************************************************************                     *                     * get the data  U=wzsock                     *               E939  skrecv    equ    *  E939 BD   E6A1               jsr    skfresFIO Simulation Structure             13:28:08  Mar 09, 2024   Page   65wz socket interface routines                                             *                     * is the DEVICE (still) active                     *  E93C BD   E695               jsr    wzdevt >E93F 1026 FFF1               lbne   rdrqer1  E943 BD   E6A8     02        jsr    skctcp  E946 26   FB                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E948 BD   F0F5               jsr    GSRRXRS   received size                     * D total aviable data  E94B BD   F1C5               jsr    RDSK2FB   transfer datat to fifo  E94E ED   48                 std    wzxfer,u  save it  E950 C6   40                 ldb    #WCRECV  E952 E7   44                 stb    wzcmnd,u  E954 BD   EF0A               jsr    PSRCR     tell sender we took it                       E957 C6   06                 ldb    #R_READ   tell data in fifo  E959 4F                      clra  E95A 39                      rts                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E95B  skreqwr   equ    *  E95B BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E95E BD   E695               jsr    wzdevt >E961 1026 FFCF     02        lbne   rdrqer1  E965 BD   E6A8               jsr    skctcp  E968 26   F7                 bne    02b                     *                     * go on                     *                     *  E96A BD   EF3E               jsr    GSRSR  E96D E7   45                 stb    wzstat,u  update status  E96F C1   00                 cmpb   #WSCLSD  E971 27   12                 beq    30f  E973 BD   F0A9               jsr    GSRTXFR   free size (remaining)  E976 10A3 4A                 cmpd   wzrqln,u  would it fit  E979 24   11                 bhs    70f                     *FIO Simulation Structure             13:28:09  Mar 09, 2024   Page   66wz socket interface routines                          E97B E6   45       10        ldb    wzstat,u  E97D C1   17                 cmpb   #WSESTB  E97F 27   1A                 beq    20f  E981 C1   1C                 cmpb   #WSCLWT  E983 26   0D                 bne    60f  E985 CC   0000     30        ldd    #0  E988 ED   48                 std    wzxfer,u  E98A 20   06                 bra    60f                     * data space  E98C 4F            70        clra  E98D C6   03                 ldb    #R_RQWR  E98F 39                      rts                                          * data space exhausted, would block  E990 4F            72        clra                     **        ldb     #R_RQWRWB  E991 39                      rts                                          * close socket and return  E992 C6   01       60        ldb    #HANGS  E994 BD   E43A               jsr    send_SI   send to main CPU  E997 4F                      clra  E998 C6   02                 ldb    #R_CLOSE  E99A 39                      rts                                          *  E99B 108E E95B     20        ldy    #skreqwr  E99F 7E   E815               jmp    polext                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E9A2  sksend    equ    *  E9A2 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E9A5 BD   E695               jsr    wzdevt >E9A8 1026 FF88     02        lbne   rdrqer1  E9AC BD   E6A8               jsr    skctcp  E9AF 26   F7                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E9B1 BD   F0A9               jsr    GSRTXFR   free size (remaining)                     * D = total available spaceFIO Simulation Structure             13:28:09  Mar 09, 2024   Page   67wz socket interface routines                          E9B4 BD   F214               jsr    WRFB2SK   transfer from fifo to socket  E9B7 ED   48                 std    wzxfer,u  save it  E9B9 C6   20                 ldb    #WCSEND  E9BB E7   44                 stb    wzcmnd,u  E9BD BD   EF0A               jsr    PSRCR     tell sender it is coming                       E9C0 C6   04                 ldb    #R_WRITE  tell data in fifo  E9C2 4F                      clra  E9C3 39                      rts                                          ***************************************************************                     * skurrdf, request readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               E9C4  skurrdf   equ    *  E9C4 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E9C7 BD   E695               jsr    wzdevt  E9CA 1026 FF66     02        lbne   rdrqer1  E9CE BD   E6B1               jsr    skcudp  E9D1 27   05                 beq    03f  E9D3 BD   E6BA               jsr    skcraw  E9D6 26   F2                 bne    02b  E9D8               03                     *                     * go on                     *                     *  E9D8 EC   C8 20              ldd    wzurms,u  check remaining size  E9DB 26   47                 bne    84f                     *                     * no  packet data present, wait for it                     *  E9DD BD   EF3E               jsr    GSRSR  E9E0 E7   45                 stb    wzstat,u  update status  E9E2 C1   00                 cmpb   #WSCLSD  E9E4 27   42                 beq    60f  E9E6 BD   F0F5               jsr    GSRRXRS   data available?  E9E9 ED   7E                 std    -2,s      test D  E9EB 26   15                 bne    22f       keep waiting                     * no data yet, check socket state  E9ED E6   45                 ldb    wzstat,u  E9EF C1   22                 cmpb   #WSUDP    still active  E9F1 27   08                 beq    20f  E9F3 C1   42                 cmpb   #WSRAW  E9F5 27   04                 beq    20f  E9F7 C1   1C                 cmpb   #WSCLWTFIO Simulation Structure             13:28:09  Mar 09, 2024   Page   68wz socket interface routines                          E9F9 27   2D                 beq    60f                     *  E9FB 108E E9C4     20        ldy    #skurrdf  E9FF 7E   E815               jmp    polext                     *                     * first data present, set wzuipa, wzuprt, wzurms                     *  EA02 31   C8 1A    22        leay   wzuipa,u  EA05 CC   0008               ldd    #8        size of header  EA08 BD   EC69               jsr    bmread    copy data                     *                     * move pointer                     *  EA0B BD   F10C               jsr    GSRRXRP  EA0E C3   0008               addd   #8  EA11 BD   F11B               jsr    PSRRXRP   update pointer  EA14 C6   40                 ldb    #WCRECV  EA16 E7   44                 stb    wzcmnd,u  process move  EA18 BD   EF0A               jsr    PSRCR                     *  EA1B EC   C8 20              ldd    wzurms,u  EA1E 1083 05C0               cmpd   #MAX_UDP  max size  EA22 22   0D                 bhi    78f                     *  EA24 4F            84        clra  EA25 C6   21                 ldb    #R_RDFRM  EA27 39                      rts                                          * close socket and return  EA28 C6   01       60        ldb    #HANGS  EA2A BD   E43A               jsr    send_SI   send to main CPU  EA2D 4F                      clra  EA2E C6   02                 ldb    #R_CLOSE  EA30 39                      rts                                          *  EA31 BD   E776     78        jsr    skclin    close  EA34 C6   C0                 ldb    #E_SOCKET  EA36 39                      rts                                          ***************************************************************                     * skurrd,  data readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA37  skurrd    equ    *  EA37 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *FIO Simulation Structure             13:28:10  Mar 09, 2024   Page   69wz socket interface routines                          EA3A BD   E695               jsr    wzdevt  EA3D 1026 FEF3     02        lbne   rdrqer1  EA41 BD   E6B1               jsr    skcudp  EA44 26   F7                 bne    02b                     *                     * go on                     *                     *                     * transfer at most fio_fsz bytes  EA46 EC   C8 20              ldd    wzurms,u  this is leading count                     * D = total available data  EA49 BD   F1C5               jsr    RDSK2FB   transfer data  EA4C 34   06                 pshs   d         xferred count  EA4E EC   C8 20              ldd    wzurms,u  update  EA51 A3   E1                 subd   0,s++  EA53 ED   C8 20              std    wzurms,u  new remaining                     *  EA56 C6   40       01        ldb    #WCRECV  EA58 E7   44                 stb    wzcmnd,u  set processed  EA5A BD   EF0A               jsr    PSRCR                     *  EA5D 4F                      clra  EA5E C6   22                 ldb    #R_RRDFD  EA60 39                      rts                                          ***************************************************************                     * skurwt,  request sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA61  skurwt    equ    *  EA61 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EA64 BD   E695               jsr    wzdevt  EA67 1026 FEC9     02        lbne   rdrqer1  EA6B BD   E6B1               jsr    skcudp  EA6E 27   05                 beq    03f  EA70 BD   E6BA               jsr    skcraw  EA73 26   F2                 bne    02b  EA75               03                     *                     * go on                     *                     *  EA75 EC   C8 12              ldd    wzdprt,u  check illegal port  EA78 1027 0080               lbeq   78f                     *  EA7C EC   C8 14              ldd    wzipad,uFIO Simulation Structure             13:28:10  Mar 09, 2024   Page   70wz socket interface routines                          EA7F                         ordx   wzipad+2,IU  EA7F 10AA                    fdb    $10aa  EA81                         doindx wzipad+2,IU  EA81 C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm >EA83 1027 0075               lbeq   78f                     * set network registers  EA87 EC   C8 12              ldd    wzdprt,u  EA8A BD   EFE6               jsr    PSRDPOR                       EA8D 31   C8 14              leay   wzipad,u  EA90 BD   EFC0               jsr    PSRDIP  EA93 EC   C8 10              ldd    wzsprt,u  EA96 26   11                 bne    04f                     *  EA98 EC   C8 10              ldd    wzsprt,u  already set?  EA9B 26   09                 bne    16f  EA9D BD   E683               jsr    sknewp    get new source port  EAA0 ED   C8 10              std    wzsprt,u  EAA3 ED   C8 1E              std    wzuprt,u  set also return port  EAA6 BD   EF5C     16        jsr    PSRPORT                     *  EAA9 108E EAB0     04        ldy    #skuwr2   do remainder  EAAD 7E   E815               jmp    polext                                          *                     * after intial setup. loop here                     *               EAB0  skusnm    equ    *  EAB0 BD   E6A1     skuwr2    jsr    skfres    set socket base  EAB3 BD   E695               jsr    wzdevt    devie active >EAB6 1026 FFAD               lbne   02b       no  EABA BD   E6B1               jsr    skcudp    check open method  EABD 26   A8                 bne    02b                     *  EABF BD   EF3E               jsr    GSRSR  EAC2 E7   45                 stb    wzstat,u  update status  EAC4 C1   00                 cmpb   #WSCLSD   closed  EAC6 27   2B                 beq    60f  EAC8 BD   F0A9               jsr    GSRTXFR   free size  EACB 10A3 C8 20              cmpd   wzurms,u  EACF 24   15                 bhs    10f                     * no space yet  EAD1 E6   45                 ldb    wzstat,u  EAD3 C1   22                 cmpb   #WSUDP  EAD5 27   08                 beq    20f  EAD7 C1   42                 cmpb   #WSRAW  EAD9 27   04                 beq    20f  EADB C1   1C                 cmpb   #WSCLWT   is closing  EADD 27   14                 beq    60f                     *FIO Simulation Structure             13:28:10  Mar 09, 2024   Page   71wz socket interface routines                          EADF 108E EA61     20        ldy    #skurwt  EAE3 7E   E815               jmp    polext    keep polling                     *  EAE6 EC   C8 20    10        ldd    wzurms,u  EAE9 1083 05C0               cmpd   #MAX_UDP  too big  EAED 22   0D                 bhi    78f                     *  EAEF 4F                      clra  EAF0 C6   23                 ldb    #R_RSNDTO  EAF2 39                      rts                       EAF3 C6   01       60        ldb    #HANGS  EAF5 BD   E43A               jsr    send_SI   send to main CPU  EAF8 4F                      clra  EAF9 C6   02                 ldb    #R_CLOSE  EAFB 39                      rts                       EAFC BD   E776     78        jsr    skclin    close  EAFF C6   C0                 ldb    #E_SOCKET  EB01 39                      rts                                                               ***************************************************************                     * skusnt,  data sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EB02  skusnt    equ    *  EB02 BD   E6A1               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EB05 BD   E695               jsr    wzdevt  EB08 1026 FE28     02        lbne   rdrqer1  EB0C BD   E6B1               jsr    skcudp  EB0F 26   F7                 bne    02b                     *                     * go on                     *                     * transfer fifo to socket data register  EB11 EC   C8 20              ldd    wzurms,u  total data                     *  EB14 BD   F214               jsr    WRFB2SK   fifo to socket  EB17 34   06                 pshs   d  EB19 EC   C8 20              ldd    wzurms,u  all loaded  EB1C A3   E1                 subd   0,s++  EB1E ED   C8 20              std    wzurms,u  EB21 26   11                 bne    01f                       EB23 EC   C8 22              ldd    wzuwrp,u  is it usedFIO Simulation Structure             13:28:10  Mar 09, 2024   Page   72wz socket interface routines                          EB26 BD   F0E6               jsr    PSRTXWP   set write pointer                       EB29 C6   20                 ldb    #WCSEND  EB2B E7   44                 stb    wzcmnd,u  EB2D BD   EF0A               jsr    PSRCR  EB30 4F                      clra  EB31 C6   24                 ldb    #R_WSNDTO data taken  EB33 39                      rts                       EB34 4F            01        clra  EB35 C6   25                 ldb    #R_SNDTOM ask for more  EB37 39                      rts                                          ***************************************************************                     *                     * special function, tstval,x is indicator                     * X hold the task table                     * U holds the SPECIAL sock address (NO wz....  access!)                     *               EB38  skspcl    equ    *                     *  EB38 34   10                 pshs   x  EB3A E6   0C                 ldb    tstval,x  get index  EB3C C1   03                 cmpb   #MAXTBL  EB3E 22   18                 bhi    01f       illegal  EB40 58                      aslb  EB41 8E   EB5F               ldx    #functb  EB44 10AE 85                 ldy    b,x       get special function  EB47 27   0F                 beq    01f       not valid  EB49 35   10                 puls   x                     *  EB4B AD   A4                 jsr    0,y       do function  EB4D 26   05                 bne    90f                     *  EB4F 4F                      clra  EB50 C6   0F                 ldb    #R_SPCL  EB52 20   0A                 bra    99f                     *  EB54 86   A2       90        lda    #162  EB56 20   04                 bra    02f                     *  EB58 35   10       01        puls   x  EB5A 86   A1                 lda    #161  EB5C               02  EB5C C6   C0                 ldb    #E_SOCKET                     *  EB5E 39            99        rts                       EB5F EB67          functb    fdb    wzdev     set device settings  EB61 EB67                    fdb    wzdev  EB63 EBBB                    fdb    showrg  EB65 EB91                    fdb    showconfFIO Simulation Structure             13:28:11  Mar 09, 2024   Page   73wz socket interface routines                                       0003  MAXTBL    equ    ((*-functb)/2)-1                                                               *                     * X hold the task table                     * U holds the special sock address                     *  EB67               wzdev  EB67 C6   08                 ldb    #8  EB69                         trfr   B,E  EB69 1F                      fcb    $1f  EB6A 9E                      fcb    B<<4|E                               endm  EB6B DE   1A                 ldu    fifo_us1  device info area  EB6D 31   C4                 leay   0,u       myip  EB6F BD   EDA1               jsr    PCRSIP    source IP  EB72 31   44                 leay   4,u  EB74 BD   ED35               jsr    PCRSNM    subnet mask  EB77 31   48                 leay   8,u  EB79 BD   ED07               jsr    PCRGA     gateway IP  EB7C 31   4C                 leay   12,u  EB7E BD   ED6B               jsr    PCRSHA    hardware address  EB81 A6   C8 12              lda    18,u      ON/OFF  EB84 27   04                 beq    01f  EB86 C6   F8                 ldb    #%11111000 all on  EB88 20   02                 bra    02f  EB8A C6   78       01        ldb    #%01111000 all off  EB8C BD   EEBF     02        jsr    PCRPHY  EB8F 4F                      clra  EB90 39                      rts                                          *                     * showconf, return settings out of w500 component                     *  EB91               showconf  EB91 C6   08                 ldb    #8  EB93                         trfr   B,E       select first socket  EB93 1F                      fcb    $1f  EB94 9E                      fcb    B<<4|E                               endm  EB95 DE   1A                 ldu    fifo_us1  EB97 33   C8 20              leau   32,u      skip network data area  EB9A 31   C4                 leay   0,u  EB9C BD   ED8A               jsr    GCRSIP  EB9F 31   44                 leay   4,u  EBA1 BD   ED1E               jsr    GCRSNM  EBA4 31   48                 leay   8,u  EBA6 BD   ECF0               jsr    GCRGA  EBA9 31   4C                 leay   12,u  EBAB BD   ED4C               jsr    GCRSHA  EBAE 31   C8 12              leay   18,u  EBB1 CC   0000               ldd    #0FIO Simulation Structure             13:28:11  Mar 09, 2024   Page   74wz socket interface routines                          EBB4 ED   A1                 std    0,y++  EBB6 ED   A1                 std    0,y++  EBB8 ED   A1                 std    0,y++  EBBA 39                      rts                                          *                     *                     *  EBBB               showrg  EBBB C6   08                 ldb    #8  EBBD                         trfr   B,E       select first socket  EBBD 1F                      fcb    $1f  EBBE 9E                      fcb    B<<4|E                               endm  EBBF DE   1A                 ldu    fifo_us1  EBC1 33   C8 20              leau   32,u      skip network data area  EBC4 BD   EEDD               jsr    GSRMR  EBC7 E7   C0                 stb    0,u+  EBC9 BD   EF3E               jsr    GSRSR  EBCC E7   C0                 stb    0,u+  EBCE BD   F06D               jsr    GSRRBFS  EBD1 E7   C0                 stb    0,u+                       EBD3 C6   3D                 ldb    #'=  EBD5 E7   C0                 stb    0,u+                       EBD7 31   C4                 leay   0,u  EBD9 BD   ED8A               jsr    GCRSIP  EBDC 33   44                 leau   4,u  EBDE 31   C4                 leay   0,u  EBE0 BD   ECF0               jsr    GCRGA  EBE3 33   44                 leau   4,u                       EBE5 C6   23                 ldb    #'#  EBE7 E7   C0                 stb    0,u+                       EBE9 31   C4                 leay   0,u  EBEB BD   ED4C               jsr    GCRSHA  EBEE 33   46                 leau   6,u                       EBF0 C6   23                 ldb    #'#  EBF2 E7   C0                 stb    0,u+                       EBF4 31   C4                 leay   0,u  EBF6 BD   ED1E               jsr    GCRSNM  EBF9 33   44                 leau   4,u                       EBFB C6   3D                 ldb    #'=  EBFD E7   C0                 stb    0,u+                       EBFF BD   EECE               jsr    GCRVERS  EC02 ED   C1                 std    0,u++FIO Simulation Structure             13:28:11  Mar 09, 2024   Page   75wz socket interface routines                                               EC04 C6   23                 ldb    #'#  EC06 E7   C4                 stb    0,u  EC08 4F                      clra                       EC09 39                      rts                                                               * X hold the task table                     * U holds the sock address  EC0A               skintrp  EC0A               skdisc  EC0A               sksmac  EC0A               skskep  EC0A 86   FF                 lda    #255  EC0C A7   47                 sta    wzerr,u  EC0E C6   C0                 ldb    #E_SOCKET  EC10 39                      rts                                    EC11  oldorg    set    *                     *                     * hardware register orgaization                     *               8080  SPIBASE   equ    $8080     hardware base address                       0000                         org    0                     *  0000               spicmd    rmb    1         HW control register               0000  spista    equ    spicmd    HW status register  0001               spicon    rmb    1         [W]   HW aux control register  0002                         rmb    2         dummy not used                     * shift register access  0004               hibyta    rmb    1         [R/W] hibyte auto 8 clock pulses for SR  0005               lobyta    rmb    1         [R/W] lobyte auto 8 clock pulses for SR  0006               hibyts    rmb    1         [R/W] hibyte static (no clock)  0007               lobyts    rmb    1         [R/W] lobyte static (no clock)                     *               0080  QFF1      equ    %10000000 [R]                          X               0040  SPI_CS_   equ    %01000000 [R/W] spi chip CS_           1               0020  SPI_RST   equ    %00100000 [R/W] spi chip RST_          1               0010  SPI_IEN   equ    %00010000 [R/W] spi chip INT enabled   0               0008  SPI_AUT   equ    %00001000 [R/W] auto advance           0               0004  SPI_SR_   equ    %00000100 [R/W] shift register MR_     1               0002  SPI_HLD   equ    %00000010 [R/W] HOLD                   0               0001  SPI_CR_   equ    %00000001 [W]   HC163 MR_              1               0001  SPI_IRQ   equ    %00000001 [R]   /IRQ bit               1                     *               0003  RSVREG    equ    %00000011 reserved register address                       EC11                         org    oldorg                                          *FIO Simulation Structure             13:28:12  Mar 09, 2024   Page   76wzspi, basic spi routines                                                * spinit, init the SPI hardware                     *               EC11  spinit    equ    *  EC11 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_ set idle  EC13 B7   8080               sta    SPIBASE+spicmd  EC16 39                      rts                                          *                     * setup inital port for SPI access                     *                     * A,B are lost A=rwflag, F=register, X=offset                     * F=corrected register bits [7...3]                     * A= R/W flag 1=write/ 0= read                     * X,Y untouched                     *               EC17  spistr2   equ    *  EC17 CE   8080               ldu    #SPIBASE  SPI base TODO  EC1A                         trfr   F,B  EC1A 1F                      fcb    $1f  EC1B F9                      fcb    F<<4|B                               endm  EC1C 5D                      tstb             register pointer  EC1D 27   09                 beq    01f       OK, valid  EC1F 34   04                 pshs   b  EC21 C4   03                 andb   #RSVREG   reserved loctation  EC23 5D                      tstb             xxx10xxx  is invalid!  EC24 35   04                 puls   b  EC26 27   1A                 beq    09f       invalid access                     * adjust READ/WRITE bit  EC28 4D            01        tsta             cmd flag  EC29 27   04                 beq    04f  EC2B 1A   01                 sec              write   100  EC2D 20   02                 bra    05f  EC2F 1C   FE       04        clc              read    000                     *  EC31 59            05        rolb             set READ/WRITE bit  [2...0]  EC32 58                      lslb             set variable length data [00]  EC33 58                      lslb                     *                     * here the actual SPI action starts                     *  EC34                         seti   disable   interrupts  EC34 1A   50                 orcc   #FF|IF                               endm  EC36 12                      nop                     *       lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT+SPI_IEN low  EC37 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT low  EC39 A7   C4                 sta    spicmd,u  EC3B AF   44                 stx    hibyta,u  and shift out  EC3D E7   44                 stb    hibyta,u  and shift out  EC3F 1A   04                 sez  EC41 39                      rtsFIO Simulation Structure             13:28:12  Mar 09, 2024   Page   77wzspi, basic spi routines                             EC42 1C   FB       09        clz  EC44 39                      rts                                          *                     * X = offset, unchanged                     * F = register#                     * read BYTE from SPI                     * return B=value, D,X,Y,U preserved                     *               EC45  byterd    equ    *  EC45 34   47                 pshs   cc,d,u  EC47 4F                      clra  EC48 8D   CD                 bsr    spistr2 >EC4A 1026 007E               lbne   09f  EC4E E6   44                 ldb    hibyta,u  extra clocks for first data                     *  EC50 E6   45                 ldb    lobyta,u  read byte  EC52 4F                      clra  EC53 ED   61                 std    1,s  EC55 20   69                 bra    sprend                                          *                     * X = offset                     * F = register#                     * read WORD from SPI                     * return D=value,  D,X,Y,U preserved                     *               EC57  wordrd    equ    *  EC57 34   47                 pshs   cc,d,u  EC59 4F                      clra >EC5A BD   EC17               jsr    spistr2  EC5D 26   6D                 bne    09f  EC5F E6   44                 ldb    hibyta,u  extra clocks for first data                     *  EC61 A6   45                 lda    lobyta,u  read byte  EC63 E6   45                 ldb    lobyta,u  read byte  EC65 ED   61                 std    1,s  EC67 20   57                 bra    sprend                                          *                     * Y=mem pointer, D=count (bytes)                     * F = register#                     * read bytes from SPI into memory location                     * return D,X,Y,U preserved                     *               EC69  bmread    equ    *  EC69 34   77                 pshs   cc,d,x,y,u  EC6B 4F                      clra  EC6C BD   F10C               jsr    GSRRXRP  EC6F 1F   01                 tfr    d,x  EC71 CE   8080               ldu    #SPIBASE  EC74 34   40                 pshs   uFIO Simulation Structure             13:28:12  Mar 09, 2024   Page   78wzspi, basic spi routines                             EC76 1A   50                 orcc   #$50  EC78 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT  EC7A A7   C4                 sta    spicmd,u  EC7C AF   44                 stx    hibyta,u  start address  EC7E BD   F1B6               jsr    tsk2rx  EC81 E7   44                 stb    hibyta,u  EC83 EC   63                 ldd    3,s       old D  EC85                         trfr   D,W       count  EC85 1F                      fcb    $1f  EC86 06                      fcb    D<<4|W                               endm  EC87 1F   12                 tfr    x,y       mem pointer  EC89 10AE 67                 ldy    7,s       old Y  EC8C E7   44                 stb    hibyta,u  shift out  EC8E 33   45                 leau   lobyta,u  EC90                         tfm4   U,Y  EC90 113B                    fdb    $113b  EC92 32                      fcb    U<<4|Y                               endm  EC93 35   40                 puls   u         old U  EC95 86   25                 lda    #SPI_RST+SPI_SR_+SPI_CR_  EC97 A7   C4                 sta    spicmd,u                     * X = old read pointer, 0,s byte wount  EC99 1F   10                 tfr    x,d  EC9B E3   61                 addd   1,s       move pointer  EC9D BD   F11B               jsr    PSRRXRP   update pointer  ECA0 35   F7                 puls   cc,d,x,y,u,pc                                          *                     * X = offset                     * F = register#                     * write BYTE to SPI, D,X,Y,U preserved                     *               ECA2  bytewr    equ    *  ECA2 34   47                 pshs   cc,d,u  ECA4 86   01                 lda    #1  ECA6 BD   EC17               jsr    spistr2  ECA9 26   21                 bne    09f                     *  ECAB A6   62                 lda    2,s  ECAD A7   44                 sta    hibyta,u  ECAF 20   0F                 bra    sprend                                          *                     * X = offset                     * F = register#                     * write WORD to SPI, D,X,Y,U preserved                     *               ECB1  wordwr    equ    *  ECB1 34   47                 pshs   cc,d,u  ECB3 86   01                 lda    #1  ECB5 BD   EC17               jsr    spistr2FIO Simulation Structure             13:28:13  Mar 09, 2024   Page   79wzspi, basic spi routines                             ECB8 26   12                 bne    09f                     *  ECBA EC   61                 ldd    1,s  ECBC A7   44                 sta    hibyta,u  ECBE E7   44                 stb    hibyta,u                     *                     * common exit from SPI action                     *  ECC0 86   65       sprend    lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_                     *sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_+SPI_IEN  ECC2 A7   C4                 sta    spicmd,u  ECC4 A6   E4                 lda    0,s       sez  ECC6 8A   04                 ora    #4  ECC8 A7   E4       02        sta    0,s  ECCA 35   C7                 puls   cc,d,u,pc                     *  ECCC A6   E4       09        lda    0,s       clz  ECCE 84   FB                 anda   #255-4  ECD0 20   F6                 bra    02b                     FIO Simulation Structure             13:28:13  Mar 09, 2024   Page   80wzspi, basic spi routines                                                                     * register names and offset               0000  WZMR      equ    0               0001  WZGAR0    equ    1               0002  WZGAR1    equ    2               0003  WZGAR2    equ    3               0004  WZGAR3    equ    4               0005  WZSUBR0   equ    5               0006  WZSUBR1   equ    6               0007  WZSUBR2   equ    7               0008  WZSUBR3   equ    8               0009  WZSHAR0   equ    9               000A  WZSHAR1   equ    10               000B  WZSHAR2   equ    11               000C  WZSHAR3   equ    12               000D  WZSHAR4   equ    13               000E  WZSHAR5   equ    14               000F  WZSIPR0   equ    15               0010  WZSIPR1   equ    16               0011  WZSIPR2   equ    17               0012  WZSIPR3   equ    18               0013  WZILLT0   equ    19               0014  WZILLT1   equ    20               0015  WZIR      equ    21               0016  WZIMR     equ    22               0017  WZSIR     equ    23               0018  WZSIMR    equ    24               0019  WZRTR0    equ    25               001A  WZRTR1    equ    26               001B  WZRCR     equ    27               0028  WZUIPR0   equ    40               0029  WZUIPR1   equ    41               002A  WZUIPR2   equ    42               002B  WZUIPR3   equ    43               002C  WZUPRT0   equ    44               002D  WZUPRT1   equ    45               002E  WZPHY     equ    46               0039  WZVERS    equ    57                                          *                     * all commands to access common register set                     *                                          *                     * GCRMR, get byte from common registers mode register                     * return byte in B                     *  ECD2 34   56       GCRMR     pshs   d,x,u  ECD4 5F                      clrb  ECD5                         trfr   B,F  ECD5 1F                      fcb    $1f  ECD6 9F                      fcb    B<<4|FFIO Simulation Structure             13:28:13  Mar 09, 2024   Page   81wzspi, basic spi routines                                                          endm  ECD7 8E   0000               ldx    #WZMR  ECDA BD   EC45               jsr    byterd  ECDD ED   E4                 std    0,s  ECDF 35   D6                 puls   d,x,u,pc                                          *                     * PCRMR, put byte B into common registers mode register                     *  ECE1 34   16       PCRMR     pshs   d,x  ECE3 5F                      clrb  ECE4                         trfr   B,F  ECE4 1F                      fcb    $1f  ECE5 9F                      fcb    B<<4|F                               endm  ECE6 8E   0000               ldx    #WZMR  ECE9 EC   E4                 ldd    0,s >ECEB BD   ECA2               jsr    bytewr  ECEE 35   96                 puls   d,x,pc                                          *                     * GCRGA, get gateway address from common regsiters                     * Y=destination address (4 bytes)                     *  ECF0 34   16       GCRGA     pshs   d,x  ECF2 5F                      clrb  ECF3                         trfr   B,F  ECF3 1F                      fcb    $1f  ECF4 9F                      fcb    B<<4|F                               endm  ECF5 8E   0001               ldx    #WZGAR0  ECF8 BD   EC57               jsr    wordrd  ECFB ED   A4                 std    0,y  ECFD 8E   0003               ldx    #WZGAR2  ED00 BD   EC57               jsr    wordrd  ED03 ED   22                 std    2,y  ED05 35   96                 puls   d,x,pc                                          *                     * PCRGW, put gateway address                     * Y=source address (4 bytes)                     *  ED07 34   16       PCRGA     pshs   d,x  ED09 5F                      clrb  ED0A                         trfr   B,F  ED0A 1F                      fcb    $1f  ED0B 9F                      fcb    B<<4|F                               endm  ED0C 8E   0001               ldx    #WZGAR0  ED0F EC   A4                 ldd    0,y >ED11 BD   ECB1               jsr    wordwr  ED14 8E   0003               ldx    #WZGAR2FIO Simulation Structure             13:28:13  Mar 09, 2024   Page   82wzspi, basic spi routines                             ED17 EC   22                 ldd    2,y >ED19 BD   ECB1               jsr    wordwr  ED1C 35   96                 puls   d,x,pc                                          *                     * GCRSNM, get subnet mask  from common regsiters                     * Y=destination address (4 bytes)                     *  ED1E 34   16       GCRSNM    pshs   d,x  ED20 5F                      clrb  ED21                         trfr   B,F  ED21 1F                      fcb    $1f  ED22 9F                      fcb    B<<4|F                               endm  ED23 8E   0005               ldx    #WZSUBR0  ED26 BD   EC57               jsr    wordrd  ED29 ED   A4                 std    0,y  ED2B 8E   0007               ldx    #WZSUBR2  ED2E BD   EC57               jsr    wordrd  ED31 ED   22                 std    2,y  ED33 35   96                 puls   d,x,pc                                          *                     * PCRSNM, put subnet mask address                     * Y=source address (4 bytes)                     *  ED35 34   16       PCRSNM    pshs   d,x  ED37 5F                      clrb  ED38                         trfr   B,F  ED38 1F                      fcb    $1f  ED39 9F                      fcb    B<<4|F                               endm  ED3A 8E   0005               ldx    #WZSUBR0  ED3D EC   A4                 ldd    0,y  ED3F BD   ECB1               jsr    wordwr  ED42 8E   0007               ldx    #WZSUBR2  ED45 EC   22                 ldd    2,y  ED47 BD   ECB1               jsr    wordwr  ED4A 35   96                 puls   d,x,pc                                          *                     * GCRSHA, get gateway hardware address from common regsiters                     * Y=destination address (6 bytes)                     *  ED4C 34   16       GCRSHA    pshs   d,x  ED4E 5F                      clrb  ED4F                         trfr   B,F  ED4F 1F                      fcb    $1f  ED50 9F                      fcb    B<<4|F                               endm  ED51 8E   0009               ldx    #WZSHAR0  ED54 BD   EC57               jsr    wordrdFIO Simulation Structure             13:28:14  Mar 09, 2024   Page   83wzspi, basic spi routines                             ED57 ED   A4                 std    0,y  ED59 8E   000B               ldx    #WZSHAR2  ED5C BD   EC57               jsr    wordrd  ED5F ED   22                 std    2,y  ED61 8E   000D               ldx    #WZSHAR4  ED64 BD   EC57               jsr    wordrd  ED67 ED   24                 std    4,y  ED69 35   96                 puls   d,x,pc                                          *                     * PCRSHA, put gateway hardware address                     * Y=source address (6 bytes)                     *  ED6B 34   16       PCRSHA    pshs   d,x  ED6D 5F                      clrb  ED6E                         trfr   B,F  ED6E 1F                      fcb    $1f  ED6F 9F                      fcb    B<<4|F                               endm  ED70 8E   0009               ldx    #WZSHAR0  ED73 EC   A4                 ldd    0,y  ED75 BD   ECB1               jsr    wordwr  ED78 8E   000B               ldx    #WZSHAR2  ED7B EC   22                 ldd    2,y  ED7D BD   ECB1               jsr    wordwr  ED80 8E   000D               ldx    #WZSHAR4  ED83 EC   24                 ldd    4,y  ED85 BD   ECB1               jsr    wordwr  ED88 35   96                 puls   d,x,pc                                          *                     * GCRSIP, get source IP address from common regsiters                     * Y=destination address (4 bytes)                     *  ED8A 34   16       GCRSIP    pshs   d,x  ED8C 5F                      clrb  ED8D                         trfr   B,F  ED8D 1F                      fcb    $1f  ED8E 9F                      fcb    B<<4|F                               endm  ED8F 8E   000F               ldx    #WZSIPR0  ED92 BD   EC57               jsr    wordrd  ED95 ED   A4                 std    0,y  ED97 8E   0011               ldx    #WZSIPR2  ED9A BD   EC57               jsr    wordrd  ED9D ED   22                 std    2,y  ED9F 35   96                 puls   d,x,pc                                          *                     * PCRSIP, put gateway address                     * Y=source address (4 bytes)                     *FIO Simulation Structure             13:28:14  Mar 09, 2024   Page   84wzspi, basic spi routines                             EDA1 34   16       PCRSIP    pshs   d,x  EDA3 5F                      clrb  EDA4                         trfr   B,F  EDA4 1F                      fcb    $1f  EDA5 9F                      fcb    B<<4|F                               endm  EDA6 8E   000F               ldx    #WZSIPR0  EDA9 EC   A4                 ldd    0,y  EDAB BD   ECB1               jsr    wordwr  EDAE 8E   0011               ldx    #WZSIPR2  EDB1 EC   22                 ldd    2,y  EDB3 BD   ECB1               jsr    wordwr  EDB6 35   96                 puls   d,x,pc                                          *                     * GCRILLT, get byte from interrup low level timer register                     * return word in D                     *  EDB8 34   16       GCRILLT   pshs   d,x  EDBA 5F                      clrb  EDBB                         trfr   B,F  EDBB 1F                      fcb    $1f  EDBC 9F                      fcb    B<<4|F                               endm  EDBD 8E   0013               ldx    #WZILLT0  EDC0 BD   EC57               jsr    wordrd  EDC3 ED   E4                 std    0,s  EDC5 35   96                 puls   d,x,pc                                          *                     * PCRILLT, put word D into common registers mode register                     *  EDC7 34   16       PCRILLT   pshs   d,x  EDC9 5F                      clrb  EDCA                         trfr   B,F  EDCA 1F                      fcb    $1f  EDCB 9F                      fcb    B<<4|F                               endm  EDCC 8E   0013               ldx    #WZILLT0  EDCF EC   E4                 ldd    0,s  EDD1 BD   ECB1               jsr    wordwr  EDD4 35   96                 puls   d,x,pc                                          *                     * GCRIR, get byte from common registers interrupt register                     * return byte in B                     *  EDD6 34   16       GCRIR     pshs   d,x  EDD8 5F                      clrb  EDD9                         trfr   B,F  EDD9 1F                      fcb    $1f  EDDA 9F                      fcb    B<<4|FFIO Simulation Structure             13:28:14  Mar 09, 2024   Page   85wzspi, basic spi routines                                                          endm  EDDB 8E   0015               ldx    #WZIR  EDDE BD   EC45               jsr    byterd  EDE1 ED   E4                 std    0,s  EDE3 35   96                 puls   d,x,pc                                          *                     * PCRIR, put byte B into common registers interrupt register                     *  EDE5 34   16       PCRIR     pshs   d,x  EDE7 5F                      clrb  EDE8                         trfr   B,F  EDE8 1F                      fcb    $1f  EDE9 9F                      fcb    B<<4|F                               endm  EDEA 8E   0015               ldx    #WZIR  EDED EC   E4                 ldd    0,s  EDEF BD   ECA2               jsr    bytewr  EDF2 35   96                 puls   d,x,pc                                          *                     * GCRIMR, get byte from common registers interrupt mask register                     * return byte in B                     *  EDF4 34   16       GCRIMR    pshs   d,x  EDF6 5F                      clrb  EDF7                         trfr   B,F  EDF7 1F                      fcb    $1f  EDF8 9F                      fcb    B<<4|F                               endm  EDF9 8E   0016               ldx    #WZIMR  EDFC BD   EC45               jsr    byterd  EDFF ED   E4                 std    0,s  EE01 35   96                 puls   d,x,pc                                          *                     * PCRIMR, put byte B into common registers interrupt mask register                     *  EE03 34   16       PCRIMR    pshs   d,x  EE05 5F                      clrb  EE06                         trfr   B,F  EE06 1F                      fcb    $1f  EE07 9F                      fcb    B<<4|F                               endm  EE08 8E   0016               ldx    #WZIMR  EE0B EC   E4                 ldd    0,s  EE0D BD   ECA2               jsr    bytewr  EE10 35   96                 puls   d,x,pc                                          *                     * GCRSIR, get byte from common registers socket interrupt register                     * return byte in BFIO Simulation Structure             13:28:15  Mar 09, 2024   Page   86wzspi, basic spi routines                                                *  EE12 34   16       GCRSIR    pshs   d,x  EE14 5F                      clrb  EE15                         trfr   B,F  EE15 1F                      fcb    $1f  EE16 9F                      fcb    B<<4|F                               endm  EE17 8E   0017               ldx    #WZSIR  EE1A BD   EC45               jsr    byterd  EE1D ED   E4                 std    0,s  EE1F 35   96                 puls   d,x,pc                                          *                     * PCRSIR, put byte B into common registers socket interrupt register                     *  EE21 34   16       PCRSIR    pshs   d,x  EE23 5F                      clrb  EE24                         trfr   B,F  EE24 1F                      fcb    $1f  EE25 9F                      fcb    B<<4|F                               endm  EE26 8E   0017               ldx    #WZSIR  EE29 EC   E4                 ldd    0,s  EE2B BD   ECA2               jsr    bytewr  EE2E 35   96                 puls   d,x,pc                                          *                     * GCSIMR, get byte from common registers socket interrupt mask register                     * return byte in B                     *  EE30 34   16       GCRSIMR   pshs   d,x  EE32 5F                      clrb  EE33                         trfr   B,F  EE33 1F                      fcb    $1f  EE34 9F                      fcb    B<<4|F                               endm  EE35 8E   0018               ldx    #WZSIMR  EE38 BD   EC45               jsr    byterd  EE3B ED   E4                 std    0,s  EE3D 35   96                 puls   d,x,pc                                          *                     * PCRSIMR, put byte B into common registers socket interrupt mask register                     *  EE3F 34   16       PCRSIMR   pshs   d,x  EE41 5F                      clrb  EE42                         trfr   B,F  EE42 1F                      fcb    $1f  EE43 9F                      fcb    B<<4|F                               endm  EE44 8E   0018               ldx    #WZSIMR  EE47 EC   E4                 ldd    0,sFIO Simulation Structure             13:28:15  Mar 09, 2024   Page   87wzspi, basic spi routines                             EE49 BD   ECA2               jsr    bytewr  EE4C 35   96                 puls   d,x,pc                                          *                     * GCRRTR, get word from common registers retry register                     * return word in D                     *  EE4E 34   16       GCRRTR    pshs   d,x  EE50 5F                      clrb  EE51                         trfr   B,F  EE51 1F                      fcb    $1f  EE52 9F                      fcb    B<<4|F                               endm  EE53 8E   0019               ldx    #WZRTR0  EE56 BD   EC57               jsr    wordrd  EE59 ED   E4                 std    0,s  EE5B 35   96                 puls   d,x,pc                                          *                     * PCRRTR, put word D into common registers retry register                     *  EE5D 34   16       PCRRTR    pshs   d,x  EE5F 5F                      clrb  EE60                         trfr   B,F  EE60 1F                      fcb    $1f  EE61 9F                      fcb    B<<4|F                               endm  EE62 8E   0019               ldx    #WZRTR0  EE65 EC   E4                 ldd    0,s  EE67 BD   ECB1               jsr    wordwr  EE6A 35   96                 puls   d,x,pc                                          *                     * GCRRCR, get byte from common registers retry count register                     * return byte in B                     *  EE6C 34   16       GCRRCR    pshs   d,x  EE6E 5F                      clrb  EE6F                         trfr   B,F  EE6F 1F                      fcb    $1f  EE70 9F                      fcb    B<<4|F                               endm  EE71 8E   001B               ldx    #WZRCR  EE74 BD   EC45               jsr    byterd  EE77 ED   E4                 std    0,s  EE79 35   96                 puls   d,x,pc                                          *                     * PCRRCR, put byte B into common registers retry count register                     *  EE7B 34   16       PCRRCR    pshs   d,x  EE7D 5F                      clrbFIO Simulation Structure             13:28:15  Mar 09, 2024   Page   88wzspi, basic spi routines                             EE7E                         trfr   B,F  EE7E 1F                      fcb    $1f  EE7F 9F                      fcb    B<<4|F                               endm  EE80 8E   001B               ldx    #WZRCR  EE83 EC   E4                 ldd    0,s  EE85 BD   ECA2               jsr    bytewr  EE88 35   96                 puls   d,x,pc                                          *                     * GCRURP, get word from common registers unreachable port register                     * return word in D                     *  EE8A 34   16       GCRURP    pshs   d,x  EE8C 5F                      clrb  EE8D                         trfr   B,F  EE8D 1F                      fcb    $1f  EE8E 9F                      fcb    B<<4|F                               endm  EE8F 8E   002C               ldx    #WZUPRT0  EE92 BD   EC57               jsr    wordrd  EE95 ED   E4                 std    0,s  EE97 35   96                 puls   d,x,pc                                          *                     * GCRUIP, get unreachable IP address from common registers                     * Y=destination address (4 bytes)                     *  EE99 34   16       GCRUIP    pshs   d,x  EE9B 5F                      clrb  EE9C                         trfr   B,F  EE9C 1F                      fcb    $1f  EE9D 9F                      fcb    B<<4|F                               endm  EE9E 8E   0028               ldx    #WZUIPR0  EEA1 BD   EC57               jsr    wordrd  EEA4 ED   A4                 std    0,y  EEA6 8E   002A               ldx    #WZUIPR2  EEA9 BD   EC57               jsr    wordrd  EEAC ED   22                 std    2,y  EEAE 35   96                 puls   d,x,pc                                          *                     * GCRPHY, get byte from common registers PHY config register                     * return byte in B                     *  EEB0 34   56       GCRPHY    pshs   d,x,u  EEB2 8E   002E               ldx    #WZPHY  EEB5 5F                      clrb  EEB6                         trfr   B,F  EEB6 1F                      fcb    $1f  EEB7 9F                      fcb    B<<4|FFIO Simulation Structure             13:28:15  Mar 09, 2024   Page   89wzspi, basic spi routines                                                          endm  EEB8 BD   EC45               jsr    byterd  EEBB ED   E4                 std    0,s  EEBD 35   D6                 puls   d,x,u,pc                                          *                     * PCRPHY, put byte B into common registers PHY config register                     *  EEBF 34   56       PCRPHY    pshs   d,x,u  EEC1 8E   002E               ldx    #WZPHY  EEC4 5F                      clrb  EEC5                         trfr   B,F  EEC5 1F                      fcb    $1f  EEC6 9F                      fcb    B<<4|F                               endm  EEC7 EC   E4                 ldd    0,s  EEC9 BD   ECA2               jsr    bytewr  EECC 35   D6                 puls   d,x,u,pc                                          *                     * GCRVERS, get byte from common registers socket version register                     * return byte in B                     *  EECE 34   56       GCRVERS   pshs   d,x,u  EED0 8E   0039               ldx    #WZVERS  EED3 5F                      clrb  EED4                         trfr   B,F  EED4 1F                      fcb    $1f  EED5 9F                      fcb    B<<4|F                               endm  EED6 BD   EC45               jsr    byterd  EED9 ED   E4                 std    0,s  EEDB 35   D6                 puls   d,x,u,pc                     *                     * all functions to access socket registers                     *                                          * socket register names and offsets               0000  SNMR      equ    0               0001  SNCR      equ    1               0002  SNIR      equ    2               0003  SNSR      equ    3               0004  SNPORT0   equ    4               0005  SNPORT1   equ    5               0006  SNDHAR0   equ    6               0007  SNDHAR1   equ    7               0008  SNDHAR2   equ    8               0009  SNDHAR3   equ    9               000A  SNDHAR4   equ    10               000B  SNDHAR5   equ    11               000C  SNDIPR0   equ    12               000D  SNDIPR1   equ    13FIO Simulation Structure             13:28:16  Mar 09, 2024   Page   90wzspi, basic spi routines                                          000E  SNDIPR2   equ    14               000F  SNDIPR3   equ    15               0010  SNDPOR0   equ    16               0011  SNDPOR1   equ    17               0012  SNMSSR0   equ    18               0013  SNMSSR1   equ    19               0014  SNPROTO   equ    20               0015  SNTOS     equ    21               0016  SNTTL     equ    22               001E  SNRBFSZ   equ    30               001F  SNTBFSZ   equ    31               0020  SNTXFR0   equ    32               0021  SNTXFR1   equ    33               0022  SNTXRP0   equ    34               0023  SNTXRP1   equ    35               0024  SNTXWP0   equ    36               0025  SNTXWP1   equ    37               0026  SNRXRZ0   equ    38               0027  SNRXRZ1   equ    39               0028  SNRXRP0   equ    40               0029  SNRXRP1   equ    41               002A  SNRXWP0   equ    42               002B  SNRXWP1   equ    43               002C  SNIMR     equ    44               002D  SNFRAG0   equ    45               002E  SNFRAG1   equ    46               002F  SNKATIM   equ    47                                                               *                     * all commands to access socket register set                     *                                                               *                     * GSRMR, get byte from socket registers mode register                     * E=socket#                     * return byte in B                     *  EEDD 34   16       GSRMR     psh    d,x  EEDF BD   F19B               jsr    tsk2rg  EEE2 8E   0000               ldx    #SNMR  EEE5 BD   EC45               jsr    byterd  EEE8 ED   E4                 std    0,s  EEEA 35   96                 puls   d,x,pc                                          *                     * PSRMR, put byte B  to socket registers mode register                     * E=socket#                     *  EEEC 34   16       PSRMR     pshs   d,x  EEEE BD   F19B               jsr    tsk2rgFIO Simulation Structure             13:28:16  Mar 09, 2024   Page   91wzspi, basic spi routines                             EEF1 8E   0000               ldx    #SNMR  EEF4 EC   E4                 ldd    0,s  EEF6 BD   ECA2               jsr    bytewr  EEF9 35   96                 puls   d,x,pc                                          *                     * GSRCR, get bytefrom socket registers command register                     * E=socket#                     * return byte in B                     *  EEFB 34   16       GSRCR     pshs   d,x  EEFD BD   F19B               jsr    tsk2rg  EF00 8E   0001               ldx    #SNCR  EF03 BD   EC45               jsr    byterd  EF06 ED   E4                 std    0,s  EF08 35   96                 puls   d,x,pc                                          *                     * PSRCR, put byte B in socket registers command register                     * E=socket#                     *  EF0A 34   16       PSRCR     pshs   d,x  EF0C BD   F19B               jsr    tsk2rg  EF0F 8E   0001               ldx    #SNCR  EF12 EC   E4                 ldd    0,s  EF14 BD   ECA2               jsr    bytewr  EF17 8D   E2       01        bsr    GSRCR  EF19 5D                      tstb  EF1A 26   FB                 bne    01b       wait command to be consumed  EF1C E7   61                 stb    1,s       set return  EF1E 35   96                 puls   d,x,pc                                          *                     * GSRIR, get bytefrom socket registers interrupt register                     * E=socket#                     * return byte in B                     *  EF20 34   16       GSRIR     pshs   d,x  EF22 BD   F19B               jsr    tsk2rg  EF25 8E   0002               ldx    #SNIR  EF28 BD   EC45               jsr    byterd  EF2B ED   E4                 std    0,s  EF2D 35   96                 puls   d,x,pc                                          *                     * PSRIR, put byte B in socket registers interrupt register                     * E=socket#                     *  EF2F 34   16       PSRIR     pshs   d,x  EF31 BD   F19B               jsr    tsk2rg  EF34 8E   0002               ldx    #SNIR  EF37 EC   E4                 ldd    0,sFIO Simulation Structure             13:28:16  Mar 09, 2024   Page   92wzspi, basic spi routines                             EF39 BD   ECA2               jsr    bytewr  EF3C 35   96                 puls   d,x,pc                                          *                     * GSRSR, get bytefrom socket registers status register                     * E=socket#                     * return byte in B                     *  EF3E 34   16       GSRSR     pshs   d,x  EF40 BD   F19B               jsr    tsk2rg  EF43 8E   0003               ldx    #SNSR  EF46 BD   EC45               jsr    byterd  EF49 ED   E4                 std    0,s  EF4B 35   96                 puls   d,x,pc                                          *                     * GSRPORT, get word from socket registers source port                     * E=socket#                     * return word in D                     *  EF4D 34   16       GSRPORT   pshs   d,x  EF4F BD   F19B               jsr    tsk2rg  EF52 8E   0004               ldx    #SNPORT0  EF55 BD   EC57               jsr    wordrd  EF58 ED   E4                 std    0,s  EF5A 35   96                 pul    d,x,pc                                          *                     * PSRPORT, put word D into socket registers source port                     * E=socket#                     *  EF5C 34   16       PSRPORT   pshs   d,x  EF5E BD   F19B               jsr    tsk2rg  EF61 8E   0004               ldx    #SNPORT0  EF64 EC   E4                 ldd    0,s  EF66 BD   ECB1               jsr    wordwr  EF69 35   96                 puls   d,x,pc                                          *                     * GSRDHAR, get destination hardware address into [Y]                     * F=sockt#, Y=destination                     *  EF6B 34   16       GSRDHAR   pshs   d,x  EF6D BD   F19B               jsr    tsk2rg  EF70 8E   0006               ldx    #SNDHAR0  EF73 BD   EC57               jsr    wordrd  EF76 ED   A4                 std    0,y  EF78 8E   0008               ldx    #SNDHAR2  EF7B BD   EC57               jsr    wordrd  EF7E ED   22                 std    2,y  EF80 8E   000A               ldx    #SNDHAR4  EF83 BD   EC57               jsr    wordrdFIO Simulation Structure             13:28:17  Mar 09, 2024   Page   93wzspi, basic spi routines                             EF86 ED   24                 std    4,y  EF88 35   96                 puls   d,x,pc                                          *                     * PSRDHAR, put [Y] into destination hardware address                     * F=sockt#, Y=destination                     *  EF8A 34   16       PSRDHAR   pshs   d,x  EF8C BD   F19B               jsr    tsk2rg  EF8F 8E   0006               ldx    #SNDHAR0  EF92 EC   A4                 ldd    0,y  EF94 BD   ECB1               jsr    wordwr  EF97 8E   0008               ldx    #SNDHAR2  EF9A EC   22                 ldd    2,y  EF9C BD   ECB1               jsr    wordwr  EF9F 8E   000A               ldx    #SNDHAR4  EFA2 EC   24                 ldd    4,y  EFA4 BD   ECB1               jsr    wordwr  EFA7 35   96                 puls   d,x,pc                                          *                     * GSRDIP. get destination IP address into [Y]                     * E=socket#                     *  EFA9 34   16       GSRDIP    pshs   d,x  EFAB BD   F19B               jsr    tsk2rg  EFAE 8E   000C               ldx    #SNDIPR0  EFB1 BD   EC57               jsr    wordrd  EFB4 ED   A4                 std    0,y  EFB6 8E   000E               ldx    #SNDIPR2  EFB9 BD   EC57               jsr    wordrd  EFBC ED   22                 std    2,y  EFBE 35   96                 puls   d,x,pc                                          *                     * PSRDIP. put destination IP address into [Y]                     * E=socket#                     *  EFC0 34   16       PSRDIP    pshs   d,x  EFC2 BD   F19B               jsr    tsk2rg  EFC5 8E   000C               ldx    #SNDIPR0  EFC8 EC   A4                 ldd    0,y  EFCA BD   ECB1               jsr    wordwr  EFCD 8E   000E               ldx    #SNDIPR2  EFD0 EC   22                 ldd    2,y  EFD2 BD   ECB1               jsr    wordwr  EFD5 35   96                 puls   d,x,pc                                          *                     * GSRDPOR, get word from socket registers destination port                     * E=socket#                     * return word in DFIO Simulation Structure             13:28:17  Mar 09, 2024   Page   94wzspi, basic spi routines                                                *  EFD7 34   16       GSRDPOR   pshs   d,x  EFD9 BD   F19B               jsr    tsk2rg  EFDC 8E   0010               ldx    #SNDPOR0  EFDF BD   EC57               jsr    wordrd  EFE2 ED   E4                 std    0,s  EFE4 35   96                 pul    d,x,pc                                          *                     * PSRDPOR, put word D into socket registers destination port                     * E=socket#                     *  EFE6 34   16       PSRDPOR   pshs   d,x  EFE8 BD   F19B               jsr    tsk2rg  EFEB 8E   0010               ldx    #SNDPOR0  EFEE EC   E4                 ldd    0,s  EFF0 BD   ECB1               jsr    wordwr  EFF3 35   96                 puls   d,x,pc                                          *                     * GSRMSS, get word from socket registers max segment size                     * E=socket#                     * return word in D                     *  EFF5 34   16       GSRMSS    pshs   d,x  EFF7 BD   F19B               jsr    tsk2rg  EFFA 8E   0012               ldx    #SNMSSR0  EFFD BD   EC57               jsr    wordrd  F000 ED   E4                 std    0,s  F002 35   96                 pul    d,x,pc                                          *                     * PSRMSS, put word D into socket registers maximum segment size                     * E=socket#                     *  F004 34   16       PSRMSS    pshs   d,x  F006 BD   F19B               jsr    tsk2rg  F009 8E   0012               ldx    #SNMSSR0  F00C EC   E4                 ldd    0,s  F00E BD   ECB1               jsr    wordwr  F011 35   96                 puls   d,x,pc                                          *                     * GSRPROT, get byte from socket registers PROTOCOL                     * E=socket#                     * return byte in B                     *  F013 34   16       GSRPROT   pshs   d,x  F015 BD   F19B               jsr    tsk2rg  F018 8E   0014               ldx    #SNPROTO  F01B BD   EC45               jsr    byterd  F01E ED   E4                 std    0,sFIO Simulation Structure             13:28:17  Mar 09, 2024   Page   95wzspi, basic spi routines                             F020 35   96                 pul    d,x,pc                                          *                     * PSRPROT, put byte B into socket registers PROTOCOL                     * E=socket#                     *  F022 34   16       PSRPROT   pshs   d,x  F024 BD   F19B               jsr    tsk2rg  F027 8E   0014               ldx    #SNPROTO  F02A EC   E4                 ldd    0,s  F02C BD   ECA2               jsr    bytewr  F02F 35   96                 puls   d,x,pc                                          *                     * GSRTOS, get byte from socket registers TOS                     * E=socket#                     * return byte in B                     *  F031 34   16       GSRTOS    pshs   d,x  F033 BD   F19B               jsr    tsk2rg  F036 8E   0015               ldx    #SNTOS  F039 BD   EC45               jsr    byterd  F03C ED   E4                 std    0,s  F03E 35   96                 pul    d,x,pc                                          *                     * PSRTOS, put byte B into socket registers TOS                     * E=socket#                     *  F040 34   16       PSRTOS    pshs   d,x  F042 BD   F19B               jsr    tsk2rg  F045 8E   0015               ldx    #SNTOS  F048 EC   E4                 ldd    0,s  F04A BD   ECA2               jsr    bytewr  F04D 35   96                 puls   d,x,pc                                          *                     * GSRTTL, get byte from socket registers TTL                     * E=socket#                     * return byte in B                     *  F04F 34   16       GSRTTL    pshs   d,x  F051 BD   F19B               jsr    tsk2rg  F054 8E   0016               ldx    #SNTTL  F057 BD   EC45               jsr    byterd  F05A ED   E4                 std    0,s  F05C 35   96                 pul    d,x,pc                                          *                     * PSRTTL, put byte B into socket registers TTL                     * E=socket#                     *FIO Simulation Structure             13:28:18  Mar 09, 2024   Page   96wzspi, basic spi routines                             F05E 34   16       PSRTTL    pshs   d,x  F060 BD   F19B               jsr    tsk2rg  F063 8E   0016               ldx    #SNTTL  F066 EC   E4                 ldd    0,s  F068 BD   ECA2               jsr    bytewr  F06B 35   96                 puls   d,x,pc                                          *                     * GSRRBFS, get byte from socket registers rec buf size                     * E=socket#                     * return byte in B                     *  F06D 34   16       GSRRBFS   pshs   d,x  F06F BD   F19B               jsr    tsk2rg  F072 8E   001E               ldx    #SNRBFSZ  F075 BD   EC45               jsr    byterd  F078 ED   E4                 std    0,s  F07A 35   96                 pul    d,x,pc                                          *                     * PSRTBFS, put byte B into socket registers rec buf size                     * E=socket#                     *  F07C 34   16       PSRRBFS   pshs   d,x  F07E BD   F19B               jsr    tsk2rg  F081 8E   001E               ldx    #SNRBFSZ  F084 EC   E4                 ldd    0,s  F086 BD   ECA2               jsr    bytewr  F089 35   96                 puls   d,x,pc                                          *                     * GSRTBFS, get byte from socket registers tx buf size                     * E=socket#                     * return byte in B                     *  F08B 34   16       GSRTBFS   pshs   d,x  F08D BD   F19B               jsr    tsk2rg  F090 8E   001F               ldx    #SNTBFSZ  F093 BD   EC45               jsr    byterd  F096 ED   E4                 std    0,s  F098 35   96                 puls   d,x,pc                                          *                     * PSRTBFS, put byte B into socket registers tx buf size                     * E=socket#                     *  F09A 34   16       PSRTBFS   pshs   d,x  F09C BD   F19B               jsr    tsk2rg  F09F 8E   001F               ldx    #SNTBFSZ  F0A2 EC   E4                 ldd    0,s  F0A4 BD   ECA2               jsr    bytewr  F0A7 35   96                 puls   d,x,pcFIO Simulation Structure             13:28:18  Mar 09, 2024   Page   97wzspi, basic spi routines                                                                     *                     * GSRTXFR, get word from socket registers TX free size                     * E=socket#                     * return word in D                     *  F0A9 34   16       GSRTXFR   pshs   d,x  F0AB BD   F19B               jsr    tsk2rg  F0AE 8E   0020               ldx    #SNTXFR0  [R]  F0B1 BD   EC57               jsr    wordrd  F0B4 ED   E4       01        std    0,s  F0B6 BD   EC57               jsr    wordrd  F0B9 10A3 E4                 cmpd   0,s       read more times and exit  F0BC 26   F6                 bne    01b       when 2 reads are equal  F0BE 35   96                 puls   d,x,pc                                          *                     * GSRTXRP, get word from socket registers TX read pointer                     * E=socket#                     * return word in D                     *  F0C0 34   16       GSRTXRP   pshs   d,x  F0C2 BD   F19B               jsr    tsk2rg  F0C5 8E   0022               ldx    #SNTXRP0  [R]  F0C8 BD   EC57               jsr    wordrd  F0CB ED   E4       01        std    0,s  F0CD BD   EC57               jsr    wordrd  F0D0 10A3 E4                 cmpd   0,s       read more times and exit  F0D3 26   F6                 bne    01b       when 2 reads are equal  F0D5 35   96                 puls   d,x,pc                                          *                     * GSRTXWP, get word from socket registers TX write pointer                     * E=socket#                     * return word in D                     *  F0D7 34   16       GSRTXWP   pshs   d,x  F0D9 BD   F19B               jsr    tsk2rg  F0DC 8E   0024               ldx    #SNTXWP0  [RW]  F0DF BD   EC57               jsr    wordrd  F0E2 ED   E4                 std    0,s  F0E4 35   96                 puls   d,x,pc                                          *                     * PSRTXWP, put word D into socket registers TX write pointer                     * E=socket#                     *  F0E6 34   16       PSRTXWP   pshs   d,x  F0E8 BD   F19B               jsr    tsk2rg  F0EB 8E   0024               ldx    #SNTXWP0  F0EE EC   E4                 ldd    0,s  F0F0 BD   ECB1               jsr    wordwrFIO Simulation Structure             13:28:18  Mar 09, 2024   Page   98wzspi, basic spi routines                             F0F3 35   96                 puls   d,x,pc                                          *                     * GSRRXRS, get word from socket registers RX received size                     * E=socket#                     * return word in D                     *  F0F5 34   16       GSRRXRS   pshs   d,x  F0F7 BD   F19B               jsr    tsk2rg  F0FA 8E   0026               ldx    #SNRXRZ0  [R]  F0FD BD   EC57               jsr    wordrd  F100 ED   E4       01        std    0,s  F102 BD   EC57               jsr    wordrd  F105 10A3 E4                 cmpd   0,s       read more times and exit  F108 26   F6                 bne    01b       when 2 reads are equal  F10A 35   96                 puls   d,x,pc                                          *                     * GSRRXRP, get word from socket registers RX read pointer                     * E=socket#                     * return word in D                     *  F10C 34   16       GSRRXRP   pshs   d,x  F10E BD   F19B               jsr    tsk2rg  F111 8E   0028               ldx    #SNRXRP0  [RW]  F114 BD   EC57               jsr    wordrd  F117 ED   E4                 std    0,s  F119 35   96                 puls   d,x,pc                                          *                     * PSRRXRP, put word D into socket registers RX read pointer                     * E=socket#                     *  F11B 34   16       PSRRXRP   pshs   d,x >F11D BD   F19B               jsr    tsk2rg  F120 8E   0028               ldx    #SNRXRP0  F123 EC   E4                 ldd    0,s  F125 BD   ECB1               jsr    wordwr  F128 35   96                 puls   d,x,pc                                          *                     * GSRRXWP, get word from socket registers RX write pointer                     * E=socket#                     * return word in D                     *  F12A 34   16       GSRRXWP   pshs   d,x >F12C BD   F19B               jsr    tsk2rg  F12F 8E   002A               ldx    #SNRXWP0  [R]  F132 BD   EC57               jsr    wordrd  F135 ED   E4       01        std    0,s  F137 BD   EC57               jsr    wordrd  F13A 10A3 E4                 cmpd   0,s       read more times and exitFIO Simulation Structure             13:28:18  Mar 09, 2024   Page   99wzspi, basic spi routines                             F13D 26   F6                 bne    01b       when 2 reads are equal  F13F 35   96                 puls   d,x,pc                                          *                     * GSRIMR, get byte from socket registers interrupt mask                     * E=socket#                     * return byte in B                     *  F141 34   16       GSRIMR    pshs   d,x >F143 BD   F19B               jsr    tsk2rg  F146 8E   002C               ldx    #SNIMR  F149 BD   EC45               jsr    byterd  F14C ED   E4                 std    0,s  F14E 35   96                 puls   d,x,pc                                          *                     * PSRIMS, put byte B into socket registers interrupt mask                     * E=socket#                     *  F150 34   16       PSRIMR    pshs   d,x >F152 BD   F19B               jsr    tsk2rg  F155 8E   002C               ldx    #SNIMR  F158 EC   E4                 ldd    0,s  F15A BD   ECA2               jsr    bytewr  F15D 35   96                 puls   d,x,pc                                          *                     * GSRFRAG, get word from socket registers FRAG                     * E=socket#                     * return word in D                     *  F15F 34   16       GSRFRAG   pshs   d,x >F161 BD   F19B               jsr    tsk2rg  F164 8E   002D               ldx    #SNFRAG0  F167 BD   EC57               jsr    wordrd  F16A ED   E4                 std    0,s  F16C 35   96                 puls   d,x,pc                                          *                     * PSRGRAG, put word D into socket registers FRAG                     * E=socket#                     *  F16E 34   16       PSRFRAG   pshs   d,x >F170 BD   F19B               jsr    tsk2rg  F173 8E   002D               ldx    #SNFRAG0  F176 EC   E4                 ldd    0,s  F178 BD   ECB1               jsr    wordwr  F17B 35   96                 puls   d,x,pc                                          *                     * GSRKATM, get byte from socket registers keep alive timer                     * E=socket#FIO Simulation Structure             13:28:19  Mar 09, 2024   Page  100wzspi, basic spi routines                                                * return byte in B                     *  F17D 34   16       GSKATM    pshs   d,x >F17F BD   F19B               jsr    tsk2rg  F182 8E   002F               ldx    #SNKATIM  F185 BD   EC45               jsr    byterd  F188 ED   E4                 std    0,s  F18A 35   96                 puls   d,x,pc                                          *                     * PSRKATM, put byte B into socket registers keep alive timer                     * E=socket#                     *  F18C 34   16       PSRKATM   pshs   d,x >F18E BD   F19B               jsr    tsk2rg  F191 8E   002F               ldx    #SNKATIM  F194 EC   E4                 ldd    0,s  F196 BD   ECA2               jsr    bytewr  F199 35   96                 puls   d,x,pc                     *                     * data handling routines                     *                                          * translate socket register in partial address                     * prepares bits [7...5][4...3]                     * E=socket#, F=lost, B=lost               F19B  tsk2rg    equ    *  F19B                         trfr   E,B  F19B 1F                      fcb    $1f  F19C E9                      fcb    E<<4|B                               endm  F19D 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F19E 1C   FE                 clc              make reg bits + '01'  F1A0 59                      rolb             socket register  F1A1 1A   01                 sec  F1A3 59                      rolb             xxx 01 ...                     *  F1A4                         trfr   B,F  F1A4 1F                      fcb    $1f  F1A5 9F                      fcb    B<<4|F                               endm  F1A6 39                      rts                                          *                     * translate socket register in final address (data xfer)                     * prepares bit [7...0]                     *               F1A7  tsk2tx    equ    *  F1A7                         trfr   E,B  F1A7 1F                      fcb    $1f  F1A8 E9                      fcb    E<<4|BFIO Simulation Structure             13:28:19  Mar 09, 2024   Page  101wzspi, basic spi routines                                                          endm  F1A9 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F1AA 1A   01                 sec              make reg bits + '10'  F1AC 59                      rolb             sock TX buffer  F1AD 1C   FE                 clc  F1AF 59                      rolb                     *  F1B0 1A   01                 sec  F1B2 59                      rolb             write bit     '1'                     *  F1B3 58                      lslb             variable size '00'  F1B4 58                      lslb             xxx 10 100                     *  F1B5 39                      rts                                          *                     * translate socket register in rx buffer address (data xfer)                     * prepares bit [7...0]                     *               F1B6  tsk2rx    equ    *  F1B6                         trfr   E,B  F1B6 1F                      fcb    $1f  F1B7 E9                      fcb    E<<4|B                               endm  F1B8 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F1B9 1A   01                 sec              make reg bits + '11'  F1BB 59                      rolb             sock RX buffer  F1BC 1A   01                 sec              make reg bits + '11'  F1BE 59                      rolb                     *  F1BF 1C   FE                 clc  F1C1 59                      rolb             read bit     '0'                     *  F1C2 58                      lslb             variable size '00'  F1C3 58                      lslb             xxx 11 000  F1C4 39                      rts                                          *                     * rdsk2fb, read socket data in fifo buffer                     * Y=sock, U=sock info                     * E=socket#                     * entry D= available count                     * return, D=xferred count                     *  F1C5 34   76       RDSK2FB   pshs   d,x,y,u                     *  F1C7 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F1CA 23   02                 bls    01f  F1CC EC   4A                 ldd    wzrqln,u  mandatory size  F1CE 1F   01       01        tfr    D,X       sizeFIO Simulation Structure             13:28:19  Mar 09, 2024   Page  102wzspi, basic spi routines                             F1D0 ED   E4                 std    0,s       save xfrerred old  D  F1D2 ED   48                 std    wzxfer,u  F1D4 27   3C                 beq    15f       no data                     *  F1D6 BD   F10C               jsr    GSRRXRP  F1D9 34   06                 pshs   d         save socket read pointer  F1DB 1F   02                 tfr    D,Y                     *  F1DD CE   8080               ldu    #SPIBASE  F1E0 34   01                 pshs   cc  F1E2                         pshsw  F1E2 1038                    fdb    $1038                               endm  F1E4 34   40                 pshs   u  F1E6 1A   50                 orcc   #$50      disable interrupts  F1E8 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F1EA A7   C4                 sta    spicmd,u  F1EC 10AF 44                 sty    hibyta,u  start address                      >F1EF BD   F1B6               jsr    tsk2rx    SOCK# to buffer address                       F1F2 E7   44                 stb    hibyta,u  F1F4 108E 0020               ldy    #fifo  F1F8 E7   44                 stb    hibyta,u  shift out first data byte  F1FA 33   45                 leau   lobyta,u  lobyte is the first byte shifted in  F1FC                         trfr   X,W  F1FC 1F                      fcb    $1f  F1FD 16                      fcb    X<<4|W                               endm  F1FE                         tfm4   U,Y  F1FE 113B                    fdb    $113b  F200 32                      fcb    U<<4|Y                               endm  F201 35   40                 puls   u  F203 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F205 A7   C4                 sta    spicmd,u  F207                         pulsw  restore   E:F  F207 1039                    fdb    $1039                               endm  F209 35   01                 puls   cc                     *  F20B 35   06                 puls   d         old read pointer  F20D E3   E4                 addd   0,s       adjust transferred  F20F BD   F11B               jsr    PSRRXRP   update pointer                     *  F212 35   F6       15        puls   d,x,y,u,pc                                                               *                     * wrfb2sk,write fifo buffer to socket buffer                     * Y=sock                     * E=socket#FIO Simulation Structure             13:28:20  Mar 09, 2024   Page  103wzspi, basic spi routines                                                * on entry D= total amount to xfer                     * on return D= xferred count                     *  F214 34   76       WRFB2SK   pshs   d,x,y,u  F216 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F219 23   02                 bls    01f  F21B EC   4A                 ldd    wzrqln,u  F21D 1F   01       01        tfr    d,x  F21F ED   E4                 std    0,s  F221 ED   48                 std    wzxfer,u  report size  F223 27   53                 beq    15f                     *  F225 10AE C8 22              ldy    wzuwrp,u  0 if not UDP or never written  F229 26   05                 bne    24f  F22B BD   F0D7               jsr    GSRTXWP   get write pointer  F22E 20   02                 bra    25f  F230 1F   20       24        tfr    y,d                     *  F232 34   06       25        pshs   d  F234 1F   02                 tfr    D,Y                     *  F236 CE   8080               ldu    #SPIBASE  F239 34   01                 pshs   cc  F23B                         pshsw  save      E:F  F23B 1038                    fdb    $1038                               endm  F23D 34   40                 pshs   u  F23F 1A   50                 orcc   #$50  F241 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F243 A7   C4                 sta    spicmd,u  F245 10AF 44                 sty    hibyta,u  start address                       F248 BD   F1A7               jsr    tsk2tx                       F24B E7   44                 stb    hibyta,u  F24D 108E 0020               ldy    #fifo  F251 33   44                 leau   hibyta,u  the first to shift out  F253                         trfr   X,W  F253 1F                      fcb    $1f  F254 16                      fcb    X<<4|W                               endm  F255                         tfm3   Y,U  F255 113A                    fdb    $113a  F257 23                      fcb    Y<<4|U                               endm  F258 35   40                 puls   u  F25A 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F25C A7   C4                 sta    spicmd,u  F25E                         pulsw  restore   E:F!!  F25E 1039                    fdb    $1039                               endm  F260 35   01                 puls   ccFIO Simulation Structure             13:28:20  Mar 09, 2024   Page  104wzspi, basic spi routines                                                *  F262 35   06                 puls   d         old write pointer  F264 E3   E4                 addd   0,s  F266 EE   66                 ldu    6,s       restore U  F268 AE   C8 26              ldx    wztype,u  F26B 8C   0002               cmpx   #SK_DGRM  F26E 27   05                 beq    10f  F270 BD   F0E6     11        jsr    PSRTXWP   update pointer  F273 20   03                 bra    15f                       F275 ED   C8 22    10        std    wzuwrp,u  set RAM pointer                     *                     *  F278 35   F6       15        puls   d,x,y,u,pcFIO Simulation Structure             13:28:20  Mar 09, 2024   Page  105Debug Interface Routines                                                   F27A               DB_main  F27A 8D   4F                 bsr    DB_test   see if debug routines present  F27C 6E   9F C002            jmp    [DEBUGROM+2]  F280               DB_pdata  F280 8D   49                 bsr    DB_test   see if debug routines present  F282 6E   9F C004            jmp    [DEBUGROM+4]  F286               DB_phex  F286 8D   43                 bsr    DB_test   see if debug routines present  F288 6E   9F C006            jmp    [DEBUGROM+6]  F28C               DB_phex2  F28C 8D   3D                 bsr    DB_test   see if debug routines present  F28E 6E   9F C008            jmp    [DEBUGROM+8]  F292               DB_pcrlf  F292 8D   37                 bsr    DB_test   see if debug routines present  F294 6E   9F C00A            jmp    [DEBUGROM+10]  F298               DB_check  F298 8D   31                 bsr    DB_test   see if debug routines present  F29A 6E   9F C00C            jmp    [DEBUGROM+12]  F29E               DB_config  F29E 8D   2B                 bsr    DB_test   see if debug routines present  F2A0 6E   9F C00E            jmp    [DEBUGROM+14]  F2A4 34   17       DB_msg    pshs   cc,d,x  F2A6 AE   65                 ldx    1+2+2,s   get return address  F2A8 EC   81                 ldd    ,x++      get mask word  F2AA B4   0401               anda   DB_cntrl  F2AD F4   0402               andb   DB_cntrl+1  F2B0 34   04                 pshs   b  F2B2 AA   E0                 ora    ,s+  F2B4 27   04                 beq    10f       jump if flag not set  F2B6 30   02                 leax   2,x       skip over false address & fall through  F2B8 20   02                 bra    20f  F2BA AE   84       10        ldx    ,x        get false branch label  F2BC AF   65       20        stx    1+2+2,s   fix up return address  F2BE 35   97                 puls   cc,d,x,pc return                     *  F2C0               DB_pspace  F2C0               DB_outsp  F2C0 34   16                 pshs   d,x  F2C2 8E   F2C9               ldx    #00f  F2C5 8D   B9                 bsr    DB_pdata  F2C7 35   96                 puls   d,x,pc  F2C9 20 00         00        fcc    ' ',0                       F2CB 34   07       DB_test   pshs   cc,d  F2CD FC   C000               ldd    DEBUGROM  Debug rom present?  F2D0 1083 1234               cmpd   #$1234    special marker  F2D4 27   05                 beq    99f       yes - exit  F2D6 35   07                 puls   cc,d      no - abort DB_xx function  F2D8 32   62                 leas   2,s  F2DA 39                      rts  F2DB 35   87       99        puls   cc,d,pc   returnFIO Simulation Structure             13:28:21  Mar 09, 2024   Page  106Debug Interface Routines                                                                                                     end    rom_initFIO Simulation Structure             13:28:21  Mar 09, 2024   Page  107Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AF_INET  0002   AF_UNIX  0001   AF_UNSP  0000   B        0009   CC       000A   CI_CFL   0080   CI_MP    0010   CI_POC   0020   CI_UNR   0040   CPU2DEV  0022   CPU_down E04F   CPUtraps FFF0   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F298   DB_cntrl 0401   DB_confi F29E   DB_iflg  0400   DB_main  F27A   DB_msg   F2A4   DB_outsp F2C0   DB_pcrlf F292   DB_pdata F280   DB_phex  F286   DB_phex2 F28C   DB_pspac F2C0   DB_test  F2CB   DBmsg00  E012   DBmsg01  E01B   DBmsg02  E03B   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV2CPU  0021   DEV_SIZE 0006   DEV_SOCK E5E0   DO_HISTO 0001   DP       000B   DPR_BASE 0000   D_END    002E   D_func0  0000   D_func1  0002   D_func10 0020   D_func11 0022   D_func12 0024   D_func13 0026   D_func2  0004   D_func3  0006   D_func4  0008   D_func5  000A   D_func6  000C   D_func7  000E   D_func8  0010   D_func9  0012   D_funcA  0014   D_funcB  0016   D_funcC  0018   D_funcD  001A   D_funcE  001C   D_funcF  001E   D_init   002A   D_inthan 0028   D_test   002C   E        000E   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get E2E8   FIFO_put E30D   FIFOgeta E2DF   FIFOputa E305   FIOPRI   FFCE   FIO_get  E2BD   FIO_lock 0446   FIO_rel  E2D2   GCRGA    ECF0   GCRILLT  EDB8   GCRIMR   EDF4   GCRIR    EDD6   GCRMR    ECD2   GCRPHY   EEB0   GCRRCR   EE6C   GCRRTR   EE4E   GCRSHA   ED4C   GCRSIMR  EE30   GCRSIP   ED8A   GCRSIR   EE12   GCRSNM   ED1E   GCRUIP   EE99   GCRURP   EE8A   GCRVERS  EECE   GSKATM   F17D   GSRCR    EEFB   GSRDHAR  EF6B   GSRDIP   EFA9   GSRDPOR  EFD7   GSRFRAG  F15F   GSRIMR   F141   GSRIR    EF20   GSRMR    EEDD   GSRMSS   EFF5   GSRPORT  EF4D   GSRPROT  F013   GSRRBFS  F06D   GSRRXRP  F10C   GSRRXRS  F0F5   GSRRXWP  F12A   GSRSR    EF3E   GSRTBFS  F08B   GSRTOS   F031   GSRTTL   F04F   GSRTXFR  F0A9   GSRTXRP  F0C0   GSRTXWP  F0D7   HANGS    0001   HRECSIZ  0004   H_cpu    E45F   H_fio    E483   IF       0010   INTS     0002   IO_end   E386   IO_han   E328   IRQ_han  E3A4   IRQmsg10 E3B1   IS       0003   IU       0002   IX       0000   IY       0001   MAXHIST  0010   MAXTBL   0003   MAX_DEV  0001   MAX_S_NU 0015   MAX_TI   0009   MAX_UDP  05C0   MAX_WZ   0008   MOD_SIZE 0004   NET      0001   NUM_TSK  0459   O_CLOSE  0020   O_INTRPT 0038   O_OPEN   0010   O_PGETD  00D0   O_PSETD  00E0   O_READ   0060   O_RQRD   0050   O_RQWR   0030   O_TTYG   00A0   O_TTYS   0090   O_WR1C   0080   O_WRITE  0040   PACK_COM 0000   PACK_FIR 0080   PACK_REM 0001   PC       0005   PCRGA    ED07   PCRILLT  EDC7   PCRIMR   EE03   PCRIR    EDE5   PCRMR    ECE1   PCRPHY   EEBF   PCRRCR   EE7B   PCRRTR   EE5D   PCRSHA   ED6B   PCRSIMR  EE3F   PCRSIP   EDA1   PCRSIR   EE21   PCRSNM   ED35   PF_INET  0002   PF_UNIX  0001   POLPRI   FFBA   PSRCR    EF0A   PSRDHAR  EF8A   PSRDIP   EFC0   PSRDPOR  EFE6   PSRFRAG  F16E   PSRIMR   F150   PSRIR    EF2F   PSRKATM  F18C   PSRMR    EEEC   PSRMSS   F004   PSRPORT  EF5C   PSRPROT  F022   PSRRBFS  F07C   PSRRXRP  F11B   PSRTBFS  F09A   PSRTOS   F040   PSRTTL   F05E   PSRTXWP  F0E6   QFF1     0080   QUITS    0003   RAMend   3EFF   RAMorg   0400   RAMscrat 7000   RAMscren 7E00   RDSK2FB  F1C5   REJECT   0080   ROMLOorg E000   ROM_ERR  E0C4   ROM_VERS 0020   ROMstack 7FE0   RSVREG   0003   RUNPRI   0046   R_ACCEPT 000B   R_BIND   0009   R_CLOCK  000E   FIO Simulation Structure             13:28:21  Mar 09, 2024   Page  108Debug Interface Routines                            R_CLOSE  0002   R_CONNEC 0008   R_DISCON 000C   R_INTRPT 0007   R_LISTEN 000A   R_OPEN   0001   R_PDATA  000B   R_RD1C   0009   R_RDFRM  0021   R_RDOK   0005   R_READ   0006   R_READM  000C   R_REQOK  0003   R_RESET  000F   R_RQRD   0005   R_RQRDNB 0015   R_RQWR   0003   R_RQWRNB 0013   R_RRDFD  0022   R_RSNDTO 0023   R_SNDKEP 000E   R_SNDMAC 000D   R_SNDTOM 0025   R_SPCL   000F   R_TTY    000D   R_WR1C   0008   R_WRITE  0004   R_WSNDTO 0024   S        0004   SIQPRI   FFD8   SI_CON   0001   SI_DIS   0002   SI_HAN   E3F8   SI_Q     040E   SI_Q_ptr 0444   SI_RCV   0004   SI_SOK   0010   SI_TIM   0008   SKADLN   0010   SKPRI    FFC4   SK_DGRM  0002   SK_RAW   0003   SK_STRM  0001   SNCR     0001   SNDHAR0  0006   SNDHAR1  0007   SNDHAR2  0008   SNDHAR3  0009   SNDHAR4  000A   SNDHAR5  000B   SNDIPR0  000C   SNDIPR1  000D   SNDIPR2  000E   SNDIPR3  000F   SNDPOR0  0010   SNDPOR1  0011   SNFRAG0  002D   SNFRAG1  002E   SNIMR    002C   SNIR     0002   SNKATIM  002F   SNMR     0000   SNMSSR0  0012   SNMSSR1  0013   SNPORT0  0004   SNPORT1  0005   SNPROTO  0014   SNRBFSZ  001E   SNRXRP0  0028   SNRXRP1  0029   SNRXRZ0  0026   SNRXRZ1  0027   SNRXWP0  002A   SNRXWP1  002B   SNSR     0003   SNTBFSZ  001F   SNTOS    0015   SNTTL    0016   SNTXFR0  0020   SNTXFR1  0021   SNTXRP0  0022   SNTXRP1  0023   SNTXWP0  0024   SNTXWP1  0025   SPIBASE  8080   SPI_AUT  0008   SPI_CR_  0001   SPI_CS_  0040   SPI_HLD  0002   SPI_IEN  0010   SPI_IRQ  0001   SPI_RST  0020   SPI_SR_  0004   SP_EGP   0008   SP_GMP   0002   SP_ICMP  0001   SP_TCP   0006   SP_UDP   0011   SYS_TABS 04C6   S_ACCEPT 0058   S_BIND   0048   S_CLOSE  0010   S_CONNEC 0040   S_DISCON 0060   S_INTRPT 0038   S_LISTEN 0050   S_OPEN   0008   S_READ   0030   S_RQRD   0028   S_RQWR   0018   S_RRDFRM 0080   S_RREAD  0088   S_SNDKEP 0070   S_SNDMAC 0068   S_SPCL   0078   S_WRITE  0020   S_WRQSTO 0090   S_WSNDTM 00A0   S_WSNDTO 0098   TFREE    0004   TRUN     0001   TSKSIZ   00D7   TSLEEP   0002   TSYS     0005   TWAIT    0003   U        0003   USTSIZ   00C0   V        0007   W        0006   WCACCP   0086   WCBIND   0085   WCCLOS   0010   WCCONN   0004   WCDISC   0008   WCLIST   0002   WCOPEN   0001   WCRECV   0040   WCRRQD   0081   WCSEND   0020   WCSKEP   0022   WCSNAC   0021   WCSPEC   0080   WCXMDR   0082   WFNBLK   0001   WRFB2SK  F214   WSCLSD   0000   WSCLSG   001A   WSCLWT   001C   WSESTB   0017   WSFWAI   0018   WSINIT   0013   WSLACK   001D   WSLIST   0014   WSRAW    0042   WSRNBL   001E   WSRRQF   0081   WSSPEC   0080   WSSYNR   0016   WSSYNS   0015   WSTIMW   001B   WSUDP    0022   WSWNBL   001F   WSXMDD   0082   WZ5_name E1D0   WZBUSY   0080   WZGAR0   0001   WZGAR1   0002   WZGAR2   0003   WZGAR3   0004   WZILLT0  0013   WZILLT1  0014   WZIMR    0016   WZIR     0015   WZLCSZ   0016   WZMR     0000   WZNETOF  0370   WZPHY    002E   WZRCR    001B   WZRTR0   0019   WZRTR1   001A   WZSHAR0  0009   WZSHAR1  000A   WZSHAR2  000B   WZSHAR3  000C   WZSHAR4  000D   WZSHAR5  000E   WZSIMR   0018   WZSIPR0  000F   WZSIPR1  0010   WZSIPR2  0011   WZSIPR3  0012   WZSIR    0017   WZSIZE   002A   WZSKIO   0002   WZSKIP   0040   WZSKIS   0004   WZSKOFF  0220   WZSLCK   0001   WZSUBR0  0005   WZSUBR1  0006   WZSUBR2  0007   WZSUBR3  0008   WZUIPR0  0028   WZUIPR1  0029   WZUIPR2  002A   WZUIPR3  002B   WZUPRT0  002C   WZUPRT1  002D   WZVERS   0039   WZWLCK   0010   X        0001   Y        0002   bad_cmd  E3A1   bittab   E752   bmread   EC69   bt2num   E741   byterd   EC45   bytewr   ECA2   change   E4A7   chproc   040C   clock_ti 0455   conlb1   E7FB   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   dev_addr 0000   dev_brbu 0004   dev_tab  04A0   dev_type 0002   end_vars 3EFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  E06E   fio_fsz  E06C   fio_irq  E21B   fio_msg  E285   fio_rese E1DB   fio_resp E2A1   fio_star E08C   fio_wait E1FE   fiointe  E284   functb   EB5F   getjo1   E4EF   FIO Simulation Structure             13:28:22  Mar 09, 2024   Page  109Debug Interface Routines                            getjo2   E4FE   getjo4   E505   getjo6   E50E   getjo8   E510   getjob   E4E9   hibyta   0004   hibyts   0006   hst_cmd  0000   hst_seq  0001   hst_tty  0002   hst_val  0003   hstbuf   045A   hstptr   049A   idle     040D   int_all  E3C9   int_buf  0447   int_ptr  0453   jobpri   040B   lobyta   0005   lobyts   0007   lstram   04C6   makrd6   E568   makrdy   E553   max_trn  E070   mod_name 0002   mod_tbl  E1CA   mod_type 0000   no_dev   E14B   num2bt   E737   nwp_strt 0000   oldorg   EC11   polext   E815   putru1   E527   putru2   E52E   putru4   E53C   putru5   E54B   putru6   E54F   putrun   E51A   rdrqer1  E934   rom_bad  E0C2   rom_firq E095   rom_init E071   rom_int  E0B7   rom_nmi  E08F   rom_swi  E09C   rom_swi2 E0A2   rom_swi3 E0A9   rom_trap E0B0   rsche2   E4BE   rsche3   E4D2   rsched   E4AD   runlst   0403   sa_dat   0002   sa_fam   0000   sdev_sig E682   send_SI  E43A   set_tabl E103   showconf EB91   showrg   EBBB   sin_addr 0014   sin_fam  0010   sin_port 0012   skacpt   E8B5   skbind   E83E   skclin   E776   skclos   E75B   skcner1  E834   skcner2  E821   skcner3  E838   skcner4  E830   skcner5  E82C   skcner6  E825   skconn   E7A8   skcraw   E6BA   skctcp   E6A8   skcudp   E6B1   skdisc   EC0A   skdvini  E62A   skfres   E6A1   skinit   E610   skinthan E681   skintrp  EC0A   sklist   E883   sknewp   E683   skopen   E6C3   skoper1  E72D   skoper2  E731   skowfo   E715   skrecv   E939   skreqrd  E8EC   skreqwr  E95B   sksend   E9A2   skskep   EC0A   sksmac   EC0A   skspcl   EB38   sktest   E67E   skurrd   EA37   skurrdf  E9C4   skurwt   EA61   skusnm   EAB0   skusnt   EB02   skuwr2   EAB0   sleep    E58D   sleep7   E5B5   slplst   0405   spicmd   0000   spicon   0001   spiint   0456   spinit   EC11   spista   0000   spistr2  EC17   sprend   ECC0   stbinit  E0D1   sto_chk  E152   swtchu   E4DE   sys_vars 0400   tim_base 8400   tim_rest 8401   timerack E1BE   timerchk E1C4   timerin  E1B8   tsagin   000F   tscmd    0009   tsdev    000D   tsevnt   0006   tsk2rg   F19B   tsk2rx   F1B6   tsk2tx   F1A7   tskend   049E   tskinit  E160   tsktab   049C   tslink   0000   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstval   000C   umark0   0013   umark1   0015   usp      0011   utask    0409   wakeu2   E574   wakeu3   E57B   wakeu4   E57F   wakeu5   E581   wakeup   E569   wlocip   0370   wordrd   EC57   wordwr   ECB1   wzanyp   0457   wzcmnd   0004   wzdctr   0001   wzdev    EB67   wzdevt   E695   wzdma1   000C   wzdma2   000E   wzdprt   0012   wzdsta   0012   wzenum   0000   wzerr    0007   wzfaml   0024   wzflg    0003   wzfsta   0002   wzgwad   0008   wzhwad   000C   wzifga   E00E   wzifip   E006   wzifma   E000   wzifnm   E00A   wzipad   0014   wzmyip   0000   wzprot   0028   wzrqln   000A   wzsbnm   0004   wzsflg   0018   wzsk1    0346   wzsk2    031C   wzsk3    02F2   wzsk4    02C8   wzsk5    029E   wzsk6    0274   wzsk7    024A   wzsk8    0220   wzsprt   0010   wzstat   0005   wztype   0026   wzuipa   001A   wzupkt   0006   wzuprt   001E   wzurms   0020   wzuwrp   0022   wzxfer   0008   xmtint   E5C2   