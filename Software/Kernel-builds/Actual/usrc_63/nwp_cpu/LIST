               0001  NET       set    1                               opt    exp  0000                         absSWTPc      Intelligent I/O Proce     07:27:41  Jan 07, 2024   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100                     *EBUG_CONTROL set     %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFD8  SIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  SKPRI     equ    -60       Waiting for socket interrupt               FFBA  POLPRI    equ    -70       poliing priority                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)                                          * -- Configuration constants                                    0009  MAX_TI    equ    9         # Queued terminal interrupts                     *               0001  MAX_DEV   equ    1                     *                     SWTPc      Intelligent I/O Proce     07:27:41  Jan 07, 2024   Page    2Macro Definitions                                                                             *                     * This file contains all the standard macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                          * register references               0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000E  E         equ    14               000F  F         equ    15                                          * indexed addressing in macro's               0000  IX        equ    0               0001  IY        equ    1               0002  IU        equ    2               0003  IS        equ    3                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                          *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                     SWTPc      Intelligent I/O Proce     07:27:42  Jan 07, 2024   Page    3Macro Definitions                                                                                                  *                     * debug macro                     *                                          *dbugm macro output_character                     * lda #'&1                     * lbsr syspch                     * endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          * load W immediate                     ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          * load W direct                     *ldwd    macro                     *        fdb     $1096                     *        fcb     &1&0xff                     *        endm                                          * load W indexed                     ldwx      macro                               fdb    $10A6                               doindx &1,&2                               endm                                          * load W extended                     *ldwe    macro                     *        fdb     $10b6                     *        fdb     &1                     *        endm                                          * load E indexed                     ldex      macro                               fdb    $11a6                               doindx &1                               endm                                          ordx      macro                               fdb    $10aaSWTPc      Intelligent I/O Proce     07:27:42  Jan 07, 2024   Page    4Macro Definitions                                                                  doindx &1,&2                               endm                                          doindx    macro                               if     (&1=0)                               fcb    $84+(&2<<5)                               else                               if     (&1<16)                               fcb    (&2<<5)+(&1&$0f)                               else                               if     (&1>-16)                               fcb    (&2<<5)+($10)+(&1&$0f)                               else                               if     (&1<128)                               fcb    $88+(&2<<5),(&1&$7f)                               endif                               endif                               endif                               endif                               endm                                          * push W on system stack                     pshsw     macro                               fdb    $1038                               endm                                          * pull W from sytemstack                     pulsw     macro                               fdb    $1039                               endm                                          * memory move ++,++                     tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endm                                          * move memory++ to location                     tfm3      macro                               fdb    $113a                               fcb    &1<<4|&2                               endm                                          * move location to memory++                     tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          * logical shift left D                     lsld      macro                               fdb    $1048SWTPc      Intelligent I/O Proce     07:27:42  Jan 07, 2024   Page    5Macro Definitions                                                                  endm                                          * logical shift right D                     lsrd      macro                               fdb    $1044                               endm                                          * arithmetic shift right D                     *asrd    macro                     *        fdb     $1047                     *        endm                                          * negate D                     negd      macro                               fdb    $1040                               endm                                          * ex-or registers                     eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          * add with carry D immediate                     adcdi     macro                               fdb    $1089                               fdb    &1                               endm                                          * increment D                     incd      macro                               fdb    $104c                               endm                                          * decrement D                     decd      macro                               fdb    $104a                               endm                                          * clear D                     clrd      macro                               fdb    $104f                               endm                                          * complement D                     comd      macro                               fdb    $1043                               endm                                          * and D immediate                     anddi     macro                               fdb    $1084SWTPc      Intelligent I/O Proce     07:27:42  Jan 07, 2024   Page    6Macro Definitions                                                                  fdb    &1                               endm                                          * bit D immediate                     bitdi     macro                               fdb    $1085                               fdb    &1                               endm                                          *                     * trfr, transfer registers, allow ALL registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          * exchange, allow ALL registers                     excg      macro                               fcb    $1e                               fcb    &1<<4|&2                               endm                                          * add registers                     *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endm                                          * subtract registers                     subr      macro                               fdb    $1032                               fcb    &1<<4|&2                               endm                                          * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endm                     SWTPc      Intelligent I/O Proce     07:27:42  Jan 07, 2024   Page    7Macro Definitions                                                        * extended addressing mode                     eime      macro                               fcb    $75                               fcb    &1                               fdb    &2                               endm                                          * test immediate memory                     *timex   macro                     *        fcb     $7b                     *        fcb     &1                     *        fdb     &2                     *        endm                                          * put a LED in LIGHTS on                     LEDON     macro                               fcb    $71                               fcb    &1                               fdb    LIGHTS                               endm                                          * put a LED in LIGHTS off                     LEDOFF    macro                               fcb    $72                               fcb    255-&1                               fdb    LIGHTS                               endmSWTPc      Intelligent I/O Proce     07:27:43  Jan 07, 2024   Page    8Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc                     *  0006               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device, indexed by fifo cmnd >>3                     * should match nwp_codes.h  and MAX_S_NUM                     * wzsockdev.t                     *  0000                         org    $0000  0000               D_func0   rmb    2         0  Bad Command  0002               D_func1   rmb    2         1  0004     "/≥:∑1ô96±ê"/≥:∑1ôê96±Üê"/≥:∑1ö96±ê ê"/≥:∑1öê96±Üê!ê"/≥:∑1õ96±ê"ê"/≥:∑1õê96±Üêò"/≥:∑1ú96±êô"/≥:∑19   rmb    2         9  0014               D_funcA   rmb    2         A  0016               D_funcB   rmb    2         B  0018               D_funcC   rmb    2         C  001A               D_funcD   rmb    2         D  001C               D_funcE   rmb    2         E  001E               D_funcF   rmb    2         F                     *  0020               D_func10  rmb    2         10  0022               D_func11  rmb    2         11  0024               D_func12  rmb    2         12  0026               D_func13  rmb    2         13                     *  0028               D_inthan  rmb    2         14 Interrupt poller/handlerSWTPc      Intelligent I/O Proce     07:27:43  Jan 07, 2024   Page    9Device     Table Structure                            002A               D_init    rmb    2         15 Device initialization  002C               D_test    rmb    2         16 Test for device present                     *  002E               D_END     rmb    0         End of common handlers                     SWTPc      Intelligent I/O Proce     07:27:43  Jan 07, 2024   Page   10History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16                     SWTPc      Intelligent I/O Proce     07:27:43  Jan 07, 2024   Page   11IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0400  RAMorg    equ    $0400     28K of RAM - Thru $6FFF               3EFF  RAMend    equ    $3EFF     $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7E00  RAMscrend equ    $7E00               7FE0  ROMstack  equ    $7FE0     High end of ROM Stack                     * BGDB uses 7FF0               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, w5500 socket device                     *Task       Structure                 07:27:43  Jan 07, 2024   Page   12IOP        Memory Layout                                                 *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    00C0  USTSIZ    equ    192       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Device for task is servicing  000F               tsagin    rmb    2         return pointer                     *  0011               usp       rmb    2         Saved User Stack Pointer  0013               umark0    rmb    2         Stack Frame Markers  0015               umark1    rmb    2  0017                         rmb    USTSIZ    space for per/process stack                                    00D7  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system task                     *                     * definition of wz5500 variables                     *                     * [*] items are initialized by the IO CPU                     * others are zeroed out                     *                                          * [*] are setup by GPP CPU                                          *                     * wzfsta bits                     *               0001  WZSLCK    equ    %00000001 sock is locked (equal to fdn)               0002  WZSKIO    equ    %00000010 io modeTask       Structure                 07:27:43  Jan 07, 2024   Page   13IOP        Memory Layout                                           0004  WZSKIS    equ    %00000100 sock is sending               0010  WZWLCK    equ    %00010000 sock task is waiting lock (equal to fdn)               0040  WZSKIP    equ    %01000000 sock interrupt pending               0080  WZBUSY    equ    %10000000 sock is busy                                                               *                     * wzcmd values (w5500), private for IOP                     *               0001  WCOPEN    equ    1         open command               0002  WCLIST    equ    2         list command               0004  WCCONN    equ    4         connect command               0008  WCDISC    equ    8         disconnect               0010  WCCLOS    equ    16        close               0020  WCSEND    equ    32        send               0021  WCSNAC    equ    33        send mac               0022  WCSKEP    equ    34        send keep               0040  WCRECV    equ    64        receive               0080  WCSPEC    equ    128       special, combined commands               0081  WCRRQD    equ    128+1     read request data               0082  WCXMDR    equ    128+2     write data in fifo                                    0085  WCBIND    equ    128+5     bind  CPU<=>GPP               0086  WCACCP    equ    128+6     accpet CPU<=>GPP                     *                     * wzstat values                   ê+©°¶)¢2∏∫ê9∑±µê1∂7π≤≤êôê+©§ß$™2∏∫êôê9∑±µê4∑4∫êö+©¶$©™2∏∫êö9∑±µê64π∫2∑êõê+©¢©™!2∏∫êõê9∑±µê2π∫0±64π¥2≤ê°ê+©°¶+™2∏∫ê±ê9∑±µê1∂7π≤ê;∞¥∫ê+©™¢(2∏∫ê9∑±µê*¢(ê+©¶°©+ê2∏∫ê9∑±µê6∞±ê90ªÜê            0015  WSSYNS    equ    $15       sock syn sent               0016  WSSYNR    equ    $16       sock syn received               0018  WSFWAI    equ    $18       sock fin wiat               001A  WSCLSG    equ    $1a       sock closing               001B  WSTIMW    equ    $1b       sock time wait               001D  WSLACK    equ    $1d       sock last ack               001E  WSRNBL    equ    $1e       sock read non block               001F  WSWNBL    equ    $1f       sock write non block               0080  WSSPEC    equ    $80       special combined commands               0081  WSRRQF    equ    $80+1     read request data in fifo               0082  WSXMDD    equ    $80+2     xmit data taken from fifo                                          *                     * miscellaneous                     *               0080  PACK_FIRST equ   $80       in non TCP packet start to receive               0001  PACK_REMAI equ   $01       in non TCP packet received               0000  PACK_COMPL equ   $00       in non TCP complete toe receiveTask       Structure                 07:27:44  Jan 07, 2024   Page   14IOP        Memory Layout                                                                0001  WFNBLK    equ    $01       in socket() call(wztype << 8)                       0000                         org    $0                     *                     * per wzsocket process and socket data                     *  0000               wzenum    rmb    1         [*] (pre=enum)  0001                         rmb    1         [*] (pre= $00)  sock has fifo allocated  0002               wzfsta    rmb    1         (pre= $00) status bits (SAME POS!! as in fdn)  0003               wzflg     rmb    1         [*] flasgs, i.e. bind                     *  0004               wzcmnd    rmb    1         command byte copy  0005               wzstat    rmb    1         status byte copy  0006               wzupkt    rmb    1         UDP packet flag  0007               wzerr     rmb    1         error code passing                     *  0008               wzxfer    rmb    2         transfer size  000A               wzrqln    rmb    2         requested size                     *  000C               wzdma1    rmb    2         if split xfer, first part  000E               wzdma2    rmb    2         if split xfer, second part                     *                     * unix socket call info                     *  0010               wzsprt    rmb    2         source port  0012               wzdprt    rmb    2         destination port  0014               wzipad    rmb    4         dest IP address  0018               wzsflg    rmb    2         flags                     *                     * udp header info                     *  001A               wzuipa    rmb    4         ip address from UDP header  001E               wzuprt    rmb    2         port number from UDP header  0020               wzurms    rmb    2         socket remained size                     * UDP write pointer  0022               wzuwrp    rmb    2         write pointer save                     *                     * open parameters                     *  0024               wzfaml    rmb    2         family            for check AF_  0026               wztype    rmb    2         type              for check SOCK_  0028               wzprot    rmb    2         protocol          for check IPPROTO_                                    002A  WZSIZE    equ    *-wzenum                       0000                         org    $0                     *                     * holds the local IP info, wzdev  net0                     * ipad, mask, gwad, macad                     *  0000               wzmyip    rmb    4         Device IP addressTask       Structure                 07:27:44  Jan 07, 2024   Page   15IOP        Memory Layout                              0004               wzsbnm    rmb    4         Subnet mask bits  0008               wzgwad    rmb    4         Gateway IP address  000C               wzhwad    rmb    6         Device Hardware address                     *  0012               wzdsta    rmb    1         up/down status  0013                         rmb    3                                    0016  WZLCSZ    equ    *-wzmyip                     *                     * this is (an attempt) to implement the Berkely                     * socket interface into the UniFLEX 6309 kernel (no 6809)                     *  0000                         org    0                                          * struct sockaddr  0000               sa_fam    rmb    2         address family  0002               sa_dat    rmb    14        protocol address               0010  SKADLN    equ    *                                          * struct sockaddr_in  0010               sin_fam   rmb    2         AF_INET  0012               sin_port  rmb    2         16 bit port  0014               sin_addr  rmb    4         32 bit netid/hostid                                          * address families               0000  AF_UNSP   equ    0         AF_UNSPEC               0001  AF_UNIX   equ    1         AF_UNIX               0002  AF_INET   equ    2         AF_INET                                          * socket types               0001  SK_STRM   equ    1         socket stream               0002  SK_DGRM   equ    2         datagram, conn less               0003  SK_RAW    equ    3         raw socket                                          * protocol families               0001  PF_UNIX   equ    AF_UNIX   same as address families               0002  PF_INET   equ    AF_INET                                          *               05C0  MAX_UDP   equ    1472      max size of UDP packet                                          FIO Simulation Structure             07:27:44  Jan 07, 2024   Page   16IOP        Memory Layout                                                                      *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         UIO                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         UIO                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************FIO Simulation Structure             07:27:45  Jan 07, 2024   Page   17IOP        Memory Layout                              0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************FIO Simulation Structure             07:27:45  Jan 07, 2024   Page   18Dual_Port RAM Structure                                                                                            *                     * this is an OVERLAY on a 1Kx8 FIFO in DPR                     *                     * the primary fifo definitions are not touched                     *                     * some locations may be re-used for this purpose                     *               0000  DPR_BASE  equ    $0000     GPP DPR at this address (GPP)  0000                         org    DPR_BASE  -- Dual port RAM address                                          *               0000  nwp_strt  equ    *         first address  of DPR RAM                     *                     ******************************************************  0000                         rmb    32        defined in fio.h                       0020                         rmb    512       fifo space                     ******************************************************               0220  WZSKOFF   equ    *                     ******************************************************  0220               wzsk8     rmb    WZSIZE    sock structure  024A               wzsk7     rmb    WZSIZE    sock  0274               wzsk6     rmb    WZSIZE    sock  029E               wzsk5     rmb    WZSIZE    sock  02C8               wzsk4     rmb    WZSIZE    sock  02F2               wzsk3     rmb    WZSIZE    sock  031C               wzsk2     rmb    WZSIZE    sock  0346               wzsk1     rmb    WZSIZE    sock                     ******************************************************               0370  WZNETOF   equ    *  0370               wlocip    rmb    WZLCSZ    network device                     ******************************************************                     *                     * fifo top                     * specified in fio.h                     *                     ******************************************************                     *                     * IOP ROM Version #                     *               0030  ROM_VERSION equ  $30       Major/Minor Version of IOP ROM                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)FIO Simulation Structure             07:27:45  Jan 07, 2024   Page   19Dual_Port RAM Structure                                            0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 generic socket error, actual is passed                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               0001  R_OPEN    equ    $01       [S]  Device open successful               0002  R_CLOSE   equ    $02       [S]  Device close successful               0003  R_RQWR    equ    $03       [S]  request for write               0004  R_WRITE   equ    $04       [S]  write data via fifo to net               0005  R_RQRD    equ    $05       [S]  request for read data               0006  R_READ    equ    $06       [S]  read data via fifo from net               0007  R_INTRPT  set    $07       [S]  Interrupt complete               0008  R_CONNECT equ    $08       [S]  connect ok               0009  R_BIND    equ    $09       [S]  bind call ok               000A  R_LISTEN  equ    $0A       [S]  listen call ok               000B  R_ACCEPT  equ    $0B       [S]  accept call ok               000C  R_DISCON  equ    $0C       [S]  disconnect happened               000D  R_SNDMAC  equ    $0D       [S]  send mac done               000E  R_SNDKEP  equ    $0E       [S]  send keep alive done               000F  R_SPCL    equ    $0F       [S]  special call ok               0015  R_RQRDNB  equ    $15       [S]  non block return read               0013  R_RQWRNB  equ    $13       [S]  non block return write                     *               0021  R_RDFRM   equ    $21       [S]  request for data readfrom               0022  R_RRDFD   equ    $22       [S]  read data readfrom next packet               0023  R_RSNDTO  equ    $23       [S]  request write sendto               0024  R_WSNDTO  equ    $24       [S]  write data sendto               0025  R_SNDTOM  equ    $25       [S]  write data, request more                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     * Socket functions                     *               0008  S_OPEN    equ    $08       Open socket               0010  S_CLOSE   equ    $10       Close socket               0018  S_RQWR    equ    $18       request write to socket               0020  S_WRITE   equ    $20       Write data to socket               0028  S_RQRD    equ    $28       Request read data from socket               0030  S_READ    equ    $30       Read data from socket               0038  S_INTRPT  equ    $38       Interrupt socket               0038  O_INTRPT  set    S_INTRPT               0040  S_CONNECT equ    $40       Connect socket               0048  S_BIND    equ    $48       Bind socket               0050  S_LISTEN  equ    $50       Listen on socket               0058  S_ACCEPT  equ    $58       Accept connection on socket               0060  S_DISCON  equ    $60       Disconnect socket               0068  S_SNDMAC  equ    $68       Send to macFIO Simulation Structure             07:27:45  Jan 07, 2024   Page   20Dual_Port RAM Structure                                            0070  S_SNDKEP  equ    $70       Send keep alive               0078  S_SPCL    equ    $78       Special. i.e set network device                     *               0080  S_RRDFRM  equ    $80       request read readfrom               0088  S_RREAD   equ    $88       read data readfrom               0090  S_WRQSTO  equ    $90       request send ssendto               0098  S_WSNDTO  equ    $98       send data sendto               00A0  S_WSNDTM  equ    $a0       send to more data                     *               0015  MAX_S_NUM equ    21        # of supported functions (incl 0)                     *                     * definition of all interrupts in the W5500                     *                                          *                     * interrupts per socket (Socket registers)                     *               0001  SI_CON    equ    %00000001 Sn_IR(CON)               0002  SI_DIS    equ    %00000010 Sn_IR(DISCON)               0004  SI_RCV    equ    %00000100 Sn_IR(RECV)               0008  SI_TIM    equ    %00001000 Sn_IR(TIMEOUT)               0010  SI_SOK    equ    %00010000 Sn_IR(SEND_OK)                                          *                     * common interrupts  (Common registers)                     *               0010  CI_MP     equ    %00010000 Magic Packet               0020  CI_POC    equ    %00100000 PPoE Close               0040  CI_UNR    equ    %01000000 UNREACH               0080  CI_CFL    equ    %10000000 IP ConflictFIO Simulation Structure             07:27:45  Jan 07, 2024   Page   21Variable   Space                                                           0400                         org    RAMorg                       0400               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"                       0400               DB_iflg   rmb    1         Debug terminal initialized  0401               DB_cntrl  rmb    2         Debug control flags                     *  0403               runlst    rmb    2         Pointer to active tasks  0405               slplst    rmb    4         Pointer to waiting tasks  0409               utask     rmb    2         Currently executing task  040B               jobpri    rmb    1         Current job priority (for scheduling)  040C               chproc    rmb    1         Set if must switch users of CPU (reschedule)                     *  040D               idle      rmb    1         idle loop flag for scheduler  040E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  0444               SI_Q_ptr  rmb    2         current Q pointer  0446               FIO_lock  rmb    1         FIO in use lock  0447               int_buf   rmb    12        Current Message in  0453               int_ptr   rmb    2         Message in pointer  0455               clock_tick rmb   1         Clock tick counter  0456               spiint    rmb    1         Interrupt flag from w5500  0457               wzanyp    rmb    2         Source Port  0459               NUM_TSK   rmb    1         max tasks                       045A               hstbuf    rmb    HRECSIZ*MAXHIST  049A               hstptr    rmb    2         next "put" pointer in history queue                                          * Pointers to system tables - configuration dependent  049C               tsktab    rmb    2         Task Control Tables  049E               tskend    rmb    2         End of task table  04A0               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table                     *  04A6                         rmb    32                       04C6               SYS_TABS  rmb    0         Start of dynamic system tables                                    04C6  lstram    equ    *               3EFF  end_vars  equ    RAMend    End of System Variables                                          FIO Simulation Structure             07:27:46  Jan 07, 2024   Page   22CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 E0A1                    fdb    rom_trap  Unused  FFF2 E09A                    fdb    rom_swi3  SWI3  FFF4 E093                    fdb    rom_swi2  SWI2  FFF6 E086                    fdb    rom_firq  FIRQ  FFF8 E395                    fdb    IRQ_han   IRQ  FFFA E08D                    fdb    rom_swi   SWI  FFFC E080                    fdb    rom_nmi   Background debug  FFFE E05F                    fdb    rom_init  Reset                     FIO Simulation Structure             07:27:46  Jan 07, 2024   Page   23System     RESET Code                                                      E000                         org    ROMLOorg                       E000 0D 4E 57 50   DBmsg00   fcc    $d,'NWP ROM',0  E009 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E029 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E03D 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          * share settings with kernel driver code               E05A  fio_fsz   equ    *         device fifo size               E05C  fio_dsz   equ    *+2       device RAM size               E05E  max_trn   equ    *+4       max transactions                     *                     * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and NWP CPU                     *  E05A 0200                    fdb    512       fio_fsz FIFO SIZE  E05C 0400                    fdb    1024      fio_dsz DEVICE SIZE  E05E 08                      fcb    8         fio_mxtrn MAX_TRANSACTIONS                     *                     * declaration of offsets and settings                     *               0008  MAX_WZ    equ    8         # of sockets in w5500                                                               *                     * System RESET code                     *  E05F 10CE 7FE0     rom_init  lds    #ROMstack initialize stack pointer  E063                         ldmd   3  E063 113D                    fdb    $113d  E065 03                      fcb    3                               endm                                          *                     * for background debugger                     *                     **        lda     #$15                     **        sta     ACIAC         init debug acia                     **        clr     bdbsta        echo on                                            E066 8E   E395               ldx    #IRQ_han  IRQ  E069 BF   7F00               stx    $7f00     GPPMON vector                                           >E06C 17   0053     20        lbsr   stbinit   go initialize system memory                       E06F 10FE 049C     30        lds    tsktab    Task 0 Stack  E073 32   E9 00D7            leas   TSKSIZ,s  E077 17   0152               lbsr   fio_reset  E07A 17   012C               lbsr   timerinFIO Simulation Structure             07:27:46  Jan 07, 2024   Page   24System     RESET Code                                                    *                     * Initialization complete - Start executing commands                     *  E07D               fio_start  E07D 7E   E49A     10        jmp    rsched                                          FIO Simulation Structure             07:27:46  Jan 07, 2024   Page   25ROM        Interrupt Fielders                                              E080 8D   26       rom_nmi   bsr    rom_int  E082 4E 4D 49 00             fcc    'NMI',0  E086 8D   20       rom_firq  bsr    rom_int  E088 46 49 52 51             fcc    'FIRQ',0  E08D 8D   19       rom_swi   bsr    rom_int  E08F 53 57 49 00             fcc    'SWI',0  E093 8D   13       rom_swi2  bsr    rom_int  E095 53 57 49 32             fcc    'SWI2',0  E09A 8D   0C       rom_swi3  bsr    rom_int  E09C 53 57 49 33             fcc    'SWI3',0  E0A1 8D   05       rom_trap  bsr    rom_int  E0A3 54 52 41 50             fcc    'TRAP',0                       E0A8 8E   E0B5     rom_int   ldx    #ROM_ERR  E0AB BD   F192               jsr    DB_pdata  E0AE 35   10                 puls   x  E0B0 BD   F192               jsr    DB_pdata  E0B3 20   FE       rom_bad   bra    *                     *  E0B5 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0FIO Simulation Structure             07:27:46  Jan 07, 2024   Page   26Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0C2 8E   0000     stbinit   ldx    #0        s  clear all variables  E0C5 CC   0000               ldd    #0  E0C8 ED   81       10        std    ,x++  E0CA 8C   3EFF               cmpx   #end_vars done yet?  E0CD 25   F9                 blo    10b                       E0CF CC   0D04               ldd    #DEBUG  E0D2 FD   0401               std    DB_cntrl                                            E0D5 B6   E05E               lda    max_trn   shared with main CPU  E0D8 48                      asla             *2  E0D9 8B   04                 adda   #4        fixed system tasks  E0DB B7   0459               sta    NUM_TSK                     * >E0DE 17   0013               lbsr   set_tables go figure out configuration, tables, etc                                          * Initialize Socket Interrupt Queue  E0E1 8E   040E     15        ldx    #SI_Q     set queue empty  E0E4 BF   0444               stx    SI_Q_ptr  E0E7 8E   0447               ldx    #int_buf  reset message in pointer  E0EA BF   0453               stx    int_ptr                      >E0ED 17   0061     17        lbsr   tskinit   initialize tasks                       E0F0 17   10BD     18        lbsr   DB_config display configuration  E0F3 39                      rts                                          *                     * Set up system tables                     *  E0F4               set_tables  E0F4 108E 04A0               ldy    #dev_tab  E0F8 8E   E5CD               ldx    #DEV_SOCK  E0FB AF   22                 stx    dev_type,y  E0FD AD   98 2A              jsr    [D_init,x]                                          * Compute configuration  E100 CE   E1BB               ldu    #mod_tbl  tables with module refs  E103 AE   C4       12        ldx    mod_type,u  E105 27   09                 beq    20f       jump if end of module table  E107 AD   98 2C              jsr    [D_test,x] check for device  E10A 25   04                 bcs    15f       jump if found  E10C 33   44                 leau   MOD_SIZE,u  E10E 20   F3                 bra    12b                     *FIO Simulation Structure             07:27:47  Jan 07, 2024   Page   27Table      Initialization                             E110               15  E110               20                     * -- All done setting up configuration                       E110 CC   04C6               ldd    #SYS_TABS start of system tables  E113 1F   03                 tfr    d,u                     * -- Task table  E115 86   D7                 lda    #TSKSIZ  E117 F6   0459               ldb    NUM_TSK  E11A 3D                      mul  E11B FF   049C               stu    tsktab >E11E 17   0022               lbsr   sto_chk   check for system table space overflow  E121 FF   049E               stu    tskend                     *                     * -- All done  E124 39            90        rts                     *  E125 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E13C 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                    *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E143 33   CB       sto_chk   leau   d,u       compute new end pointer  E145 1183 3EFF               cmpu   #end_vars overflow?  E149 22   03                 bhi    10f       yes - return error  E14B 1C   FE                 clc              no         - return OK  E14D 39                      rts  E14E 1A   01       10        sec              ..         bad owies  E150 39                      rts                                          *                     * tskinit - Initialize all tasks                     *  E151 BE   049C     tskinit   ldx    tsktab  E154 BF   0409               stx    utask  E157 F6   0459               ldb    NUM_TSK   # tasks in system  E15A 34   04                 pshs   b  E15C 10BE 049C               ldy    tsktab    task 1  E160 31   A9 00D7            leay   TSKSIZ,y  E164               10                                            E164 86   04       11        lda    #TFREE    mark all tasks free  E166 BC   049C               cmpx   tsktab    is this the system task?FIO Simulation Structure             07:27:47  Jan 07, 2024   Page   28Table      Initialization                             E169 26   02                 bne    15f  E16B 86   05                 lda    #TSYS     the system task is never free  E16D A7   04       15        sta    tsstat,x  E16F 86   FF                 lda    #$FF      not associated with a terminal  E171 A7   0D                 sta    tsdev,x  E173 A7   0E                 sta    tsdev+1,x  E175 33   89 00D7            leau   TSKSIZ,x  initialize stack  E179 CC   E319               ldd    #IO_han  E17C 34   20                 pshs   y  E17E AC   E1                 cmpx   ,s++      task 1?  E180 26   03                 bne    20f       no - normal I/O handling task  E182 CC   E3E9               ldd    #SI_HAN   yes - special terminal interrupt handling task  E185 36   06       20        pshu   d  E187 EF   88 11              stu    usp,x  E18A EF   88 13              stu    umark0,x  E18D 30   89 00D7            leax   TSKSIZ,x  E191 6A   E4                 dec    0,s       done?  E193 26   CF                 bne    10b  E195 32   61                 leas   1,s       clean up stack  E197 CC   0000               ldd    #0        nothing running or sleeping  E19A FD   0403               std    runlst  E19D FD   0405               std    slplst  E1A0 FD   0407               std    slplst+tsslnk  E1A3 30   A4                 leax   0,y       start interrupt handling task  E1A5 BD   E540               jsr    makrdy  E1A8 39                      rts                                                               *                     * GPP interrupt timer                     *               8400  tim_base  equ    $8400               8401  tim_rest  equ    $8401                       E1A9 86   00       timerin   lda    #%00000000 D0      (OFF!)  E1AB B7   8400               sta    tim_base  interrupt enable  E1AE 39                      rts                                                         E1AF  timerack  equ    *  E1AF 86   01                 lda    #1  E1B1 B7   8401               sta    tim_rest  reset interrupt  E1B4 39                      rts                       E1B5 B6   8400     timerchk  lda    tim_base  E1B8 84   80                 anda   #%10000000 interrupt flag  E1BA 39                      rtsFIO Simulation Structure             07:27:47  Jan 07, 2024   Page   29IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E1BB  mod_tbl   equ    *  E1BB E5CD E1C1               fdb    DEV_SOCK,WZ5_name  E1BF 0000                    fdb    0                     *  E1C1 57 35 35 30   WZ5_name  fcc    'W5500_SOCK',0FIO Simulation Structure             07:27:47  Jan 07, 2024   Page   30FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     *  E1CC               fio_reset                     * when here, all storage locations have been erased already                     *  E1CC 8E   0000               ldx    #0  E1CF 9F   14                 stx    fifo_get  set Q pointers  E1D1 9F   16                 stx    fifo_put  E1D3 8E   0370               ldx    #WZNETOF  E1D6 9F   1A                 stx    fifo_us1  E1D8 8E   0220               ldx    #WZSKOFF  E1DB 9F   18                 stx    fifo_us0  so that kernel CPU can see it                     * init the 8 SOCK structs  E1DD 86   08                 lda    #8  E1DF A7   84       01        sta    wzenum,x  E1E1 30   88 2A              leax   WZSIZE,x  to next  E1E4 4A                      deca  E1E5 26   F8                 bne    01b                     *  E1E7 BE   E05C               ldx    fio_dsz  E1EA 30   1E                 leax   -2,x      one from top  E1EC CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E1EF C6   FF       fio_wait  ldb    #255      Spin counter                     *  E1F1               00  E1F1 6D   84                 tst    0,x       fio_cpuF  E1F3 27   16                 beq    10f                     *  E1F5 5A                      decb  E1F6 26   F9                 bne    00b       jump back if not ready                     *  E1F8 33   5F                 leau   -1,u  E1FA 1183 0000               cmpu   #0  E1FE 26   EF                 bne    fio_wait  E200 8E   E03D               ldx    #CPU_down  E203 17   0F8C               lbsr   DB_pdata  E206 17   0F83               lbsr   DB_main  E209 20   C1                 bra    fio_reset                     * reset OK  E20B 39            10        rts                                                               *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     *  E20C BE   0453     fio_irq   ldx    int_ptr   input message pointer  E20F 96   00                 lda    cpu_fio   move REQUEST  E211 A7   80                 sta    ,x+FIO Simulation Structure             07:27:48  Jan 07, 2024   Page   31FIO        Simulation Routines                        E213 DC   01                 ldd    cpu_fio1  sequence # TASK ID  E215 ED   81                 std    ,x++  E217 96   03                 lda    cpu_fio2  specific DATA  E219 A7   80                 sta    ,x+  E21B DC   04                 ldd    cpu_fio3  device major/minor  E21D ED   81                 std    ,x++                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     *  E21F FE   E05C               ldu    fio_dsz  E222 33   5F                 leau   -1,u  E224 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  E226 BF   0453               stx    int_ptr   update pointer  E229 108E 0447               ldy    #int_buf  get message from buffer  E22D A6   A4                 lda    0,y       -- Send interrupt command?  E22F 81   38                 cmpa   #S_INTRPT  E231 26   0D                 bne    30f                     *                     * special case OOB signal                     *  E233 10BF 0453               sty    int_ptr   reset pointer  E237 E6   23                 ldb    3,y       signal  E239 AE   24                 ldx    4,y       SOCK reference                     *  E23B BD   E61B               jsr    sdev_sig  send device signal  E23E 20   35                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  E240 BE   049C     30        ldx    tsktab    search for an available task  E243 F6   0459               ldb    NUM_TSK   Number of tasks in system                     *  E246 A6   04       32        lda    tsstat,x  E248 81   04                 cmpa   #TFREE    looking for a "free" task  E24A 27   0E                 beq    40f                     *  E24C 30   89 00D7            leax   TSKSIZ,x  E250 5A                      decb  E251 26   F3                 bne    32b                     *  E253 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated! >E255 BD   E276               jsr    fio_msg  E258 20   1B                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     * move data over into task struct                     *  E25A 108E 0447     40        ldy    #int_buf  get message from buffer  E25E 10BF 0453               sty    int_ptr   reset pointer  E262 E6   A0                 ldb    ,y+       command byte  REQUESTFIO Simulation Structure             07:27:48  Jan 07, 2024   Page   32FIO        Simulation Routines                        E264 E7   09                 stb    tscmd,x   save for task  E266 EC   A1                 ldd    ,y++      sequence #    task ID  E268 ED   0A                 std    tsseq,x  E26A E6   A0                 ldb    ,y+       command specific DATA  E26C E7   0C                 stb    tstval,x  E26E EC   A1                 ldd    ,y++      associate with terminal major/minor  E270 ED   0D                 std    tsdev,x  E272 BD   E540               jsr    makrdy    make task ready to run                     *  E275 39            fiointe   rts              exit                                          *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *  E276 34   54       fio_msg   pshs   b,x,u     save register  E278 FE   E05C               ldu    fio_dsz  E27B 33   5E                 leau   -2,u      one off top  E27D D7   09                 stb    fio_cpu   set up mailbox value                       E27F 86   FF       5         lda    #$FF      tell CPU mailbox full  E281 A7   C4                 sta    0,u       fio_cpuF  E283 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  E286 A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  E288 27   06                 beq    20f       jump if consumed                     *  E28A 30   1F                 leax   -1,x      time-out yet?  E28C 26   F8                 bne    10b                     *  E28E 20   F3                 bra    05b       try again                     *  E290 35   D4       20        puls   b,x,u,pc                     *                                          *                     * this is the normal way the IOP sends data to the host CPU                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *  E292 34   16       fio_response pshs d,x  E294 8D   18                 bsr    FIO_get   access FIO  E296 BE   0409               ldx    utask     task ID  E299 EC   0A                 ldd    tsseq,x  E29B DD   0A                 std    fio_cpu1  E29D EC   0D                 ldd    tsdev,x   device info  E29F DD   0D                 std    fio_cpu3FIO Simulation Structure             07:27:48  Jan 07, 2024   Page   33FIO        Simulation Routines                        E2A1 A6   E4                 lda    0,s       get transaction specific value (i.e. error code)  E2A3 97   0C                 sta    fio_cpu2  E2A5 E6   61                 ldb    1,s       is RESPONSE code >E2A7 BD   E276               jsr    fio_msg  E2AA 8D   17                 bsr    FIO_rel   release FIO  E2AC 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  E2AE 34   76       FIO_get   pshs   d,x,y,u   save registers  E2B0 108E 0446     10        ldy    #FIO_lock is the device locked  E2B4 6D   A4                 tst    0,y  E2B6 27   07                 beq    20f       no - go get it                     *  E2B8 C6   CE                 ldb    #FIOPRI   waiting for the FIO  E2BA BD   E57A               jsr    sleep  E2BD 20   F1                 bra    10b       try again                     *  E2BF 6C   A4       20        inc    0,y       mark in use  E2C1 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  E2C3 34   76       FIO_rel   pshs   d,x,y,u  E2C5 108E 0446               ldy    #FIO_lock  E2C9 6F   A4                 clr    0,y  E2CB BD   E556               jsr    wakeup  E2CE 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E2D0 34   04       FIFOgeta  pshs   b  E2D2 8D   05                 bsr    FIFO_get  E2D4 35   02                 puls   a  E2D6 1E   89                 exg    a,b  E2D8 39                      rts                     *  E2D9 34   12       FIFO_get  pshs   a,x  E2DB DC   12                 ldd    fifo_cnt  any data?  E2DD 27   15                 beq    99f       no - exit                     *  E2DF                         decd   yes       - adjust count  E2DF 104A                    fdb    $104a                               endm  E2E1 DD   12                 std    fifo_cnt  E2E3 9E   14                 ldx    fifo_get  get consumer pointer  E2E5 E6   88 20              ldb    fifo,x    fetch byteFIO Simulation Structure             07:27:48  Jan 07, 2024   Page   34FIO        Simulation Routines                        E2E8 30   01                 leax   1,x       bump pointer  E2EA BC   E05A               cmpx   fio_fsz   end of fifo?  E2ED 26   03                 bne    10f                     *  E2EF 8E   0000               ldx    #0        reset pointer                     *  E2F2 9F   14       10        stx    fifo_get                     *  E2F4 35   92       99        puls   a,x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  E2F6 34   04       FIFOputa  pshs   b  E2F8 1F   89                 tfr    a,b  E2FA 8D   02                 bsr    FIFO_put  E2FC 35   84                 puls   b,pc                     *  E2FE 34   16       FIFO_put  pshs   d,x  E300 9E   16                 ldx    fifo_put  get consumer pointer  E302 E7   88 20              stb    fifo,x    store byte  E305 30   01                 leax   1,x       bump pointer  E307 BC   E05A               cmpx   fio_fsz   end of FIFO?  E30A 26   03                 bne    10f                     *  E30C 8E   0000               ldx    #0        reset pointer  E30F 9F   16       10        stx    fifo_put                     *  E311 DC   12                 ldd    fifo_cnt  E313                         incd  E313 104C                    fdb    $104c                               endm  E315 DD   12                 std    fifo_cnt  E317 35   96       99        puls   d,x,pcFIO Simulation Structure             07:27:49  Jan 07, 2024   Page   35IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  E319               IO_han    seti   block     interrupts  E319 1A   50                 orcc   #FF|IF                               endm                     *                     * we execute the task belonging to the transaction                     *  E31B               10        clri  E31B 1C   AF                 andcc  #!(FF|IF)                               endm  E31D BE   0409               ldx    utask     get task control block address  E320 A6   09                 lda    tscmd,x   get I/O command                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab                     *  E322 44                      lsra             isolate    command  E323 44                      lsra  E324 44                      lsra                     **        lsra  E325 81   15                 cmpa   #MAX_S_NUM  E327 22   69                 bhi    bad_cmd                     *  E329 48                      lsla             --   word index on command  E32A 34   10                 pshs   x  E32C 8E   04A0               ldx    #dev_tab  E32F AE   02                 ldx    dev_type,x get handler table address  E331 10AE 86                 ldy    a,x       get processor address  E334 35   10                 puls   x  E336 34   20                 pshs   y  E338 10AE 0F                 ldy    tsagin,x  if 0, d nothing  E33B 27   0A                 beq    05f       else it is target ponter  E33D 10AF E4                 sty    0,s  E340 108E 0000               ldy    #0  E344 10AF 0F                 sty    tsagin,x  reset pointer  E347 35   20       05        puls   y         change address  E349 4F                      clra                     *  E34A 8E   E377               ldx    #IO_end   interrupt handler address  E34D 34   10                 pshs   x  E34F BE   0409               ldx    utask     task pointer  E352 10EF 88 15              sts    umark1,x  E356 EE   0D                 ldu    tsdev,x   get sock refernceFIO Simulation Structure             07:27:49  Jan 07, 2024   Page   36IO         Command Handler                            E358 1E   03                 exg    d,u  E35A 84   07                 anda   #%00000111 mask off address bits  E35C 1E   03                 exg    d,u                     *                     * CALL HANDLER: X=utask, Y=handler address, U=sock address                     *  E35E AD   A4                 jsr    0,y       perform operation & return status  E360 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     *  E362 BE   0409               ldx    utask     restore task pointer  E365 108C FFFF               cmpy   #$ffff  E369 26   09                 bne    20f                     * task is NOT done yet  E36B 86   BA                 lda    #POLPRI  E36D A7   05                 sta    tsprir,x  at lower prio  E36F BD   E494               jsr    change  E372 20   1B                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  E374 BD   E292     20        jsr    fio_response                     *                     * task is done                     *  E377               IO_end    seti   mask      interrupts  E377 1A   50                 orcc   #FF|IF                               endm  E379 BE   0409               ldx    utask     restore task control block address  E37C A7   0C                 sta    tstval,x  remember transaction value sent  E37E E7   09                 stb    tscmd,x   and command response  E380 86   04                 lda    #TFREE    mark task "terminated & free"  E382 A7   04                 sta    tsstat,x  E384 86   FF                 lda    #$FF      disassociate from any terminal  E386 A7   0D                 sta    tsdev,x  E388 A7   0E                 sta    tsdev+1,x  E38A 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *  E38C BD   E49A     90        jsr    rsched    run other tasks >E38F 16   FF87     91        lbra   IO_han                                          *                     * Illegal command                     *  E392               bad_cmdFIO Simulation Structure             07:27:49  Jan 07, 2024   Page   37IO         Command Handler                            E392 C6   81                 ldb    #E_BADCMD error code  E394 39                      rtsFIO Simulation Structure             07:27:49  Jan 07, 2024   Page   38Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *               E395  IRQ_han   equ    *                     *                     * Check for FIO Mailbox interrupt                     *  E395 BE   E05C     10        ldx    fio_dsz  E398 30   1F                 leax   -1,x  E39A A6   84                 lda    0,x       cpu_fioF   see if mailbox interrupt  E39C 27   03                 beq    99f       no - move on  E39E BD   E20C               jsr    fio_irq   call fio interrupt handler                     *                     *         lbsr    DB_main                     *  E3A1 3B            99        rti              return from interrupt                     *  E3A2 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  E3AD 2D 2D 20 4E   00        fcc    '-- No tasks!',0FIO Simulation Structure             07:27:49  Jan 07, 2024   Page   39Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E3BA 34   36       int_all   pshs   d,x,y  E3BC F6   0459               ldb    NUM_TSK  E3BF C0   02                 subb   #2  E3C1 34   04                 pshs   b  E3C3 BE   049C               ldx    tsktab  E3C6 30   89 01AE            leax   2*TSKSIZ,x                     *  E3CA EC   61       10        ldd    1,s  E3CC 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  E3CF 26   0C                 bne    20f                     *  E3D1 BC   0409               cmpx   utask     make sure I don't get blown away  E3D4 27   07                 beq    20f                     *  E3D6 34   16                 pshs   d,x  E3D8 BD   E5AF               jsr    xmtint    interrupt task  E3DB 35   16                 puls   d,x                     *  E3DD 30   89 00D7  20        leax   TSKSIZ,x  next task  E3E1 6A   E4                 dec    0,s       more tasks?  E3E3 26   E5                 bne    10b  E3E5 32   61                 leas   1,s                     *  E3E7 35   B6                 puls   d,x,y,pc  returnFIO Simulation Structure             07:27:50  Jan 07, 2024   Page   40Terminal   Interrupt Handling Task                                                            *                     * SI_HAN Socket interrupt handler                     *  E3E9 108E 040E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  E3ED                         seti  E3ED 1A   50                 orcc   #FF|IF                               endm  E3EF FE   0444               ldu    SI_Q_ptr  get current Q ptr  E3F2 1183 040E               cmpu   #SI_Q     anything in Q?  E3F6 26   07                 bne    20f       yes - go process it                     *  E3F8 C6   D8                 ldb    #SIQPRI   wait for something to do  E3FA BD   E57A               jsr    sleep  E3FD 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  E3FF E6   C2       20        ldb    0,-u      B = Interrupt #  E401 34   04                 pshs   b  E403 EC   C3                 ldd    0,--u     A = Device #  E405 34   06                 pshs   d  E407 EC   C3                 ldd    0,--u     task ID  E409 34   06                 pshs   d         save registers  E40B FF   0444               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  E40E E6   63                 ldb    3,s       set up to flush all input for this terminal                     **!       jsr     ttftab     X=ttytab, U=device table                     **!       jsr     flushi  E410                         clri   allow     interrupts  E410 1C   AF                 andcc  #!(FF|IF)                               endm                     *  E412 BD   E2AE               jsr    FIO_get   get access to FIO  E415 EC   E1                 ldd    0,s++     task ID  E417 DD   0A                 std    fio_cpu1  E419 EC   E1                 ldd    ,s++      terminal #  E41B DD   0D                 std    fio_cpu3  terminal  E41D E6   E0                 ldb    ,s+       interrupt #  E41F D7   0C                 stb    fio_cpu2  signal  E421 C6   07                 ldb    #R_INTRPT  E423 BD   E276               jsr    fio_msg   send interrupt message  E426 BD   E2C3               jsr    FIO_rel   release access to FIO  E429 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a socket interrupt                     *   B = Interrupt #                     *   X = SOCK address                     *   jsr send_SIFIO Simulation Structure             07:27:50  Jan 07, 2024   Page   41Terminal   Interrupt Handling Task                                       *  E42B 34   76       send_SI   pshs   d,x,y,u   save registers  E42D FE   0444               ldu    SI_Q_ptr  get Q head  E430 1183 0444               cmpu   #SI_Q_ptr check for overflow  E434 24   0D                 bhs    90f       exit if so - sorry                     *  E436 34   04                 pshs   b                     **!       ldd     ttask,x    task id  E438 ED   C1                 std    0,u++                     **!       ldd     tdevic,x   get terminal #  E43A ED   C1                 std    0,u++     place value in Queue  E43C 35   04                 puls   b  E43E E7   C0                 stb    0,u+  E440 FF   0444               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  E443 108E 040E     90        ldy    #SI_Q     wake up Queue server  E447 BD   E556               jsr    wakeup  E44A 35   F6                 puls   d,x,y,u,pc return                     FIO Simulation Structure             07:27:50  Jan 07, 2024   Page   42History    Entry Procedures                                                                   *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  E44C 34   16       H_cpu     pshs   d,x  E44E BE   049A               ldx    hstptr    get history queue pointer  E451 96   00                 lda    cpu_fio  E453 A7   84                 sta    hst_cmd,x  E455 96   01                 lda    cpu_fio1  E457 A7   01                 sta    hst_seq,x  E459 96   04                 lda    cpu_fio3  E45B A7   02                 sta    hst_tty,x  E45D 96   03                 lda    cpu_fio2  E45F A7   03                 sta    hst_val,x  E461 30   04                 leax   HRECSIZ,x  E463 8C   049A               cmpx   #hstptr   end of Queue?  E466 25   03                 blo    10f  E468 8E   045A               ldx    #hstbuf  E46B BF   049A     10        stx    hstptr  E46E 35   96                 puls   d,x,pc                                          *                     * H_fio - Place a transaction from the IOP into                     *         the history Queue.                     *  E470 34   16       H_fio     pshs   d,x  E472 BE   049A               ldx    hstptr    get history queue pointer  E475 96   09                 lda    fio_cpu  E477 A7   84                 sta    hst_cmd,x  E479 96   0A                 lda    fio_cpu1  E47B A7   01                 sta    hst_seq,x  E47D 96   0D                 lda    fio_cpu3  E47F A7   02                 sta    hst_tty,x  E481 96   0C                 lda    fio_cpu2  E483 A7   03                 sta    hst_val,x  E485 30   04                 leax   HRECSIZ,x  E487 8C   049A               cmpx   #hstptr   end of Queue?  E48A 25   03                 blo    10f  E48C 8E   045A               ldx    #hstbuf  E48F BF   049A     10        stx    hstptr  E492 35   96                 puls   d,x,pcFIO Simulation Structure             07:27:50  Jan 07, 2024   Page   43Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E494 BE   0409     change    ldx    utask     point to task table entry >E497 17   006D               lbsr   putrun    put on ready list                     *  E49A               rsched    seti   mask      interrupts  E49A 1A   50                 orcc   #FF|IF                               endm  E49C BE   0409               ldx    utask     point to current task  E49F 10EF 88 13              sts    umark0,x  save stack pointers  E4A3 BE   049C               ldx    tsktab    point to task table  E4A6 8D   23                 bsr    swtchu    switch users  E4A8 7F   040D               clr    idle      reset idle/running flag                     *  E4AB 7F   040C     rsche2    clr    chproc    reset change flag >E4AE 17   0025               lbsr   getjob    get a new task  E4B1 26   0C                 bne    rsche3    find one?                                          ***+++                     ***---                       E4B3 86   7F       05        lda    #127      set higheset priority  E4B5 B7   040B               sta    jobpri    set as current  E4B8                         clri   clear     interrupts  E4B8 1C   AF                 andcc  #!(FF|IF)                               endm                     * idle work could go on here  E4BA 12                      nop  E4BB                         seti  E4BB 1A   50                 orcc   #FF|IF                               endm  E4BD 20   EC                 bra    rsche2    loop til find a ready one                     *  E4BF F7   040B     rsche3    stb    jobpri    set new priority  E4C2 8D   07                 bsr    swtchu    switch users top pageFIO Simulation Structure             07:27:51  Jan 07, 2024   Page   44Scheduler  routines                                   E4C4 BE   0409               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  E4C7 CC   0001               ldd    #1        return 1 to new task  E4CA 39                      rts              return                                              *                     * Switch users                     *   X - Task entry for new task                     *  E4CB 35   20       swtchu    puls   y         get return address  E4CD BF   0409               stx    utask     set up new running task  E4D0 10EE 88 13              lds    umark0,x  reset stack                                          ***+++                     ***---                       E4D4 6E   A4                 jmp    0,y       return to caller                                          ***+++                     ***---                                                                                    ***+++                     ***---                                          FIO Simulation Structure             07:27:51  Jan 07, 2024   Page   45Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       E4D6 5F            getjob    clrb             clear      flag  E4D7 BE   0403               ldx    runlst    point to head of list  E4DA 27   1F                 beq    getjo6    empty list?                     *  E4DC A6   04       getjo1    lda    tsstat,x  get status byte  E4DE 81   01                 cmpa   #TRUN     is it in run state?  E4E0 26   1B                 bne    getjo8                     *  E4E2 5D                      tstb             first      in list?  E4E3 27   06                 beq    getjo2                     *  E4E5 EC   84                 ldd    tslink,x  remove from list  E4E7 ED   A4                 std    tslink,y  E4E9 20   07                 bra    getjo4                     *  E4EB 10AE 84       getjo2    ldy    tslink,x  remove from list head  E4EE 10BF 0403               sty    runlst    set new head                     *  E4F2 E6   05       getjo4    ldb    tsprir,x  get priority  E4F4 6F   84                 clr    tslink,x  zero out link  E4F6 6F   01                 clr    tslink+1,x so not run list  E4F8 86   FF                 lda    #$ff      set ne status  E4FA 39                      rts              return                         *  E4FB 4F            getjo6    clra             set        eq status  E4FC 39                      rts                     *  E4FD 1F   12       getjo8    tfr    x,y       save old pos  E4FF AE   84                 ldx    tslink,x  follow link  E501 27   F8                 beq    getjo6                     *  E503 C6   01                 ldb    #1        set flag  E505 20   D5                 bra    getjo1    repeat loop                     FIO Simulation Structure             07:27:51  Jan 07, 2024   Page   46Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       E507 34   01       putrun    pshs   cc        save status  E509                         seti   mask      interrupts  E509 1A   50                 orcc   #FF|IF                               endm  E50B 10BE 0403               ldy    runlst    point to head  E50F 26   0A                 bne    putru2  E511 BF   0403               stx    runlst    set new head                     *  E514 CC   0000     putru1    ldd    #0        set last link  E517 ED   84                 std    tslink,x  E519 35   81                 puls   cc,pc     return                     *  E51B E6   05       putru2    ldb    tsprir,x  get priority  E51D E1   25                 cmpb   tsprir,y  look for correct prior slot  E51F 2F   08                 ble    putru4                     *  E521 FC   0403               ldd    runlst  E524 BF   0403               stx    runlst    set new head  E527 20   0F                 bra    putru5    link in rest                     *  E529 1F   23       putru4    tfr    y,u       save last look  E52B 10AE A4                 ldy    tslink,y  follow link  E52E 27   0C                 beq    putru6                     *  E530 E1   25                 cmpb   tsprir,y  check priority  E532 2F   F5                 ble    putru4                     *  E534 EC   C4                 ldd    tslink,u  link into list here  E536 AF   C4                 stx    tslink,u                     *  E538 ED   84       putru5    std    tslink,x  E53A 35   81                 puls   cc,pc     return                     *  E53C AF   C4       putru6    stx    tslink,u  E53E 20   D4                 bra    putru1    go zero last link                     FIO Simulation Structure             07:27:52  Jan 07, 2024   Page   47Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E540 86   01       makrdy    lda    #TRUN     set status  E542 A7   04                 sta    tsstat,x  E544 CC   0000               ldd    #0        clear events flag  E547 ED   06                 std    tsevnt,x  E549 8D   BC                 bsr    putrun    put on ready list  E54B E6   05                 ldb    tsprir,x  get priority  E54D F1   040B               cmpb   jobpri    higher than current?  E550 2F   03                 ble    makrd6                     *  E552 7C   040C               inc    chproc    set change flag                     *  E555 39            makrd6    rts              return    FIO Simulation Structure             07:27:52  Jan 07, 2024   Page   48Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E556 34   57       wakeup    pshs   cc,d,x,u  save registers  E558                         seti   mask      interupts  E558 1A   50                 orcc   #FF|IF                               endm  E55A CE   0405               ldu    #slplst  E55D AE   42                 ldx    tsslnk,u  point to sleep list  E55F 27   0B                 beq    wakeu4                     *  E561 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E564 27   08                 beq    wakeu5  E566 33   84                 leau   0,x       mark this entry                     *  E568 AE   02       wakeu3    ldx    tsslnk,x  follow chain  E56A 26   F5                 bne    wakeu2    end of list?                     *  E56C 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E56E 34   70       wakeu5    pshs   x,y,u     save registers  E570 EC   02                 ldd    tsslnk,x  remove from list  E572 ED   42                 std    tsslnk,u  E574 8D   CA                 bsr    makrdy    put on ready list  E576 35   70                 puls   u,x,y  E578 20   EE                 bra    wakeu3    repeat                     FIO Simulation Structure             07:27:52  Jan 07, 2024   Page   49Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  E57A 34   51       sleep     pshs   cc,x,u    save registers  E57C BE   0409               ldx    utask     point to task  E57F 6D   08                 tst    tssgnl,x  any signals waiting?  E581 26   1F                 bne    sleep7                     *  E583                         seti   mask      ints  E583 1A   50                 orcc   #FF|IF                               endm  E585 E7   05                 stb    tsprir,x  set priority  E587 10AF 06                 sty    tsevnt,x  set event  E58A 86   02                 lda    #TSLEEP   set status  E58C A7   04                 sta    tsstat,x  E58E FC   0407               ldd    slplst+tsslnk get head of list  E591 ED   02                 std    tsslnk,x  set new link  E593 BF   0407               stx    slplst+tsslnk set new head  E596 17   FF01               lbsr   rsched    reschedule cpu                       E599 BE   0409     20        ldx    utask     get task entry  E59C 6D   08                 tst    tssgnl,x  any signals waiting?  E59E 26   02                 bne    sleep7                     *  E5A0 35   D1                 puls   cc,x,u,pc return                     *  E5A2 BE   0409     sleep7    ldx    utask     reset signal  E5A5 6F   08                 clr    tssgnl,x  E5A7 EC   88 15              ldd    umark1,x  stack reset point  E5AA 35   51                 puls   cc,x,u    reset cc and registers  E5AC 1F   04                 tfr    d,s       change stacks  E5AE 39                      rts              returnFIO Simulation Structure             07:27:52  Jan 07, 2024   Page   50Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  E5AF 34   76       xmtint    pshs   d,x,y,u   save registers  E5B1 A6   04                 lda    tsstat,x  get task state  E5B3 81   01                 cmpa   #TRUN     running?  E5B5 26   06                 bne    10f       no - try something else                     *  E5B7 86   01                 lda    #1        set signal  E5B9 A7   08                 sta    tssgnl,x  E5BB 20   0E                 bra    99f       exit                     *  E5BD 81   02       10        cmpa   #TSLEEP   task sleeping?  E5BF 26   0A                 bne    99f       no - can't send interrupt                     *  E5C1 86   01                 lda    #1        set signal  E5C3 A7   08                 sta    tssgnl,x  E5C5 10AE 06                 ldy    tsevnt,x  wake task up >E5C8 17   FF8B               lbsr   wakeup                     *  E5CB 35   F6       99        puls   d,x,y,u,pc returnFIO Simulation Structure             07:27:52  Jan 07, 2024   Page   51Sleep      and Wakeup routines                                                                *                     * the routines in this file are specific                     * for the W5500 socket device                     * they are called from "wskhan" and "wskdrv" files                     *                     * wzsocket device table                     *  E5CD               DEV_SOCK  E5CD E392                    fdb    bad_cmd   0  E5CF E653                    fdb    skopen    S_OPEN    1 open socket  E5D1 E6CC                    fdb    skclos    S_CLOSE   2 close socket  E5D3 E8C7                    fdb    skreqwr   S_RQWR    3 request write to socket  E5D5 E908                    fdb    sksend    S_SEND    4 write data to socket  E5D7 E85D                    fdb    skreqrd   S_RQRD    5 request read data from socket  E5D9 E8A5                    fdb    skrecv    S_RECV    6 read data from socket  E5DB EB3A                    fdb    skintrp   S_INTRPT  7 interrupt socket  E5DD E719                    fdb    skconn    S_CONNECT 8 connect socket  E5DF E7AF                    fdb    skbind    S_BIND    9 bind socket  E5E1 E7F4                    fdb    sklist    S_LISTEN  10 listen on socket  E5E3 E826                    fdb    skacpt    S_ACCEPT  11 accept connection  E5E5 EB3A                    fdb    skdisc    S_DISCON  12 disconnect socket  E5E7 EB3A                    fdb    sksmac    S_SNDMAC  13 send mac  E5E9 EB3A                    fdb    skskep    S_SNDKEP  14 send keep alive  E5EB EA82                    fdb    skspcl    S_SPCL    15 special command  E5ED E92A                    fdb    skurrdf   S_RRDFRM  16 request read readfrom  E5EF E98F                    fdb    skurrd    S_RREAD   17 read data readfrom  E5F1 E9B9                    fdb    skurwt    S_WRQSTO  18 request write sendto  E5F3 EA4C                    fdb    skusnt    S_WSNDTO  19 write data sendto  E5F5 EA03                    fdb    skusnm    S_WSNDTM  20 write data send more                     *  E5F7 E61A                    fdb    skinthan  16 socket interrupt handler  E5F9 E5FD                    fdb    skinit    17 socket initialization  E5FB E617                    fdb    sktest    18 test device present                     *                     *                     * this file contains all socket handlers                     *                     * when a wzsocket is opened, all locations are effectively                     * cleared to zero, with exception of the enumeration byte                     *                                          *                     * do everything to init the system                     *               E5FD  skinit    equ    *  E5FD BD   EB41               jsr    spinit    set SPI  E600 C6   80                 ldb    #%10000000 software reset  E602 BD   EC11               jsr    PCRMR  E605 BD   EC02     01        jsr    GCRMR  E608 5D                      tstb  E609 2B   FA                 bmi    01bFIO Simulation Structure             07:27:53  Jan 07, 2024   Page   52wz socket interface routines                          E60B C6   78                 ldb    #%01111000 power up  E60D BD   EDEF               jsr    PCRPHY    set the PHY part  E610 CC   8000               ldd    #32768  E613 FD   0457               std    wzanyp    set value for Source port  E616 39                      rts                                          *                     * test if device is present                     *  E617 1A   01       sktest    sec              yes  E619 39                      rts                                          *                     * skinthan, fromddevice table                     *               E61A  skinthan  equ    *  E61A 39                      rts                                          *                     * device signal handle                     *               E61B  sdev_sig  equ    *  E61B 39                      rts                                          *                     * get a new source port                     *  E61C FC   0457     sknewp    ldd    wzanyp    else create one  E61F                         incd  E61F 104C                    fdb    $104c                               endm  E621 1083 FFF0               cmpd   #$FFF0  E625 25   03                 blo    03f  E627 CC   8000               ldd    #$8000  E62A FD   0457     03        std    wzanyp  E62D 39                      rts                                                               *                     * wzdevt, device test, return Z if running, NZ if not                     *  E62E 34   22       wzdevt    pshs   a,y  E630 109E 1A                 ldy    fifo_us1  device info  E633 A6   A8 12              lda    wzdsta,y  E636 81   FF                 cmpa   #$ff      open  E638 35   A2                 puls   a,y,pc                                          *                     * skfres, socket restore info                     *  E63A A6   C4       skfres    lda    wzenum,u  socket #, is remembered  E63C                         trfr   A,EFIO Simulation Structure             07:27:53  Jan 07, 2024   Page   53wz socket interface routines                          E63C 1F                      fcb    $1f  E63D 8E                      fcb    A<<4|E                               endm  E63E 6F   47                 clr    wzerr,u   init result  E640 39                      rts                                          *                     * skctcp, check if in TCP mode                     * return zero if in TCP mode, non-zero if not                     * U = wzsock                     *  E641 34   06       skctcp    pshs   d  E643 EC   C8 26              ldd    wztype,u  SOCK_STREAM  E646 C1   01                 cmpb   #SK_STRM  is TCP  E648 35   86                 puls   d,pc                                          *                     * skcudp, check if in UDP mode                     * return zero if in UDP mode, non-zero if not                     * U = wzsock                     *  E64A 34   06       skcudp    pshs   d  E64C EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E64F C1   02                 cmpb   #SK_DGRM  is UDP  E651 35   86                 puls   d,pc                                          ****************************************************************                     *                     * here the socket is opened                     * X hold the TASK table                     * U holds the sock address                     *               E653  skopen    equ    * >E653 BD   E63A               jsr    skfres                     *                     * check if DEVICE is active                     * >E656 BD   E62E               jsr    wzdevt  E659 27   06                 beq    11f  E65B BD   E6E7               jsr    skclin    NO, close internal and don't start >E65E 16   003D     04        lbra   skoper1                     *                     * retry, we do all things                     *  E661 A6   42       11        lda    wzfsta,u  check if allocated by OS  E663 2A   F9                 bpl    04b       no, do nothing                     *                     * check socket() call arguments                     *  E665 6F   43                 clr    wzflg,u   erase flags  E667 EC   C8 24              ldd    wzfaml,u  E66A C1   02                 cmpb   #AF_INETFIO Simulation Structure             07:27:53  Jan 07, 2024   Page   54wz socket interface routines                          E66C 26   F0                 bne    04b       not supported                     * wztype holds socket type AND socket flags (hibyte)  E66E EC   C8 26              ldd    wztype,u  E671 C1   01                 cmpb   #SK_STRM  SOCK_STREAM  E673 27   10                 beq    01f  E675 C1   02                 cmpb   #SK_DGRM  SOCK_DGRAM  E677 27   08                 beq    21f  E679 C1   03                 cmpb   #SK_RAW   SOCK_RAW  E67B 26   25                 bne    skoper2                     * raw socket  E67D C6   04                 ldb    #%00000100 MACRAW  E67F 20   06                 bra    07f                     * dgram  E681 C6   02       21        ldb    #%00000010 UDP  E683 20   02                 bra    07f                     * TCP socket  E685 C6   01       01        ldb    #%00000001 TCP set source port in connect                     *                     * set socket mode register                     *  E687 BD   EE1C     07        jsr    PSRMR     set socket mode register                     *                     * here do the real OPEN,                     *  E68A C6   01                 ldb    #WCOPEN   open the device  E68C E7   44                 stb    wzcmnd,u  copy command  E68E BD   EE3A               jsr    PSRCR                     *                     * interrupts not expected for 'open'                     *  E691 BD   EE6E     21        jsr    GSRSR     get status  E694 E7   45                 stb    wzstat,u  E696 C1   00                 cmpb   #WSCLSD  E698 27   F7                 beq    21b       wait until updated                     *  E69A 4F                      clra  E69B C6   01                 ldb    #R_OPEN   response  E69D 39            99        rts                     *  E69E 86   01       skoper1   lda    #1        device not initialized  E6A0 20   02                 bra    12f  E6A2 86   02       skoper2   lda    #2        type error  E6A4 C6   C0       12        ldb    #E_SOCKET  E6A6 20   F5                 bra    99b                                          *                     * convert number in bit position                     * B = enum, B=bit                     *  E6A8 34   10       num2bt    pshs   x  E6AA 8E   E6C3               ldx    #bittab  E6AD 3A                      abxFIO Simulation Structure             07:27:54  Jan 07, 2024   Page   55wz socket interface routines                          E6AE E6   84                 ldb    0,x  E6B0 35   90                 puls   x,pc                                          *                     * bit to nummer, offset byt one, entry should NOT be 0                     *  E6B2 34   10       bt2num    pshs   x  E6B4 8E   E6C3               ldx    #bittab  E6B7 6F   E2                 clr    0,-s  E6B9 E1   80       02        cmpb   0,x+  E6BB 27   04                 beq    01f  E6BD 6C   E4                 inc    0,s  E6BF 20   F8                 bra    02b  E6C1 35   94       01        puls   b,x,pc                                          * table  E6C3 00            bittab    fcb    0  E6C4 01 02 04 08             fcb    %00000001,%00000010,%00000100,%00001000  E6C8 10 20 40 80             fcb    %00010000,%00100000,%01000000,%10000000                                          ***************************************************************                     *                     * close the socket                     * X hold the task table                     * U holds the sock address                     *               E6CC  skclos    equ    *  E6CC BD   E63A               jsr    skfres  E6CF C6   08                 ldb    #WCDISC  E6D1 E7   44                 stb    wzcmnd,u  E6D3 BD   EE3A               jsr    PSRCR     send disconnect                     *  E6D6 8D   0F                 bsr    skclin  E6D8                         clrd  E6D8 104F                    fdb    $104f                               endm  E6DA ED   C8 24              std    wzfaml,u  E6DD ED   C8 26              std    wztype,u  E6E0 ED   C8 28              std    wzprot,u                     *  E6E3 4F                      clra  E6E4 C6   02                 ldb    #R_CLOSE  response  E6E6 39                      rts                                          *                     * wzclin, close interal                     *  E6E7 34   06       skclin    pshs   d  E6E9 C6   10                 ldb    #WCCLOS   do close  E6EB E7   44           9∫1;Ω1∂∑2:Üê"õ"¢!""¢ô†ê           jsr    PSRCR                     *FIO Simulation Structure             07:27:54  Jan 07, 2024   Page   56wz socket interface routines                                             * erase registers in device                     *  E6F0 CC   0000               ldd    #0  E6F3 BD   EE8C               jsr    PSRPORT   source port                     *  E6F6 A6   42                 lda    wzfsta,u  E6F8 84   F9                 anda   #!(WZSKIO+WZSKIS) reset io mode and is sending  E6FA A7   42                 sta    wzfsta,u  E6FC CC   0000               ldd    #0  E6FF ED   48                 std    wzxfer,u  clear remaining size                     *  E701 BD   EE6E     91        jsr    GSRSR  E704 E7   45                 stb    wzstat,u  stat = 0 (closed)                     *  E706 CC   0000               ldd    #0  E709 ED   C8 10              std    wzsprt,u  erase old info  E70C ED   C8 14              std    wzipad,u  E70F ED   C8 16              std    wzipad+2,u  E712 ED   C8 12              std    wzdprt,u  E715 E7   43                 stb    wzflg,u   clear flags                     *  E717 35   86                 puls   d,pc                                          ***************************************************************                     *                     * connect socket                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E719  skconn    equ    *  E719 BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E71C BD   E62E               jsr    wzdevt  E71F 27   06                 beq    01f >E721 BD   E6CC               jsr    skclos    NO, don't start >E724 16   007A     02        lbra   skcner4  E727 BD   E641     01        jsr    skctcp    not in tcp, illegal  E72A 26   F8                 bne    02b                     *                     * check if socket has been set up                     *  E72C BD   EE6E     11        jsr    GSRSR     status  E72F E7   45                 stb    wzstat,u  check if properly setup  E731 C1   13                 cmpb   #WSINIT   SHOULD BE >E733 1026 005F               lbne   skcner6                     *                     * check the info from the connect call                     *  E737 EC   C8 14              ldd    wzipad,u  check if dest IP == nullFIO Simulation Structure             07:27:54  Jan 07, 2024   Page   57wz socket interface routines                          E73A                         ordx   wzipad+2,IU  E73A 10AA                    fdb    $10aa  E73C                         doindx wzipad+2,IU  E73C C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm  E73E 27   65                 beq    skcner1   IP address == NULL                     * IP address = 0000  E740 EC   C8 14              ldd    wzipad,u  or FFFFFFFF  E743                         incd  E743 104C                    fdb    $104c                               endm  E745 26   07                 bne    01f  E747 EC   C8 16              ldd    wzipad+2,u  E74A                         incd  E74A 104C                    fdb    $104c                               endm  E74C 27   57                 beq    skcner1   IP address = FFFFFFFF                     *                     * valid IP                     *  E74E EC   C8 12    01        ldd    wzdprt,u  check destination port  E751 27   4A                 beq    skcner5   is not set, error                     *  E753 BD   EF16               jsr    PSRDPOR   set destination port  E756 31   C8 14              leay   wzipad,u  load socket  E759 BD   EEF0               jsr    PSRDIP    set destination IP                     *                     * source port, create one, always unique                     *  E75C BD   E61C               jsr    sknewp    get new  E75F ED   C8 10              std    wzsprt,u  tell us what you took  E762 BD   EE8C               jsr    PSRPORT   source port                     *                     * do the CONNECT here                     *  E765 C6   04                 ldb    #WCCONN  E767 E7   44                 stb    wzcmnd,u  E769 BD   EE3A               jsr    PSRCR     do connect                     *                     *                     *  E76C BD   E63A     conlb1    jsr    skfres  E76F BD   EE6E               jsr    GSRSR     update status  E772 E7   45                 stb    wzstat,u  E774 C1   17                 cmpb   #WSESTB  E776 27   0A                 beq    90f  E778 C1   00                 cmpb   #WSCLSD  E77A 27   16                 beq    skcner2  E77C 108E E76C               ldy    #conlb1  E780 20   04                 bra    polext                     *FIO Simulation Structure             07:27:55  Jan 07, 2024   Page   58wz socket interface routines                          E782 4F            90        clra  E783 C6   08                 ldb    #R_CONNECT  E785 39            99        rts                                          *                     * polexit, Y=where to return                     *  E786 10AF 0F       polext    sty    tsagin,x  here to restart  E789 C6   BA                 ldb    #POLPRI  E78B E7   05                 stb    tsprir,x  E78D 108E FFFF               ldy    #$ffFF  E791 39                      rts                       E792 C6   0C       skcner2   ldb    #R_DISCON  E794 20   EF                 bra    99b                       E796 BD   E6E7     skcner6   jsr    skclin    reset open  E799 86   0F                 lda    #15       not properly setup  E79B 20   0E                 bra    09f  E79D 86   0E       skcner5   lda    #14       destination port not set  E79F 20   0A                 bra    09f  E7A1 86   0A       skcner4   lda    #10       device not initialized  E7A3 20   06                 bra    09f  E7A5 86   0B       skcner1   lda    #11       IP address invalid  E7A7 20   02                 bra    09f  E7A9 86   0D       skcner3   lda    #13  E7AB C6   C0       09        ldb    #E_SOCKET  E7AD 20   D6                 bra    99b                                          ***************************************************************                     *                     * bind request                     * X hold the task table                     * U holds the sock address                     * bindt() call fills in info in the sock structure                     *               E7AF  skbind    equ    *  E7AF BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E7B2 BD   E62E               jsr    wzdevt  E7B5 1026 00E7               lbne   rdrqer1  E7B9 BD   E641               jsr    skctcp    check TCP  E7BC 27   12                 beq    01f  E7BE BD   E64A               jsr    skcudp    check UDP >E7C1 1026 FFD1               lbne   skcner6                     *                     * go on , the bind() call sets wzipad and wzsprt, this is for                     * a server, for a client it needs to set wzdprt                     * for as server IP is local, for a client IP is remote                     *FIO Simulation Structure             07:27:55  Jan 07, 2024   Page   59wz socket interface routines                                             *  E7C5 BD   EE6E               jsr    GSRSR     status  E7C8 E7   45                 stb    wzstat,u  E7CA C1   22                 cmpb   #WSUDP    check  E7CC 27   0D                 beq    03f  E7CE 20   07                 bra    04f                       E7D0 BD   EE6E     01        jsr    GSRSR     status  E7D3 E7   45                 stb    wzstat,u  E7D5 C1   13                 cmpb   #WSINIT   should be >E7D7 1026 FFBB     04        lbne   skcner6                     *                     * set the network connection data                     *  E7DB BD   E61C     03        jsr    sknewp  E7DE ED   C8 12              std    wzdprt,u  E7E1 BD   EF16               jsr    PSRDPOR   destination port  E7E4 EC   C8 10              ldd    wzsprt,u  E7E7 BD   EE8C               jsr    PSRPORT   source port                     *  E7EA 31   C8 14              leay   wzipad,u  E7ED BD   EEF0               jsr    PSRDIP    source IP                     *  E7F0 4F                      clra  E7F1 C6   09                 ldb    #R_BIND  E7F3 39                      rts                     *                                          ***************************************************************                     *                     * listen request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E7F4  sklist    equ    *  E7F4 BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E7F7 BD   E62E               jsr    wzdevt  E7FA 1026 00A2     02        lbne   rdrqer1  E7FE BD   E641               jsr    skctcp  E801 26   F7                 bne    02b                     *                     * go on                     *                     *  E803 BD   EE6E               jsr    GSRSR     status  E806 E7   45                 stb    wzstat,u                     *  E808 C1   00                 cmpb   #WSCLSD   closed?FIO Simulation Structure             07:27:55  Jan 07, 2024   Page   60wz socket interface routines                          E80A 27   0F                 beq    80f  E80C C1   13                 cmpb   #WSINIT   opened  E80E 26   0F                 bne    90f                     *  E810 C6   02                 ldb    #WCLIST  E812 E7   44                 stb    wzcmnd,u  E814 BD   EE3A               jsr    PSRCR                     *  E817 4F                      clra  E818 C6   0A                 ldb    #R_LISTEN  E81A 39                      rts                                          *  E81B 4F            80        clra  E81C C6   02                 ldb    #R_CLOSE  E81E 39                      rts                     *  E81F 108E E7F4     90        ldy    #sklist  E823 7E   E786               jmp    polext                                          ***************************************************************                     *                     * accept request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E826  skacpt    equ   ê"ú!""õ†ê59π9µ≥92πÜêê4πê:42ê""´$°¢ê9∫4∂6ê0±∫4ª2Üêê"úê!""õ"ê59π;Ω22ª:ê"ú!êòò6172ê9298≤πÜê"úò!""õê59π  skctcp  E833 26   F7                 bne    02b       wrong mode                     *                     * go on                     *  E835 BD   EE6E               jsr    GSRSR     status  E838 E7   45                 stb    wzstat,u  E83A C1   17                 cmpb   #WSESTB   connected  E83C 26   10                 bne    01f  E83E BD   EF07               jsr    GSRDPOR   fill in peer port  E841 ED   C8 12              std    wzdprt,u  E844 31   C8 14              leay   wzipad,u  E847 BD   EED9               jsr    GSRDIP                     *  E84A 4F                      clra  E84B C6   0B                 ldb    #R_ACCEPT  E84D 39                      rts                     *FIO Simulation Structure             07:27:56  Jan 07, 2024   Page   61wz socket interface routines                          E84E C1   00       01        cmpb   #WSCLSD  E850 26   04                 bne    02f  E852 4F                      clra  E853 C6   02                 ldb    #R_CLOSE  E855 39                      rts                     *  E856 108E E826     02        ldy    #skacpt  E85A 7E   E786               jmp    polext                                                               ***************************************************************                     *                     * read request  TCP only !!                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E85D  skreqrd   equ    *  E85D BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E860 BD   E62E               jsr    wzdevt >E863 1026 0039     02        lbne   rdrqer1  E867 BD   E641               jsr    skctcp    check TCP  E86A 26   F7                 bne    02b                     *                     * go on                     *                     *  E86C BD   EE6E               jsr    GSRSR  E86F E7   45                 stb    wzstat,u  update status  E871 BD   F007               jsr    GSRRXRS   data available?  E874 ED   48                 std    wzxfer,u  E876 26   20                 bne    70f                     *  E878 A6   C8 26              lda    wztype,u  check flags  E87B 85   01                 bita   #WFNBLK   non block  E87D 26   15                 bne    75f                     *  E87F E6   45                 ldb    wzstat,u  E881 C1   17       17        cmpb   #WSESTB   still active  E883 27   08                 beq    20f                       E885 C1   1C                 cmpb   #WSCLWT  E887 27   13                 beq    60f  E889 C1   00                 cmpb   #WSCLSD  E88B 27   0F                 beq    60f                     *  E88D 108E E85D     20        ldy    #skreqrd  E891 7E   E786               jmp    polext                     FIO Simulation Structure             07:27:56  Jan 07, 2024   Page   62wz socket interface routines                                             *************************  E894 4F            75        clra  E895 C6   15                 ldb    #R_RQRDNB tell no data  E897 39                      rts                                          * data present  E898 4F            70        clra  E899 C6   05                 ldb    #R_RQRD  E89B 39                      rts                                          * close socket and return  E89C 4F            60        clra  E89D C6   02                 ldb    #R_CLOSE  E89F 39                      rts                                            E8A0 86   82       rdrqer1   lda    #130  E8A2 C6   C0                 ldb    #E_SOCKET  E8A4 39                      rts                                          ***************************************************************                     *                     * get the data  U=wzsock                     *               E8A5  skrecv    equ    *  E8A5 BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E8A8 BD   E62E               jsr    wzdevt >E8AB 1026 FFF1               lbne   rdrqer1  E8AF BD   E641     02        jsr    skctcp  E8B2 26   FB                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E8B4 BD   F007               jsr    GSRRXRS   received size                     * D total aviable data  E8B7 BD   F0D7               jsr    RDSK2FB   transfer datat to fifo  E8BA ED   48                 std    wzxfer,u  save it  E8BC C6   40                 ldb    #WCRECV  E8BE E7   44                 stb    wzcmnd,u  E8C0 BD   EE3A               jsr    PSRCR     tell sender we took it                       E8C3 C6   06                 ldb    #R_READ   tell data in fifo  E8C5 4F                      clra  E8C6 39                      rts                                          ***************************************************************                     *FIO Simulation Structure             07:27:56  Jan 07, 2024   Page   63wz socket interface routines                                             * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E8C7  skreqwr   equ    *  E8C7 BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E8CA BD   E62E               jsr    wzdevt >E8CD 1026 FFCF     02        lbne   rdrqer1  E8D1 BD   E641               jsr    skctcp  E8D4 26   F7                 bne    02b                     *                     * go on                     *                     *  E8D6 BD   EE6E               jsr    GSRSR  E8D9 E7   45                 stb    wzstat,u  update status  E8DB BD   EFBB               jsr    GSRTXFR   free size (remaining)  E8DE 10A3 4A                 cmpd   wzrqln,u  would it fit  E8E1 24   15                 bhs    70f                     *  E8E3 E6   45       10        ldb    wzstat,u  E8E5 C1   17                 cmpb   #WSESTB  E8E7 27   18                 beq    20f  E8E9 C1   1C                 cmpb   #WSCLWT  E8EB 27   11                 beq    60f  E8ED C1   00                 cmpb   #WSCLSD  E8EF 26   10                 bne    20f  E8F1 CC   0000               ldd    #0  E8F4 ED   48                 std    wzxfer,u  E8F6 20   06                 bra    60f                     * data space  E8F8 4F            70        clra  E8F9 C6   03                 ldb    #R_RQWR  E8FB 39                      rts                                          * data space exhausted, would block  E8FC 4F            72        clra                     **        ldb     #R_RQWRWB  E8FD 39                      rts                                          * close socket and return  E8FE C6   02       60        ldb    #R_CLOSE  E900 39                      rts                                          *  E901 108E E8C7     20        ldy    #skreqwr  E905 7E   E786               jmp    polext                     FIO Simulation Structure             07:27:57  Jan 07, 2024   Page   64wz socket interface routines                                             ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E908  sksend    equ    *  E908 BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E90B BD   E62E               jsr    wzdevt >E90E 1026 FF8E     02        lbne   rdrqer1  E912 BD   E641               jsr    skctcp  E915 26   F7                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E917 BD   EFBB               jsr    GSRTXFR   free size (remaining)                     * D = total available space  E91A BD   F126               jsr    WRFB2SK   transfer from fifo to socket  E91D ED   48                 std    wzxfer,u  save it  E91F C6   20                 ldb    #WCSEND  E921 E7   44                 stb    wzcmnd,u  E923 BD   EE3A               jsr    PSRCR     tell sender it is coming                       E926 C6   04                 ldb    #R_WRITE  tell data in fifo  E928 4F                      clra  E929 39                      rts                                          ***************************************************************                     * skurrdf, request readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               E92A  skurrdf   equ    *  E92A BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E92D BD   E62E               jsr    wzdevt  E930 1026 FF6C     02        lbne   rdrqer1  E934 BD   E64A               jsr    skcudp  E937 26   F7                 bne    02b                     *                     * go on                     *FIO Simulation Structure             07:27:57  Jan 07, 2024   Page   65wz socket interface routines                                             *  E939 EC   C8 20              ldd    wzurms,u  check remaining size  E93C 26   43                 bne    84f                     *                     * no  packet data present, wait for it                     *  E93E BD   EE6E               jsr    GSRSR  E941 E7   45                 stb    wzstat,u  update status  E943 BD   F007               jsr    GSRRXRS   data available?  E946 ED   7E                 std    -2,s      test D  E948 26   15                 bne    22f       keep waiting                     * no data yet, check socket state  E94A E6   45                 ldb    wzstat,u  E94C C1   22                 cmpb   #WSUDP    still active  E94E 27   08                 beq    20f                       E950 C1   1C                 cmpb   #WSCLWT  E952 27   31                 beq    60f  E954 C1   00                 cmpb   #WSCLSD  E956 27   2D                 beq    60f                     *       ldd     wzsprt,u                     *       jsr     PSRPORT         set source port                     *  E958 108E E92A     20        ldy    #skurrdf  E95C 7E   E786               jmp    polext                     *                     * first data present, set wzuipa, wzuprt, wzurms                     *  E95F 31   C8 1A    22        leay   wzuipa,u  E962 CC   0008               ldd    #8        size of header  E965 BD   EB99               jsr    bmread    copy data                     *                     * move pointer                     *  E968 BD   F01E               jsr    GSRRXRP  E96B C3   0008               addd   #8  E96E BD   F02D               jsr    PSRRXRP   update pointer  E971 C6   40                 ldb    #WCRECV  E973 E7   44                 stb    wzcmnd,u  process move  E975 BD   EE3A               jsr    PSRCR                     *  E978 EC   C8 20              ldd    wzurms,u  E97B 1083 05C0               cmpd   #MAX_UDP  max size  E97F 22   08                 bhi    78f                     *  E981 4F            84        clra  E982 C6   21                 ldb    #R_RDFRM  E984 39                      rts                                          * close socket and return  E985 4F            60        clra  E986 C6   02                 ldb    #R_CLOSEFIO Simulation Structure             07:27:57  Jan 07, 2024   Page   66wz socket interface routines                          E988 39                      rts                                          *  E989 BD   E6E7     78        jsr    skclin    close  E98C C6   C0                 ldb    #E_SOCKET  E98E 39                      rts                                          ***************************************************************                     * skurrd,  data readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               E98F  skurrd    equ    *  E98F BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E992 BD   E62E               jsr    wzdevt  E995 1026 FF07     02        lbne   rdrqer1  E999 BD   E64A               jsr    skcudp  E99C 26   F7                 bne    02b                     *                     * go on                     *                     *                     * transfer at most fio_fsz bytes  E99E EC   C8 20              ldd    wzurms,u  this is leading count                     * D = total available data  E9A1 BD   F0D7               jsr    RDSK2FB   transfer data  E9A4 34   06                 pshs   d         xferred count  E9A6 EC   C8 20              ldd    wzurms,u  update  E9A9 A3   E1                 subd   0,s++  E9AB ED   C8 20              std    wzurms,u  new remaining                     *  E9AE C6   40       01        ldb    #WCRECV  E9B0 E7   44                 stb    wzcmnd,u  set processed  E9B2 BD   EE3A               jsr    PSRCR                     *  E9B5 4F                      clra  E9B6 C6   22                 ldb    #R_RRDFD  E9B8 39                      rts                                          ***************************************************************                     * skurwt,  request sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               E9B9  skurwt    equ    *FIO Simulation Structure             07:27:57  Jan 07, 2024   Page   67wz socket interface routines                          E9B9 BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E9BC BD   E62E               jsr    wzdevt  E9BF 1026 FEDD     02        lbne   rdrqer1  E9C3 BD   E64A               jsr    skcudp  E9C6 26   F7                 bne    02b                     *                     * go on                     *                     *  E9C8 EC   C8 12              ldd    wzdprt,u  check illegal port >E9CB 1027 0077               lbeq   78f                     *  E9CF EC   C8 14              ldd    wzipad,u  E9D2                         ordx   wzipad+2,IU  E9D2 10AA                    fdb    $10aa  E9D4                         doindx wzipad+2,IU  E9D4 C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm >E9D6 1027 006C               lbeq   78f                     * set network registers  E9DA EC   C8 12              ldd    wzdprt,u  E9DD BD   EF16               jsr    PSRDPOR                       E9E0 31   C8 14              leay   wzipad,u  E9E3 BD   EEF0               jsr    PSRDIP  E9E6 EC   C8 10              ldd    wzsprt,u  E9E9 26   11                 bne    04f                     *  E9EB EC   C8 10              ldd    wzsprt,u  already set?  E9EE 26   09                 bne    16f  E9F0 BD   E61C               jsr    sknewp    get new source port  E9F3 ED   C8 10              std    wzsprt,u  E9F6 ED   C8 1E              std    wzuprt,u  set also return port  E9F9 BD   EE8C     16        jsr    PSRPORT                     *  E9FC 108E EA03     04        ldy    #skuwr2   do remainder  EA00 7E   E786               jmp    polext                                          *                     * after intial setup. loop here                     *               EA03  skusnm    equ    *  EA03 BD   E63A     skuwr2    jsr    skfres    set socket base  EA06 BD   E62E               jsr    wzdevt    devie active >EA09 1026 FFB2               lbne   02b       no  EA0D BD   E64A               jsr    skcudp    check open method  EA10 26   AD                 bne    02b                     *FIO Simulation Structure             07:27:58  Jan 07, 2024   Page   68wz socket interface routines                          EA12 BD   EE6E               jsr    GSRSR  EA15 E7   45                 stb    wzstat,u  update status  EA17 BD   EFBB               jsr    GSRTXFR   free size  EA1A 10A3 C8 20              cmpd   wzurms,u  EA1E 24   15                 bhs    10f                     * no space yet  EA20 E6   45                 ldb    wzstat,u  EA22 C1   22                 cmpb   #WSUDP  EA24 27   08                 beq    20f                       EA26 C1   1C                 cmpb   #WSCLWT   is closing  EA28 27   18                 beq    60f  EA2A C1   00                 cmpb   #WSCLSD   closed  EA2C 27   14                 beq    60f                     *  EA2E 108E E9B9     20        ldy    #skurwt  EA32 7E   E786               jmp    polext    keep polling                     *  EA35 EC   C8 20    10        ldd    wzurms,u  EA38 1083 05C0               cmpd   #MAX_UDP  too big  EA3C 22   08                 bhi    78f                     *  EA3E 4F                      clra  EA3F C6   23                 ldb    #R_RSNDTO  EA41 39                      rts                       EA42 4F            60        clra  EA43 C6   02                 ldb    #R_CLOSE  EA45 39                      rts                       EA46 BD   E6E7     78        jsr    skclin    close  EA49 C6   C0                 ldb    #E_SOCKET  EA4B 39                      rts                                                               ***************************************************************                     * skusnt,  data sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA4C  skusnt    equ    *  EA4C BD   E63A               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EA4F BD   E62E               jsr    wzdevt  EA52 1026 FE4A     02        lbne   rdrqer1  EA56 BD   E64A               jsr    skcudp  EA59 26   F7                 bne    02b                     *FIO Simulation Structure             07:27:58  Jan 07, 2024   Page   69wz socket interface routines                                             * go on                     *                     * transfer fifo to socket data register  EA5B EC   C8 20              ldd    wzurms,u  total data                     *  EA5E BD   F126               jsr    WRFB2SK   fifo to socket  EA61 34   06                 pshs   d  EA63 EC   C8 20              ldd    wzurms,u  all loaded  EA66 A3   E1                 subd   0,s++  EA68 ED   C8 20              std    wzurms,u  EA6B 26   11                 bne    01f                       EA6D EC   C8 22              ldd    wzuwrp,u  is it used  EA70 BD   EFF8               jsr    PSRTXWP   set write pointer                       EA73 C6   20                 ldb    #WCSEND  EA75 E7   44                 stb    wzcmnd,u  EA77 BD   EE3A               jsr    PSRCR  EA7A 4F                      clra  EA7B C6   24                 ldb    #R_WSNDTO data taken  EA7D 39                      rts                       EA7E 4F            01        clra  EA7F C6   25                 ldb    #R_SNDTOM ask for more  EA81 39                      rts                                          ***************************************************************                     *                     * special function, tstval,x is indicator                     * X hold the task table                     * U holds the SPECIAL sock address (NO wz....  access!)                     *               EA82  skspcl    equ    *                     *  EA82 34   10                 pshs   x  EA84 E6   0C                 ldb    tstval,x  get index  EA86 C1   04                 cmpb   #MAXTBL  EA88 22   18                 bhi    01f       illegal  EA8A 58                      aslb  EA8B 8E   EAA9               ldx    #functb  EA8E 10AE 85                 ldy    b,x       get special function  EA91 27   0F                 beq    01f       not valid  EA93 35   10                 puls   x                     *  EA95 AD   A4                 jsr    0,y       do function  EA97 26   05                 bne    90f                     *  EA99 4F                      clra  EA9A C6   0F                 ldb    #R_SPCL  EA9C 20   0A                 bra    99f                     *  EA9E 86   A2       90        lda    #162FIO Simulation Structure             07:27:58  Jan 07, 2024   Page   70wz socket interface routines                          EAA0 20   04                 bra    02f                     *  EAA2 35   10       01        puls   x  EAA4 86   A1                 lda    #161  EAA6               02  EAA6 C6   C0                 ldb    #E_SOCKET                     *  EAA8 39            99        rts                       EAA9 EAB1          functb    fdb    wzdev     set device settings  EAAB EAB1                    fdb    wzdev  EAAD EADB                    fdb    showrg  EAAF 0000                    fdb    0               0004  MAXTBL    equ    (*-functb)/2                                                               *                     * X hold the task table                     * U holds the special sock address                     *  EAB1               wzdev  EAB1 C6   08                 ldb    #8  EAB3                         trfr   B,E  EAB3 1F                      fcb    $1f  EAB4 9E           31±!>"Üê2∑26Üê"†°ê""ê†ê62:ê34≥7Ø∫πòê22ª4±≤ê4∑37ê0π2∞Üê"†°êòê!ö62∞ºê:ê6º¥∏ê"†°ê!""°¢ê59π(!©)§®9∑∫π1≤ê$®ê"†°!êòê62∞ºê:Üê"†°"ê!""°õê59π(!©)ß&ê9∫±72∫6∞πµÜê"†°òêòê62∞ºê:Üê"†°ôê!""°ôõê59π(!©#†ê3∞∫2ª∞ºê$P  EAC6 31   4C                 leay   12,u  EAC8 BD   EC9B               jsr    PCRSHA    hardware address  EACB A6   C8 12              lda    18,u      ON/OFF  EACE 27   04                 beq    01f  EAD0 C6   F8                 ldb    #%11111000 all on  EAD2 20   02                 bra    02f  EAD4 C6   78       01        ldb    #%01111000 all off  EAD6 BD   EDEF     02        jsr    PCRPHY  EAD9 4F                      clra  EADA 39                      rts                                          *                     *                     *  EADB               showrg  EADB C6   08                 ldb    #8  EADD                         trfr   B,E       select first socket  EADD 1F                      fcb    $1f  EADE 9E                      fcb    B<<4|EFIO Simulation Structure             07:27:59  Jan 07, 2024   Page   71wz socket interface routines                                                       endm  EADF DE   1A                 ldu    fifo_us1  EAE1 33   C8 20              leau   32,u      skip network data area  EAE4 BD   EE0D               jsr    GSRMR  EAE7 E7   C0                 stb    0,u+  EAE9 BD   EE6E               jsr    GSRSR  EAEC E7   C0                 stb    0,u+  EAEE BD   EF7F               jsr    GSRRBFS  EAF1 E7   C0                 stb    0,u+                       EAF3 C6   3D                 ldb    #'=  EAF5 E7   C0                 stb    0,u+                       EAF7 BD   EE7D               jsr    GSRPORT  EAFA ED   C1                 std    0,u++  EAFC BD   EF07               jsr    GSRDPOR  EAFF ED   C1                 std    0,u++                       EB01 C6   23                 ldb    #'#  EB03 E7   C0                 stb    0,u+                       EB05 31   C4                 leay   0,u  EB07 BD   EE9B               jsr    GSRDHAR  EB0A 33   46                 leau   6,u                       EB0C C6   23                 ldb    #'#  EB0E E7   C0                 stb    0,u+                       EB10 31   C4                 leay   0,u  EB12 BD   EED9               jsr    GSRDIP  EB15 33   44                 leau   4,u                       EB17 C6   3D                 ldb    #'=  EB19 E7   C0                 stb    0,u+                       EB1B BD   EF25               jsr    GSRMSS  EB1E ED   C1                 std    0,u++  EB20 BD   F007               jsr    GSRRXRS  EB23 ED   C1                 std    0,u++  EB25 BD   F01E               jsr    GSRRXRP  EB28 ED   C1                 std    0,u++  EB2A BD   F03C               jsr    GSRRXWP  EB2D ED   C1                 std    0,u++  EB2F BD   F071               jsr    GSRFRAG  EB32 ED   C1                 std    0,u++                       EB34 C6   23                 ldb    #'#  EB36 E7   C4                 stb    0,u  EB38 4F                      clra                       EB39 39                      rts                     FIO Simulation Structure             07:27:59  Jan 07, 2024   Page   72wz socket interface routines                                                                  * X hold the task table                     * U holds the sock address  EB3A               skintrp  EB3A               skdisc  EB3A               sksmac  EB3A               skskep  EB3A 86   FF                 lda    #255  EB3C A7   47                 sta    wzerr,u  EB3E C6   C0                 ldb    #E_SOCKET  EB40 39                      rts                                    EB41  oldorg    set    *                     *                     * hardware register orgaization                     *               8080  SPIBASE   equ    $8080     hardware base address                       0000                         org    0                     *  0000               spicmd    rmb    1         HW control register               0000  spista    equ    spicmd    HW status register  0001               spicon    rmb    1         [W]   HW aux control register  0002                         rmb    2         dummy not used                     * shift register access  0004               hibyta    rmb    1         [R/W] hibyte auto 8 clock pulses for SR  0005               lobyta    rmb    1         [R/W] lobyte auto 8 clock pulses for SR  0006               hibyts    rmb    1         [R/W] hibyte static (no clock)  0007               lobyts    rmb    1         [R/W] lobyte static (no clock)                     *               0080  QFF1      equ    %10000000 [R]                          X               0040  SPI_CS_   equ    %01000000 [R/W] spi chip CS_           1               0020  SPI_RST   equ    %00100000 [R/W] spi chip RST_          1               0010  SPI_IEN   equ    %00010000 [R/W] spi chip INT enabled   0               0008  SPI_AUT   equ    %00001000 [R/W] auto advance           0               0004  SPI_SR_   equ    %00000100 [R/W] shift register MR_     1               0002  SPI_HLD   equ    %00000010 [R/W] HOLD                   0               0001  SPI_CR_   equ    %00000001 [W]   HC163 MR_              1               0001  SPI_IRQ   equ    %00000001 [R]   /IRQ bit               1                     *               0003  RSVREG    equ    %00000011 reserved register address                       EB41                         org    oldorg                                          *                     * spinit, init the SPI hardware                     *               EB41  spinit    equ    *  EB41 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_ set idle  EB43 B7   8080               sta    SPIBASE+spicmd  EB46 39                      rts                     FIO Simulation Structure             07:27:59  Jan 07, 2024   Page   73wzspi, basic spi routines                                                *                     * setup inital port for SPI access                     *                     * A,B are lost A=rwflag, F=register, X=offset                     * F=corrected register bits [7...3]                     * A= R/W flag 1=write/ 0= read                     * X,Y untouched                     *               EB47  spistr2   equ    *  EB47 CE   8080               ldu    #SPIBASE  SPI base TODO  EB4A                         trfr   F,B  EB4A 1F                      fcb    $1f  EB4B F9                      fcb    F<<4|B                               endm  EB4C 5D                      tstb             register pointer  EB4D 27   09                 beq    01f       OK, valid  EB4F 34   04                 pshs   b  EB51 C4   03                 andb   #RSVREG   reserved loctation  EB53 5D                      tstb             xxx10xxx  is invalid!  EB54 35   04                 puls   b  EB56 27   1A                 beq    09f       invalid access                     * adjust READ/WRITE bit  EB58 4D            01        tsta             cmd flag  EB59 27   04                 beq    04f  EB5B 1A   01                 sec              write   100  EB5D 20   02                 bra    05f  EB5F 1C   FE       04        clc              read    000                     *  EB61 59            05        rolb             set READ/WRITE bit  [2...0]  EB62 58                      lslb             set variable length data [00]  EB63 58                      lslb                     *                     * here the actual SPI action starts                     *  EB64                         seti   disable   interrupts  EB64 1A   50                 orcc   #FF|IF                               endm  EB66 12                      nop                     *       lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT+SPI_IEN low  EB67 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT low  EB69 A7   C4                 sta    spicmd,u  EB6B AF   44                 stx    hibyta,u  and shift out  EB6D E7   44                 stb    hibyta,u  and shift out  EB6F 1A   04                 sez  EB71 39                      rts  EB72 1C   FB       09        clz  EB74 39                      rts                                          *                     * X = offset, unchanged                     * F = register#                     * read BYTE from SPIFIO Simulation Structure             07:28:00  Jan 07, 2024   Page   74;Ω9∏4ñ10π¥±ê9∏4ê97∫∫4∑2πêÜÜê92∫:π7!ª0∂:≤ñ",,ñ*ê892π≤π;2≤êê"°öê1<∫2π22∏∫êê"°öêöê89¥9ê1±ñ2:Üê"°õê#1∂90Üê"°ú"!¢19π9∏4π∫9ê"°†êò¢ê6172ê 09f  EB7E E6   44                 ldb    hibyta,u  extra clocks for first data                     *  EB80 E6   45                 ldb    lobyta,u  read byte  EB82 4F                      clra  EB83 ED   61                 std    1,s  EB85 20   69                 bra    sprend                                          *                     * X = offset                     * F = register#                     * read WORD from SPI                     * return D=value,  D,X,Y,U preserved                     *               EB87  wordrd    equ    *  EB87 34   47                 pshs   cc,d,u  EB89 4F                      clra >EB8A BD   EB47               jsr    spistr2  EB8D 26   6D                 bne    09f  EB8F E6   44                 ldb    hibyta,u  extra clocks for first data                     *  EB91 A6   45                 lda    lobyta,u  read byte  EB93 E6   45                 ldb    lobyta,u  read byte  EB95 ED   61                 std    1,s  EB97 20   57                 bra    sprend                                          *                     * Y=mem pointer, D=count (bytes)                     * F = register#                     * read bytes from SPI into memory location                     * return D,X,Y,U preserved                     *               EB99  bmread    equ    *  EB99 34   77                 pshs   cc,d,x,y,u  EB9B 4F                      clra  EB9C BD   F01E               jsr    GSRRXRP  EB9F 1F   01                 tfr    d,x  EBA1 CE   8080               ldu    #SPIBASE  EBA4 34   40                 pshs   u  EBA6 1A   50                 orcc   #$50  EBA8 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT  EBAA A7   C4                 sta    spicmd,u  EBAC AF   44                 stx    hibyta,u  start address  EBAE BD   F0C8               jsr    tsk2rx  EBB1 E7   44                 stb    hibyta,u  EBB3 EC   63                 ldd    3,s       old DFIO Simulation Structure             07:28:00  Jan 07, 2024   Page   75wzspi, basic spi routines                             EBB5                         trfr   D,W       count  EBB5 1F                      fcb    $1f  EBB6 06                      fcb    D<<4|W                               endm  EBB7 1F   12                 tfr    x,y       mem pointer  EBB9 10AE 67                 ldy    7,s       old Y  EBBC E7   44                 stb    hibyta,u  shift out  EBBE 33   45                 leau   lobyta,u  EBC0                         tfm4   U,Y  EBC0 113B                    fdb    $113b  EBC2 32                      fcb    U<<4|Y                               endm  EBC3 35   40                 puls   u         old U  EBC5 86   25                 lda    #SPI_RST+SPI_SR_+SPI_CR_  EBC7 A7   C4                 sta    spicmd,u                     * X = old read pointer, 0,s byte wount  EBC9 1F   10                 tfr    x,d  EBCB E3   61                 addd   1,s       move pointer  EBCD BD   F02D               jsr    PSRRXRP   update pointer  EBD0 35   F7                 puls   cc,d,x,y,u,pc                                          *                     * X = offset                     * F = register#                     * write BYTE to SPI, D,X,Y,U preserved                     *               EBD2  bytewr    equ    *  EBD2 34   47                 pshs   cc,d,u  EBD4 86   01                 lda    #1  EBD6 BD   EB47               jsr    spistr2  EBD9 26   21                 bne    09f                     *  EBDB A6   62                 lda    2,s  EBDD A7   44                 sta    hibyta,u  EBDF 20   0F                 bra    sprend                                          *                     * X = offset                     * F = register#                     * write WORD to SPI, D,X,Y,U preserved                     *               EBE1  wordwr    equ    *  EBE1 34   47                 pshs   cc,d,u  EBE3 86   01                 lda    #1  EBE5 BD   EB47               jsr    spistr2  EBE8 26   12                 bne    09f                     *  EBEA EC   61                 ldd    1,s  EBEC A7   44                 sta    hibyta,u  EBEE E7   44                 stb    hibyta,u                     *                     * common exit from SPI actionFIO Simulation Structure             07:28:00  Jan 07, 2024   Page   76wzspi, basic spi routines                                                *  EBF0 86   65       sprend    lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_                     *sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_+SPI_IEN  EBF2 A7   C4                 sta    spicmd,u  EBF4 A6   E4                 lda    0,s       sez  EBF6 8A   04                 ora    #4  EBF8 A7   E4       02        sta    0,s  EBFA 35   C7                 puls   cc,d,u,pc                     *  EBFC A6   E4       09        lda    0,s       clz  EBFE 84   FB                 anda   #255-4  EC00 20   F6                 bra    02b                     FIO Simulation Structure             07:28:01  Jan 07, 2024   Page   77wzspi, basic spi routines                                                                     * register names and offset               0000  WZMR      equ    0               0001  WZGAR0    equ    1               0002  WZGAR1    equ    2               0003  WZGAR2    equ    3               0004  WZGAR3    equ    4               0005  WZSUBR0   equ    5               0006  WZSUBR1   equ    6               0007  WZSUBR2   equ    7               0008  WZSUBR3   equ    8               0009  WZSHAR0   equ    9               000A  WZSHAR1   equ    10               000B  WZSHAR2   equ    11               000C  WZSHAR3   equ    12               000D  WZSHAR4   equ    13               000E  WZSHAR5   equ    14               000F  WZSIPR0   equ    15               0010  WZSIPR1   equ    16         òê+≠)§®)2∏∫êõÜêô+≠)§®)ê2∏∫êúêôê+≠$¶&*2∏∫êúÜêö+≠$¶&*ê2∏∫êêöê+≠$©2∏∫êÜê          0016  WZIMR     equ    22               0017  WZSIR     equ    23               0018  WZSIMR    equ    24               0019  WZRTR0    equ    25               001A  WZRTR1    equ    26               001B  WZRCR     equ    27               0028  WZUIPR0   equ    40               0029  WZUIPR1   equ    41               002A  WZUIPR2   equ    42               002B  WZUIPR3   equ    43               002C  WZUPRT0   equ    44               002D  WZUPRT1   equ    45               002E  WZPHY     equ    46               0039  WZVERS    equ    57                                          *                     * all commands to access common register set                     *                                          *                     * GCRMR, get byte from common registers mode register                     * return byte in B                     *  EC02 34   56       GCRMR     pshs   d,x,u  EC04 5F                      clrb  EC05                         trfr   B,F  EC05 1F                      fcb    $1f  EC06 9F                      fcb    B<<4|FFIO Simulation Structure             07:28:01  Jan 07, 2024   Page   78wzspi, basic spi routines                                                          endm  EC07 8E   0000               ldx    #WZMR  EC0A BD   EB75               jsr    byterd  EC0D ED   E4                 std    0,s  EC0F 35   D6                 puls   d,x,u,pc                                          *                     * PCRMR, put byte B into common registers mode register                     *  EC11 34   16       PCRMR     pshs   d,x  EC13 5F                      clrb  EC14                         trfr   B,F  EC14 1F                      fcb    $1f  EC15 9F                      fcb    B<<4|F                               endm  EC16 8E   0000               ldx    #WZMR  EC19 EC   E4                 ldd    0,s >EC1B BD   EBD2               jsr    bytewr  EC1E 35   96                 puls   d,x,pc                                          *                     * GCRGA, get gateway address from common regsiters                     * Y=destination address (4 bytes)                     *  EC20 34   16       GCRGA     pshs   d,x  EC22 5F                      clrb  EC23                         trfr   B,F  EC23 1F                      fcb    $1f  EC24 9F                      fcb    B<<4|F                               endm  EC25 8E   0001               ldx    #WZGAR0  EC28 BD   EB87               jsr    wordrd  EC2B ED   A4                 std    0,y  EC2D 8E   0003               ldx    #WZGAR2  EC30 BD   EB87               jsr    wordrd  EC33 ED   22                 std    2,y  EC35 35   96                 puls   d,x,pc                                          *                     * PCRGW, put gateway address                     * Y=source address (4 bytes)                     *  EC37 34   16       PCRGA     pshs   d,x  EC39 5F                      clrb  EC3A                         trfr   B,F  EC3A 1F                      fcb    $1f  EC3B 9F                      fcb    B<<4|F                               endm  EC3C 8E   0001               ldx    #WZGAR0  EC3F EC   A4                 ldd    0,y >EC41 BD   EBE1               jsr    wordwr  EC44 8E   0003               ldx    #WZGAR2FIO Simulation Structure             07:28:01  Jan 07, 2024   Page   79wzspi, basic spi routines                             EC47 EC   22                 ldd    2,y >EC49 BD   EBE1               jsr    wordwr  EC4C 35   96                 puls   d,x,pc                                          *                     * GCRSNM, get subnet mask  from common regsiters                     * Y=destination address (4 bytes)                     *  EC4E 34   16       GCRSNM    pshs   d,x  EC50 5F                      clrb  EC51                         trfr   B,F  EC51 1F                      fcb    $1f  EC52 9F                      fcb    B<<4|F                               endm  EC53 8E   0005               ldx    #WZSUBR0  EC56 BD   EB87               jsr    wordrd  EC59 ED   A4                 std    0,y  EC5B 8E   0007               ldx    #WZSUBR2  EC5E BD   EB87               jsr    wordrd  EC61 ED   22                 std    2,y  EC63 35   96                 puls   d,x,pc                                          *                     * PCRSNM, put subnet mask address                     * Y=source address (4 bytes)                     *  EC65 34   16       PCRSNM    pshs   d,x  EC67 5F                      clrb  EC68                         trfr   B,F  EC68 1F                      fcb    $1f  EC69 9F                      fcb    B<<4|F                               endm  EC6A 8E   0005               ldx    #WZSUBR0  EC6D EC   A4                 ldd    0,y  EC6F BD   EBE1               jsr    wordwr  EC72 8E   0007               ldx    #WZSUBR2  EC75 EC   22                 ldd    2,y  EC77 BD   EBE1               jsr    wordwr  EC7A 35   96                 puls   d,x,pc                                          *                     * GCRSHA, get gateway hardware address from common regsiters                     * Y=destination address (6 bytes)                     *  EC7C 34   16       GCRSHA    pshs   d,x  EC7E 5F                      clrb  EC7F                         trfr   B,F  EC7F 1F                      fcb    $1f  EC80 9F                      fcb    B<<4|F                               endm  EC81 8E   0009               ldx    #WZSHAR0  EC84 BD   EB87               jsr    wordrdFIO Simulation Structure             07:28:01  Jan 07, 2024   Page   80wzspi, basic spi routines                             EC87 ED   A4                 std    0,y  EC89 8E   000B               ldx    #WZSHAR2  EC8C BD   EB87               jsr    wordrd  EC8F ED   22                 std    2,y  EC91 8E   000D               ldx    #WZSHAR4  EC94 BD   EB87               jsr    wordrd  EC97 ED   24                 std    4,y  EC99 35   96                 puls   d,x,pc                                          *                     * PCRSHA, put gateway hardware address                     * Y=source address (6 bytes)                     *  EC9B 34   16       PCRSHA    pshs   d,x  EC9D 5F                      clrb  EC9E                         trfr   B,F  EC9E 1F                      fcb    $1f  EC9F 9F                      fcb    B<<4|F                               endm  ECA0 8E   0009               ldx    #WZSHAR0  ECA3 EC   A4                 ldd    0,y  ECA5 BD   EBE1               jsr    wordwr  ECA8 8E   000B               ldx    #WZSHAR2  ECAB EC   22                 ldd    2,y  ECAD BD   EBE1               jsr    wordwr  ECB0 8E   000D               ldx    #WZSHAR4  ECB3 EC   24                 ldd    4,y  ECB5 BD   EBE1               jsr    wordwr  ECB8 35   96                 puls   d,x,pc                                          *                     * GCRSIP, get source IP address from common regsiters                     * Y=destination address (4 bytes)                     *  ECBA 34   16       GCRSIP    pshs   d,x  ECBC 5F                      clrb  ECBD                         trfr   B,F  ECBD 1F                      fcb    $1f  ECBE 9F                      fcb    B<<4|F                               endm  ECBF 8E   000F               ldx    #WZSIPR0  ECC2 BD   EB87               jsr    wordrd  ECC5 ED   A4                 std    0,y  ECC7 8E   0011               ldx    #WZSIPR2  ECCA BD   EB87               jsr    wordrd  ECCD ED   22                 std    2,y  ECCF 35   96                 puls   d,x,pc                                          *                     * PCRSIP, put gateway address                     * Y=source address (4 bytes)                     *FIO Simulation Structure             07:28:02  Jan 07, 2024   Page   81wzspi, basic spi routines                             ECD1 34   16       PCRSIP    pshs   d,x  ECD3 5F                      clrb  ECD4                         trfr   B,F  ECD4 1F                      fcb    $1f  ECD5 9F                      fcb    B<<4|F                               endm  ECD6 8E   000F               ldx    #WZSIPR0  ECD9 EC   A4                 ldd    0,y  ECDB BD   EBE1               jsr    wordwr  ECDE 8E   0011               ldx    #WZSIPR2  ECE1 EC   22                 ldd    2,y  ECE3 BD   EBE1               jsr    wordwr  ECE6 35   96                 puls   d,x,pc                                          *                     * GCRILLT, get byte from interrup low level timer register                     * return word in D                     *  ECE8 34   16       GCRILLT   pshs   d,x  ECEA 5F                      clrb  ECEB                         trfr   B,F  ECEB 1F                      fcb    $1f  ECEC 9F                      fcb    B<<4|F                               endm  ECED 8E   0013               ldx    #WZILLT0  ECF0 BD   EB87               jsr    wordrd  ECF3 ED   E4                 std    0,s  ECF5 35   96                 puls   d,x,pc                                          *                     * PCRILLT, put word D into common registers mode register                     *  ECF7 34   16       PCRILLT   pshs   d,x  ECF9 5F                      clrb  ECFA                         trfr   B,F  ECFA 1F                      fcb    $1f  ECFB 9F                      fcb    B<<4|F                               endm  ECFC 8E   0013               ldx    #WZILLT0  ECFF EC   E4                 ldd    0,s  ED01 BD   EBE1               jsr    wordwr  ED04 35   96                 puls   d,x,pc                                          *                     * GCRIR, get byte from common registers interrupt register                     * return byte in B                     *  ED06 34   16       GCRIR     pshs   d,x  ED08 5F                      clrb  ED09                         trfr   B,F  ED09 1F                      fcb    $1f  ED0A 9F                      fcb    B<<4|FFIO Simulation Structure             07:28:02  Jan 07, 2024   Page   82wzspi, basic spi routines                                                          endm  ED0B 8E   0015               ldx    #WZIR  ED0E BD   EB75               jsr    byterd  ED11 ED   E4                 std    0,s  ED13 35   96                 puls   d,x,pc                                          *                     * PCRIR, put byte B into common registers interrupt register                     *  ED15 34   16       PCRIR     pshs   d,x  ED17 5F                      clrb  ED18                         trfr   B,F  ED18 1F                      fcb    $1f  ED19 9F                      fcb    B<<4|F                               endm  ED1A 8E   0015               ldx    #WZIR  ED1D EC   E4                 ldd    0,s  ED1F BD   EBD2               jsr    bytewr  ED22 35   96                 puls   d,x,pc                                          *                     * GCRIMR, get byte from common registers interrupt mask register                     * return byte in B                     *  ED24 34   16       GCRIMR    pshs   d,x  ED26 5F                      clrb  ED27                         trfr   B,F  ED27 1F                      fcb    $1f  ED28 9F                      fcb    B<<4|F                               endm  ED29 8E   0016               ldx    #WZIMR  ED2C BD   EB75               jsr    byterd  ED2F ED   E4                 std    0,s  ED31 35   96                 puls   d,x,pc                                          *                     * PCRIMR, put byte B into common registers interrupt mask register                     *  ED33 34   16       PCRIMR    pshs   d,x  ED35 5F                      clrb  ED36                         trfr   B,F  ED36 1F                      fcb    $1f  ED37 9F                      fcb    B<<4|F                               endm  ED38 8E   0016               ldx    #WZIMR  ED3B EC   E4                 ldd    0,s  ED3D BD   EBD2               jsr    bytewr  ED40 35   96                 puls   d,x,pc                                          *                     * GCRSIR, get byte from common registers socket interrupt register                     * return byte in BFIO Simulation Structure             07:28:02  Jan 07, 2024   Page   83wzspi, basic spi routines                                                *  ED42 34   16       GCRSIR    pshs   d,x  ED44 5F                      clrb  ED45                         trfr   B,F  ED45 1F                      fcb    $1f  ED46 9F                      fcb    B<<4|F                               endm  ED47 8E   0017               ldx    #WZSIR  ED4A BD   EB75               jsr    byterd  ED4D ED   E4                 std    0,s  ED4F 35   96                 puls   d,x,pc                                          *                     * PCRSIR, put byte B into common registers socket interrupt register                     *  ED51 34   16       PCRSIR    pshs   d,x  ED53 5F                      clrb  ED54                         trfr   B,F  ED54 1F                      fcb    $1f  ED55 9F                      fcb    B<<4|F                               endm  ED56 8E   0017               ldx    #WZSIR  ED59 EC   E4                 ldd    0,s  ED5B BD   EBD2               jsr    bytewr  ED5E 35   96                 puls   d,x,pc                                          *                     * GCSIMR, get byte from common registers socket interrupt mask register                     * return byte in B                     *  ED60 34   16       GCRSIMR   pshs   d,x  ED62 5F                      clrb  ED63                         trfr   B,F  ED63 1F                      fcb    $1f  ED64 9F                      fcb    B<<4|F                               endm  ED65 8E   0018               ldx    #WZSIMR  ED68 BD   EB75               jsr    byterd  ED6B ED   E4                 std    0,s  ED6D 35   96                 puls   d,x,pc                                          *                     * PCRSIMR, put byte B into common registers socket interrupt mask register                     *  ED6F 34   16       PCRSIMR   pshs   d,x  ED71 5F                      clrb  ED72                         trfr   B,F  ED72 1F                      fcb    $1f  ED73 9F                      fcb    B<<4|F                               endm  ED74 8E   0018               ldx    #WZSIMR  ED77 EC   E4                 ldd    0,sFIO Simulation Structure             07:28:03  Jan 07, 2024   Page   84wzspi, basic spi routines                             ED79 BD   EBD2               jsr    bytewr  ED7C 35   96                 puls   d,x,pc                                          *                     * GCRRTR, get word from common registers retry register                     * return word in D                     *  ED7E 34   16       GCRRTR    pshs   d,x  ED80 5F                      clrb  ED81                         trfr   B,F  ED81 1F                      fcb    $1f  ED82 9F                      fcb    B<<4|F                               endm  ED83 8E   0019               ldx    #WZRTR0  ED86 BD   EB87               jsr    wordrd  ED89 ED   E4                 std    0,s  ED8B 35   96                 puls   d,x,pc                                          *                     * PCRRTR, put word D into common registers retry register                     *  ED8D 34   16       PCRRTR    pshs   d,x  ED8F 5F                      clrb  ED90                         trfr   B,F  ED90 1F                      fcb    $1f  ED91 9F                      fcb    B<<4|F                               endm  ED92 8E   0019               ldx    #WZRTR0  ED95 EC   E4                 ldd    0,s  ED97 BD   EBE1               jsr    wordwr  ED9A 35   96                 puls   d,x,pc                                          *                     * GCRRCR, get byte from common registers retry count register                     * return byte in B                     *  ED9C 34   16       GCRRCR    pshs   d,x  ED9E 5F                      clrb  ED9F                         trfr   B,F  ED9F 1F                      fcb    $1f  EDA0 9F                      fcb    B<<4|F                               endm  EDA1 8E   001B               ldx    #WZRCR  EDA4 BD   EB75               jsr    byterd  EDA7 ED   E4                 std    0,s  EDA9 35   96                 puls   d,x,pc                                          *                     * PCRRCR, put byte B into common registers retry count register                     *  EDAB 34   16       PCRRCR    pshs   d,x  EDAD 5F                      clrbFIO Simulation Structure             07:28:03  Jan 07, 2024   Page   85wzspi, basic spi routines                             EDAE                         trfr   B,F  EDAE 1F                      fcb    $1f  EDAF 9F                      fcb    B<<4|F                               endm  EDB0 8E   001B               ldx    #WZRCR  EDB3 EC   E4                 ldd    0,s  EDB5 BD   EBD2               jsr    bytewr  EDB8 35   96                 puls   d,x,pc                                          *                     * GCRURP, get word from common registers unreachable port register                     * return word in D                     *  EDBA 34   16       GCRURP    pshs   d,x  EDBC 5F                      clrb  EDBD                         trfr   B,F  EDBD 1F                      fcb    $1f  EDBE 9F                      fcb    B<<4|F                               endm  EDBF 8E   002C               ldx    #WZUPRT0  EDC2 BD   EB87               jsr    wordrd  EDC5 ED   E4                 std    0,s  EDC7 35   96                 puls   d,x,pc                                          *                     * GCRUIP, get unreachable IP address from common registers                     * Y=destination address (4 bytes)                     *  EDC9 34   16       GCRUIP    pshs   d,x  EDCB 5F                      clrb  EDCC                         trfr   B,F  EDCC 1F                      fcb    $1f  EDCD 9F                      fcb    B<<4|F                               endm  EDCE 8E   0028               ldx    #WZUIPR0  EDD1 BD   EB87               jsr    wordrd  EDD4 ED   A4                 std    0,y  EDD6 8E   002A               ldx    #WZUIPR2  EDD9 BD   EB87               jsr    wordrd  EDDC ED   22                 std    2,y  EDDE 35   96                 puls   d,x,pc                                          *                     * GCRPHY, get byte from common registers PHY config register                     * return byte in B                     *  EDE0 34   56       GCRPHY    pshs   d,x,u  EDE2 8E   002E               ldx    #WZPHY  EDE5 5F                      clrb  EDE6                         trfr   B,F  EDE6 1F                      fcb    $1f  EDE7 9F                      fcb    B<<4|FFIO Simulation Structure             07:28:03  Jan 07, 2024   Page   86wzspi, basic spi routines                                                          endm  EDE8 BD   EB75               jsr    byterd  EDEB ED   E4                 std    0,s  EDED 35   D6                 puls   d,x,u,pc                                          *                     * PCRPHY, put byte B into common registers PHY config register                     *  EDEF 34   56       PCRPHY    pshs   d,x,u  EDF1 8E   002E               ldx    #WZPHY  EDF4 5F                      clrb  EDF5                         trfr   B,F  EDF5 1F                      fcb    $1f  EDF6 9F                      fcb    B<<4|F                               endm  EDF7 EC   E4                 ldd    0,s  EDF9 BD   EBD2               jsr    bytewr  EDFC 35   D6                 puls   d,x,u,pc                                          *                     * GCRVERS, get byte from common registers socket version register                     * return byte in B                     *  EDFE 34   56       GCRVERS   pshs   d,x,u  EE00 8E   0039               ldx    #WZVERS  EE03 5F                      clrb  EE04                         trfr   B,F  EE04 1F                      fcb    $1f  EE05 9F                      fcb    B<<4|F                               endm  EE06 BD   EB75               jsr    byterd  EE09 ED   E4                 std    0,s  EE0B 35   D6                 puls   d,x,u,pc                     *                     * all functions to access socket registers                     *                                          * socket register names and offsets               0000  SNMR      equ    0               0001  SNCR      equ    1               0002  SNIR      equ    2               0003  SNSR      equ    3               0004  SNPORT0   equ    4               0005  SNPORT1   equ    5               0006  SNDHAR0   equ    6               0007  SNDHAR1   equ    7               0008  SNDHAR2   equ    8               0009  SNDHAR3   equ    9               000A  SNDHAR4   equ    10               000B  SNDHAR5   equ    11               000C  SNDIPR0   equ    12               000D  SNDIPR1   equ    13FIO Simulation Structure             07:28:04  Jan 07, 2024   Page   87wzspi, basic spi routines                                          000E  SNDIPR2   equ    14               000F  SNDIPR3   equ    15               0010  SNDPOR0   equ    16               0011  SNDPOR1   equ    17               0012  SNMSSR0   equ    18               0013  SNMSSR1   equ    19               0015  SNTOS     equ    21               0016  SNTTL     equ    22               001E  SNRBFSZ   equ    30               001F  SNTBFSZ   equ    31               0020  SNTXFR0   equ    32               0021  SNTXFR1   equ    33               0022  SNTXRP0   equ    34               0023  SNTXRP1   equ    35               0024  SNTXWP0   equ    36               0025  SNTXWP1   equ    37               0026  SNRXRZ0   equ    38               0027  SNRXRZ1   equ    39               0028  SNRXRP0   equ    40               0029  SNRXRP1   equ    41               002A  SNRXWP0   equ    42               002B  SNRXWP1   equ    43               002C  SNIMR     equ    44               002D  SNFRAG0   equ    45               002E  SNFRAG1   equ    46               002F  SNKATIM   equ    47                                                               *                     * all commands to access socket register set                     *                                                               *                     * GSRMR, get byte from socket registers mode register                     * E=socket#                     * return byte in B                     *  EE0D 34   16       GSRMR     psh    d,x  EE0F BD   F0AD               jsr    tsk2rg  EE12 8E   0000               ldx    #SNMR  EE15 BD   EB75               jsr    byterd  EE18 ED   E4                 std    0,s  EE1A 35   96                 puls   d,x,pc                                          *                     * PSRMR, put byte B  to socket registers mode register                     * E=socket#                     *  EE1C 34   16       PSRMR     pshs   d,x  EE1E BD   F0AD               jsr    tsk2rg  EE21 8E   0000               ldx    #SNMRFIO Simulation Structure             07:28:04  Jan 07, 2024   Page   88wzspi, basic spi routines                             EE24 EC   E4                 ldd    0,s  EE26 BD   EBD2               jsr    bytewr  EE29 35   96                 puls   d,x,pc                                          *                     * GSRCR, get bytefrom socket registers command register                     * E=socket#                     * return byte in B                     *  EE2B 34   16       GSRCR     pshs   d,x  EE2D BD   F0AD               jsr    tsk2rg  EE30 8E   0001               ldx    #SNCR  EE33 BD   EB75               jsr    byterd  EE36 ED   E4                 std    0,s  EE38 35   96                 puls   d,x,pc                                          *                     * PSRCR, put byte B in socket registers command register                     * E=socket#                     *  EE3A 34   16       PSRCR     pshs   d,x  EE3C BD   F0AD               jsr    tsk2rg  EE3F 8E   0001               ldx    #SNCR  EE42 EC   E4                 ldd    0,s  EE44 BD   EBD2               jsr    bytewr  EE47 8D   E2       01        bsr    GSRCR  EE49 5D                      tstb  EE4A 26   FB                 bne    01b       wait command to be consumed  EE4C E7   61                 stb    1,s       set return  EE4E 35   96                 puls   d,x,pc                                          *                     * GSRIR, get bytefrom socket registers interrupt register                     * E=socket#                     * return byte in B                     *  EE50 34   16       GSRIR     pshs   d,x  EE52 BD   F0AD               jsr    tsk2rg  EE55 8E   0002               ldx    #SNIR  EE58 BD   EB75               jsr    byterd  EE5B ED   E4                 std    0,s  EE5D 35   96                 puls   d,x,pc                                          *                     * PSRIR, put byte B in socket registers interrupt register                     * E=socket#                     *  EE5F 34   16       PSRIR     pshs   d,x  EE61 BD   F0AD               jsr    tsk2rg  EE64 8E   0002               ldx    #SNIR  EE67 EC   E4                 ldd    0,s  EE69 BD   EBD2               jsr    bytewrFIO Simulation Structure             07:28:04  Jan 07, 2024   Page   89wzspi, basic spi routines                             EE6C 35   96                 puls   d,x,pc                                          *                     * GSRSR, get bytefrom socket registers status register                     * E=socket#                     * return byte in B                     *  EE6E 34   16       GSRSR     pshs   d,x  EE70 BD   F0AD               jsr    tsk2rg  EE73 8E   0003               ldx    #SNSR  EE76 BD   EB75               jsr    byterd  EE79 ED   E4                 std    0,s  EE7B 35   96                 puls   d,x,pc                                          *                     * GSRPORT, get word from socket registers source port                     * E=socket#                     * return word in D                     *  EE7D 34   16       GSRPORT   pshs   d,x  EE7F BD   F0AD               jsr    tsk2rg  EE82 8E   0004               ldx    #SNPORT0  EE85 BD   EB87               jsr    wordrd  EE88 ED   E4                 std    0,s  EE8A 35   96                 pul    d,x,pc                                          *                     * PSRPORT, put word D  into socket registers source port                     * E=socket#                     *  EE8C 34   16       PSRPORT   pshs   d,x  EE8E BD   F0AD               jsr    tsk2rg  EE91 8E   0004               ldx    #SNPORT0  EE94 EC   E4                 ldd    0,s  EE96 BD   EBE1               jsr    wordwr  EE99 35   96                 puls   d,x,pc                                          *                     * GSRDHAR, get destination hardware address into [Y]                     * F=sockt#, Y=destination                     *  EE9B 34   16       GSRDHAR   pshs   d,x  EE9D BD   F0AD               jsr    tsk2rg  EEA0 8E   0006               ldx    #SNDHAR0  EEA3 BD   EB87               jsr    wordrd  EEA6 ED   A4                 std    0,y  EEA8 8E   0008               ldx    #SNDHAR2  EEAB BD   EB87               jsr    wordrd  EEAE ED   22                 std    2,y  EEB0 8E   000A               ldx    #SNDHAR4  EEB3 BD   EB87               jsr    wordrd  EEB6 ED   24                 std    4,yFIO Simulation Structure             07:28:05  Jan 07, 2024   Page   90wzspi, basic spi routines                             EEB8 35   96                 puls   d,x,pc                                          *                     * PSRDHAR, put [Y] into destination hardware address                     * F=sockt#, Y=destination                     *  EEBA 34   16       PSRDHAR   pshs   d,x  EEBC BD   F0AD               jsr    tsk2rg  EEBF 8E   0006               ldx    #SNDHAR0  EEC2 EC   A4                 ldd    0,y  EEC4 BD   EBE1               jsr    wordwr  EEC7 8E   0008               ldx    #SNDHAR2  EECA EC   22                 ldd    2,y  EECC BD   EBE1               jsr    wordwr  EECF 8E   000A               ldx    #SNDHAR4  EED2 EC   24                 ldd    4,y  EED4 BD   EBE1               jsr    wordwr  EED7 35   96                 puls   d,x,pc                                          *                     * GSRDIP. get destination IP address into [Y]                     * E=socket#                     *  EED9 34   16       GSRDIP    pshs   d,x  EEDB BD   F0AD               jsr    tsk2rg  EEDE 8E   000C               ldx    #SNDIPR0  EEE1 BD   EB87               jsr    wordrd  EEE4 ED   A4                 std    0,y  EEE6 8E   000E               ldx    #SNDIPR2  EEE9 BD   EB87               jsr    wordrd  EEEC ED   22                 std    2,y  EEEE 35   96                 puls   d,x,pc                                          *                     * PSRDIP. put destination IP address into [Y]                     * E=socket#                     *  EEF0 34   16       PSRDIP    pshs   d,x  EEF2 BD   F0AD               jsr    tsk2rg  EEF5 8E   000C               ldx    #SNDIPR0  EEF8 EC   A4                 ldd    0,y  EEFA BD   EBE1               jsr    wordwr  EEFD 8E   000E               ldx    #SNDIPR2  EF00 EC   22                 ldd    2,y  EF02 BD   EBE1               jsr    wordwr  EF05 35   96                 puls   d,x,pc                                          *                     * GSRDPOR, get word from socket registers destination port                     * E=socket#                     * return word in D                     *FIO Simulation Structure             07:28:05  Jan 07, 2024   Page   91wzspi, basic spi routines                             EF07 34   16       GSRDPOR   pshs   d,x  EF09 BD   F0AD               jsr    tsk2rg  EF0C 8E   0010               ldx    #SNDPOR0  EF0F BD   EB87               jsr    wordrd  EF12 ED   E4                 std    0,s  EF14 35   96                 pul    d,x,pc                                          *                     * PSRDPOR, put word D  into socket registers source port                     * E=socket#                     *  EF16 34   16       PSRDPOR   pshs   d,x  EF18 BD   F0AD               jsr    tsk2rg  EF1B 8E   0010               ldx    #SNDPOR0  EF1E EC   E4                 ldd    0,s  EF20 BD   EBE1               jsr    wordwr  EF23 35   96                 puls   d,x,pc                                          *                     * GSRMSS, get word from socket registers max segment size                     * E=socket#                     * return word in D                     *  EF25 34   16       GSRMSS    pshs   d,x  EF27 BD   F0AD               jsr    tsk2rg  EF2A 8E   0012               ldx    #SNMSSR0  EF2D BD   EB87               jsr    wordrd  EF30 ED   E4                 std    0,s  EF32 35   96 8:∂2<81Üêêê()©&©©ñ8:∫;∑π2"4∑:7ê9∑±µ≤∫92≥¥π∫2π9ê6∞º4∂∫∂ê9≤≥∂≤∑:9¥Ω2Üê"ûπ∑±µ≤∫Üêê"£ööõ()©&©©ê89¥9ê2<ê"£õ!"# ¢59π:9µô93Üê"£úê"êô62<©ß&©©©ê"£°ê"°ê"ö6229Üê"£¢ê!""°"òê59π;∑π2;πê"£êöêõ8:∂9ê2<81Üêê                 *                     * GSRTOS, get byte from socket registers TOS                     * E=socket#                     * return byte in B                     *  EF43 34   16       GSRTOS    pshs   d,x  EF45 BD   F0AD               jsr    tsk2rg  EF48 8E   0015               ldx    #SNTOS  EF4B BD   EB75               jsr    byterd  EF4E ED   E4                 std    0,s  EF50 35   96                 pul    d,x,pcFIO Simulation Structure             07:28:05  Jan 07, 2024   Page   92wzspi, basic spi routines                                                                     *                     * PSRTOS, put byte B  into socket registers TOS                     * E=socket#                     *  EF52 34   16       PSRTOS    pshs   d,x  EF54 BD   F0AD               jsr    tsk2rg  EF57 8E   0015               ldx    #SNTOS  EF5A EC   E4                 ldd    0,s  EF5C BD   EBD2               jsr    bytewr  EF5F 35   96                 puls   d,x,pc                                          *                     * GSRTTL, get byte from socket registers TTL                     * E=socket#                     * return byte in B                     *  EF61 34   16       GSRTTL    pshs   d,x  EF63 BD   F0AD               jsr    tsk2rg  EF66 8E   0016               ldx    #SNTTL  EF69 BD   EB75               jsr    byterd  EF6C ED   E4                 std    0,s  EF6E 35   96                 pul    d,x,pc                                          *                     * PSRTTL, put byte B  into socket registers TTL                     * E=socket#                     *  EF70 34   16       PSRTTL    pshs   d,x  EF72 BD   F0AD               jsr    tsk2rg  EF75 8E   0016               ldx    #SNTTL  EF78 EC   E4                 ldd    0,s  EF7A BD   EBD2               jsr    bytewr  EF7D 35   96                 puls   d,x,pc                                          *                     * GSRRBFS, get byte from socket registers rec buf size                     * E=socket#                     * return byte in B                     *  EF7F 34   16       GSRRBFS   pshs   d,x  EF81 BD   F0AD               jsr    tsk2rg  EF84 8E   001E               ldx    #SNRBFSZ  EF87 BD   EB75               jsr    byterd  EF8A ED   E4                 std    0,s  EF8C 35   96                 pul    d,x,pc                                          *                     * PSRTBFS, put byte B  into socket registers rec buf siz                     * E=socket#                     *  EF8E 34   16       PSRRBFS   pshs   d,xFIO Simulation Structure             07:28:06  Jan 07, 2024   Page   93wzspi, basic spi routines                             EF90 BD   F0AD               jsr    tsk2rg  EF93 8E   001E               ldx    #SNRBFSZ  EF96 EC   E4                 ldd    0,s  EF98 BD   EBD2               jsr    bytewr  EF9B 35   96                 puls   d,x,pc                                          *                     * GSRTBFS, get byte from socket registers tx buf size                     * E=socket#                     * return byte in B                     *  EF9D 34   16       GSRTBFS   pshs   d,x  EF9F BD   F0AD               jsr    tsk2rg  EFA2 8E   001F               ldx    #SNTBFSZ  EFA5 BD   EB75               jsr    byterd  EFA8 ED   E4                 std    0,s  EFAA 35   96                 puls   d,x,pc                                          *                     * PSRTBFS, put byte B  into socket registers tx buf siz                     * E=socket#                     *  EFAC 34   16       PSRTBFS   pshs   d,x  EFAE BD   F0AD               jsr    tsk2rg  EFB1 8E   001F               ldx    #SNTBFSZ  EFB4 EC   E4                 ldd    0,s  EFB6 BD   EBD2               jsr    bytewr  EFB9 35   96                 puls   d,x,pc                                          *                     * GSRTXFR, get word from socket registers TX free size                     * E=socket#                     * return word in D                     *  EFBB 34   16       GSRTXFR   pshs   d,x  EFBD BD   F0AD               jsr    tsk2rg  EFC0 8E   0020               ldx    #SNTXFR0  [R]  EFC3 BD   EB87               jsr    wordrd  EFC6 ED   E4       01        std    0,s  EFC8 BD   EB87               jsr    wordrd  EFCB 10A3 E4                 cmpd   0,s       read more times and exit  EFCE 26   F6                 bne    01b       when 2 reads are equal  EFD0 35   96                 puls   d,x,pc                                          *                     * GSRTXRP, get word from socket registers TX read pointer                     * E=socket#                     * return word in D                     *  EFD2 34   16       GSRTXRP   pshs   d,x  EFD4 BD   F0AD               jsr    tsk2rg  EFD7 8E   0022               ldx    #SNTXRP0  [R]FIO Simulation Structure             07:28:06  Jan 07, 2024   Page   94wzspi, basic spi routines                             EFDA BD   EB87               jsr    wordrd  EFDD ED   E4       01        std    0,s  EFDF BD   EB87               jsr    wordrd  EFE2 10A3 E4                 cmpd   0,s       read more times and exit  EFE5 26   F6                 bne    01b       when 2 reads are equal  EFE7 35   96                 puls   d,x,pc                                          *                     * GSRTXWP, get word from socket registers TX write pointer                     * E=socket#                     * return word in D                     *  EFE9 34   16       GSRTXWP   pshs   d,x  EFEB BD   F0AD               jsr    tsk2rg  EFEE 8E   0024               ldx    #SNTXWP0  [RW]  EFF1 BD   EB87               jsr    wordrd  EFF4 ED   E4                 std    0,s  EFF6 35   96                 puls   d,x,pc                                          *                     * PSRTXWP, put word D into socket registers TX write pointer                     * E=socket#                     *  EFF8 34   16       PSRTXWP   pshs   d,x  EFFA BD   F0AD               jsr    tsk2rg  EFFD 8E   0024               ldx    #SNTXWP0  F000 EC   E4                 ldd    0,s  F002 BD   EBE1               jsr    wordwr  F005 35   96                 puls   d,x,pc                                          *                     * GSRRXRS, get word from socket registers RX received size                     * E=socket#                     * return word in D                     *  F007 34   16       GSRRXRS   pshs   d,x  F009 BD   F0AD               jsr    tsk2rg  F00C 8E   0026               ldx    #SNRXRZ0  [R]  F00F BD   EB87               jsr    wordrd  F012 ED   E4       01        std    0,s  F014 BD   EB87               jsr    wordrd  F017 10A3 E4                 cmpd   0,s       read more times and exit  F01A 26   F6                 bne    01b       when 2 reads are equal  F01C 35   96                 puls   d,x,pc                                          *                     * GSRRXRP, get word from socket registers RX read pointer                     * E=socket#                     * return word in D                     *  F01E 34   16       GSRRXRP   pshs   d,x  F020 BD   F0AD               jsr    tsk2rgFIO Simulation Structure             07:28:06  Jan 07, 2024   Page   95wzspi, basic spi routines                             F023 8E   0028               ldx    #SNRXRP0  [RW]  F026 BD   EB87               jsr    wordrd  F029 ED   E4                 std    0,s  F02B 35   96                 puls   d,x,pc                                          *                     * PSRRXRP, put word D into socket registers RX read pointer                     * E=socket#                     *  F02D 34   16       PSRRXRP   pshs   d,x >F02F BD   F0AD               jsr    tsk2rg  F032 8E   0028               ldx    #SNRXRP0  F035 EC   E4                 ldd    0,s  F037 BD   EBE1               jsr    wordwr  F03A 35   96                 puls   d,x,pc                                          *                     * GSRRXWP, get word from socket registers RX write pointer                     * E=socket#                     * return word in D                     *  F03C 34   16       GSRRXWP   pshs   d,x >F03E BD   F0AD               jsr    tsk2rg  F041 8E   002A               ldx    #SNRXWP0  [R]  F044 BD   EB87               jsr    wordrd  F047 ED   E4       01        std    0,s  F049 BD   EB87               jsr    wordrd  F04C 10A3 E4                 cmpd   0,s       read more times and exit  F04F 26   F6                 bne    01b       when 2 reads are equal  F051 35   96                 puls   d,x,pc                                          *                     * GSRIMR, get byte from socket registers interrupt mask                     * E=socket#                     * return byte in B                     *  F053 34   16       GSRIMR    pshs   d,x >F055 BD   F0AD               jsr    tsk2rg  F058 8E   002C               ldx    #SNIMR  F05B BD   EB75               jsr    byterd  F05E ED   E4                 std    0,s  F060 35   96                 puls   d,x,pc                                          *                     * PSRIMS, put byte B  into socket registers interrupt mask                     * E=socket#                     *  F062 34   16       PSRIMR    pshs   d,x >F064 BD   F0AD               jsr    tsk2rg  F067 8E   002C               ldx    #SNIMR  F06A EC   E4                 ldd    0,s  F06C BD   EBD2               jsr    bytewrFIO Simulation Structure             07:28:07  Jan 07, 2024   Page   96wzspi, basic spi routines                             F06F 35   96                 puls   d,x,pc                                          *                     * GSRFRAG, get word from socket registers FRAG                     * E=socket#                     * return word in D                     *  F071 34   16       GSRFRAG   pshs   d,x >F073 BD   F0AD               jsr    tsk2rg  F076 8E   002D               ldx    #SNFRAG0  F079 BD   EB87               jsr    wordrd  F07C ED   E4                 std    0,s  F07E 35   96                 puls   d,x,pc                                          *                     * PSRGRAG, put word D into socket registers FRAG                     * E=socket#                     *  F080 34   16       PSRFRAG   pshs   d,x >F082 BD   F0AD               jsr    tsk2rg  F085 8E   002D               ldx    #SNFRAG0  F088 EC   E4                 ldd    0,s  F08A BD   EBE1               jsr    wordwr  F08D 35   96                 puls   d,x,pc                                          *                     * GSRKATM, get byte from socket registers keep alive timer                     * E=socket#                     * return byte in B                     *  F08F 34   16       GSKATM    pshs   d,x >F091 BD   F0AD               jsr    tsk2rg  F094 8E   002F               ldx    #SNKATIM  F097 BD   EB75               jsr    byterd  F09A ED   E4                 std    0,s  F09C 35   96                 puls   d,x,pc                                          *                     * PSRKATM, put byte B  into socket registers keep alive timer                     * E=socket#                     *  F09E 34   16       PSRKATM   pshs   d,x >F0A0 BD   F0AD               jsr    tsk2rg  F0A3 8E   002F               ldx    #SNKATIM  F0A6 EC   E4                 ldd    0,s  F0A8 BD   EBD2               jsr    bytewr  F0AB 35   96                 puls   d,x,pc                     *                     * data handling routines                     *                                          * translate socket register in partial addressFIO Simulation Structure             07:28:07  Jan 07, 2024   Page   97wzspi, basic spi routines                                                * prepares bits [7...5][4...3]                     * E=socket#, F=lost, B=lost               F0AD  tsk2rg    equ    *  F0AD                         trfr   E,B  F0AD 1F                      fcb    $1f  F0AE E9                      fcb    E<<4|B                               endm  F0AF 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F0B0 1C   FE                 clc              make reg bits + '01'  F0B2 59                      rolb             socket register  F0B3 1A   01                 sec  F0B5 59                      rolb             xxx 01 ...                     *  F0B6                         trfr   B,F  F0B6 1F                      fcb    $1f  F0B7 9F                      fcb    B<<4|F                               endm  F0B8 39                      rts                                          *                     * translate socket register in final address (data xfer)                     * prepares bit [7...0]                     *               F0B9  tsk2tx    equ    *  F0B9                         trfr   E,B  F0B9 1F                      fcb    $1f  F0BA E9                      fcb    E<<4|B                               endm  F0BB 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F0BC 1A   01                 sec              make reg bits + '10'  F0BE 59                      rolb             sock TX buffer  F0BF 1C   FE                 clc  F0C1 59                      rolb                     *  F0C2 1A   01                 sec  F0C4 59                      rolb             write bit     '1'                     *  F0C5 58                      lslb             variable size '00'  F0C6 58                      lslb             xxx 10 100                     *  F0C7 39                      rts                                          *                     * translate socket register in rx buffer address (data xfer)                     * prepares bit [7...0]                     *               F0C8  tsk2rx    equ    *  F0C8                         trfr   E,B  F0C8 1F                      fcb    $1f  F0C9 E9                      fcb    E<<4|BFIO Simulation Structure             07:28:07  Jan 07, 2024   Page   98wzspi, basic spi routines                                                          endm  F0CA 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F0CB 1A   01                 sec              make reg bits + '11'  F0CD 59                      rolb             sock RX buffer  F0CE 1A   01                 sec              make reg bits + '11'  F0D0 59                      rolb                     *  F0D1 1C   FE                 clc  F0D3 59                      rolb             read bit     '0'                     *  F0D4 58                      lslb             variable size '00'  F0D5 58                      lslb             xxx 11 000  F0D6 39                      rts                                          *                     * rdsk2fb, read socket data in fifo buffer                     * Y=sock, U=sock info                     * E=socket#                     * entry D= available count                     * return, D=xferred count                     *  F0D7 34   76       RDSK2FB   pshs   d,x,y,u                     *  F0D9 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F0DC 23   02                 bls    01f  F0DE EC   4A                 ldd    wzrqln,u  mandatory size  F0E0 1F   01       01        tfr    D,X       size  F0E2 ED   E4                 std    0,s       save xfrerred old  D  F0E4 ED   48                 std    wzxfer,u  F0E6 27   3C                 beq    15f       no data                     *  F0E8 BD   F01E               jsr    GSRRXRP  F0EB 34   06                 pshs   d         save socket read pointer  F0ED 1F   02                 tfr    D,Y                     *  F0EF CE   8080               ldu    #SPIBASE  F0F2 34   01                 pshs   cc  F0F4                         pshsw  F0F4 1038                    fdb    $1038                               endm  F0F6 34   40                 pshs   u  F0F8 1A   50                 orcc   #$50      disable interrupts  F0FA 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F0FC A7   C4                 sta    spicmd,u  F0FE 10AF 44                 sty    hibyta,u  start address                      >F101 BD   F0C8               jsr    tsk2rx    SOCK# to buffer address                       F104 E7   44                 stb    hibyta,u  F106 108E 0020               ldy    #fifo  F10A E7   44                 stb    hibyta,u  shift out first data byteFIO Simulation Structure             07:28:07  Jan 07, 2024   Page   99wzspi, basic spi routines                             F10C 33   45                 leau   lobyta,u  lobyte is the first byte shifted in  F10E                         trfr   X,W  F10E 1F                      fcb    $1f  F10F 16                      fcb    X<<4|W                               endm  F110                         tfm4   U,Y  F110 113B                    fdb    $113b  F112 32                      fcb    U<<4|Y                               endm  F113 35   40                 puls   u  F115 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F117 A7   C4                 sta    spicmd,u  F119                         pulsw  restore   E:F  F119 1039                    fdb    $1039                               endm  F11B 35   01                 puls   cc                     *  F11D 35   06                 puls   d         old read pointer  F11F E3   E4                 addd   0,s       adjust transferred  F121 BD   F02D               jsr    PSRRXRP   update pointer                     *  F124 35   F6       15        puls   d,x,y,u,pc                                                               *                     * wrfb2sk,write fifo buffer to socket buffer                     * Y=sock                     * E=socket#                     * on entry D= total amount to xfer                     * on return D= xferred count                     *  F126 34   76       WRFB2SK   pshs   d,x,y,u  F128 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F12B 23   02                 bls    01f  F12D EC   4A                 ldd    wzrqln,u  F12F 1F   01       01        tfr    d,x  F131 ED   E4                 std    0,s  F133 ED   48                 std    wzxfer,u  report size  F135 27   53                 beq    15f                     *  F137 10AE C8 22              ldy    wzuwrp,u  0 if not UDP or never written  F13B 26   05                 bne    24f  F13D BD   EFE9               jsr    GSRTXWP   get write pointer  F140 20   02                 bra    25f  F142 1F   20       24        tfr    y,d                     *  F144 34   06       25        pshs   d  F146 1F   02                 tfr    D,Y                     *  F148 CE   8080               ldu    #SPIBASE  F14B 34   01                 pshs   cc  F14D                         pshsw  save      E:FFIO Simulation Structure             07:28:08  Jan 07, 2024   Page  100wzspi, basic spi routines                             F14D 1038                    fdb    $1038                               endm  F14F 34   40                 pshs   u  F151 1A   50                 orcc   #$50  F153 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F155 A7   C4                 sta    spicmd,u  F157 10AF 44                 sty    hibyta,u  start address                       F15A BD   F0B9               jsr    tsk2tx                       F15D E7   44                 stb    hibyta,u  F15F 108E 0020               ldy    #fifo  F163 33   44                 leau   hibyta,u  the first to shift out  F165                         trfr   X,W  F165 1F                      fcb    $1f  F166 16                      fcb    X<<4|W                               endm  F167                         tfm3   Y,U  F167 113A                    fdb    $113a  F169 23                      fcb    Y<<4|U                               endm  F16A 35   40                 puls   u  F16C 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F16E A7   C4                 sta    spicmd,u  F170                         pulsw  restore   E:F!!  F170 1039                    fdb    $1039                               endm  F172 35   01                 puls   cc                     *  F174 35   06                 puls   d         old write pointer  F176 E3   E4                 addd   0,s  F178 EE   66                 ldu    6,s       restore U  F17A AE   C8 26              ldx    wztype,u  F17D 8C   0002               cmpx   #SK_DGRM  F180 27   05                 beq    10f  F182 BD   EFF8     11        jsr    PSRTXWP   update pointer  F185 20   03                 bra    15f                       F187 ED   C8 22    10        std    wzuwrp,u  set RAM pointer                     *                     *  F18A 35   F6       15        puls   d,x,y,u,pcFIO Simulation Structure             07:28:08  Jan 07, 2024   Page  101Debug Interface Routines                                                   F18C               DB_main  F18C 8D   4F                 bsr    DB_test   see if debug routines present  F18E 6E   9F C002            jmp    [DEBUGROM+2]  F192               DB_pdata  F192 8D   49                 bsr    DB_test   see if debug routines present  F194 6E   9F C004            jmp    [DEBUGROM+4]  F198               DB_phex  F198 8D   43                 bsr    DB_test   see if debug routines present  F19A 6E   9F C006            jmp    [DEBUGROM+6]  F19E               DB_phex2  F19E 8D   3D                 bsr    DB_test   see if debug routines present  F1A0 6E   9F C008            jmp    [DEBUGROM+8]  F1A4               DB_pcrlf  F1A4 8D   37                 bsr    DB_test   see if debug routines present  F1A6 6E   9F C00A            jmp    [DEBUGROM+10]  F1AA               DB_check  F1AA 8D   31                 bsr    DB_test   see if debug routines present  F1AC 6E   9F C00C            jmp    [DEBUGROM+12]  F1B0               DB_config  F1B0 8D   2B                 bsr    DB_test   see if debug routines present  F1B2 6E   9F C00E            jmp    [DEBUGROM+14]  F1B6 34   17       DB_msg    pshs   cc,d,x  F1B8 AE   65                 ldx    1+2+2,s   get return address  F1BA EC   81                 ldd    ,x++      get mask word  F1BC B4   0401               anda   DB_cntrl  F1BF F4   0402               andb   DB_cntrl+1  F1C2 34   04                 pshs   b  F1C4 AA   E0                 ora    ,s+  F1C6 27   04                 beq    10f       jump if flag not set  F1C8 30   02                 leax   2,x       skip over false address & fall through  F1CA 20   02                 bra    20f  F1CC AE   84       10        ldx    ,x        get false branch label  F1CE AF   65       20        stx    1+2+2,s   fix up return address  F1D0 35   97                 puls   cc,d,x,pc return                     *  F1D2               DB_pspace  F1D2               DB_outsp  F1D2 34   16                 pshs   d,x  F1D4 8E   F1DB               ldx    #00f  F1D7 8D   B9                 bsr    DB_pdata  F1D9 35   96                 puls   d,x,pc  F1DB 20 00         00        fcc    ' ',0                       F1DD 34   07       DB_test   pshs   cc,d  F1DF FC   C000               ldd    DEBUGROM  Debug rom present?  F1E2 1083 1234               cmpd   #$1234    special marker  F1E6 27   05                 beq    99f       yes - exit  F1E8 35   07                 puls   cc,d      no - abort DB_xx function  F1EA 32   62                 leas   2,s  F1EC 39                      rts  F1ED 35   87       99        puls   cc,d,pc   returnFIO Simulation Structure             07:28:08  Jan 07, 2024   Page  102Debug Interface Routines                                                                                                     end    rom_initFIO Simulation Structure             07:28:09  Jan 07, 2024   Page  103Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AF_INET  0002   AF_UNIX  0001   AF_UNSP  0000   B        0009   CC       000A   CI_CFL   0080   CI_MP    0010   CI_POC   0020   CI_UNR   0040   CPU2DEV  0022   CPU_down E03D   CPUtraps FFF0   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F1AA   DB_cntrl 0401   DB_confi F1B0   DB_iflg  0400   DB_main  F18C   DB_msg   F1B6   DB_outsp F1D2   DB_pcrlf F1A4   DB_pdata F192   DB_phex  F198   DB_phex2 F19E   DB_pspac F1D2   DB_test  F1DD   DBmsg00  E000   DBmsg01  E009   DBmsg02  E029   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV2CPU  0021   DEV_SIZE 0006   DEV_SOCK E5CD   DO_HISTO 0001   DP       000B   DPR_BASE 0000   D_END    002E   D_func0  0000   D_func1  0002   D_func10 0020   D_func11 0022   D_func12 0024   D_func13 0026   D_func2  0004   D_func3  0006   D_func4  0008   D_func5  000A   D_func6  000C   D_func7  000E   D_func8  0010   D_func9  0012   D_funcA  0014   D_funcB  0016   D_funcC  0018   D_funcD  001A   D_funcE  001C   D_funcF  001E   D_init   002A   D_inthan 0028   D_test   002C   E        000E   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get E2D9   FIFO_put E2FE   FIFOgeta E2D0   FIFOputa E2F6   FIOPRI   FFCE   FIO_get  E2AE   FIO_lock 0446   FIO_rel  E2C3   GCRGA    EC20   GCRILLT  ECE8   GCRIMR   ED24   GCRIR    ED06   GCRMR    EC02   GCRPHY   EDE0   GCRRCR   ED9C   GCRRTR   ED7E   GCRSHA   EC7C   GCRSIMR  ED60   GCRSIP   ECBA   GCRSIR   ED42   GCRSNM   EC4E   GCRUIP   EDC9   GCRURP   EDBA   GCRVERS  EDFE   GSKATM   F08F   GSRCR    EE2B   GSRDHAR  EE9B   GSRDIP   EED9   GSRDPOR  EF07   GSRFRAG  F071   GSRIMR   F053   GSRIR    EE50   GSRMR    EE0D   GSRMSS   EF25   GSRPORT  EE7D   GSRRBFS  EF7F   GSRRXRP  F01E   GSRRXRS  F007   GSRRXWP  F03C   GSRSR    EE6E   GSRTBFS  EF9D   GSRTOS   EF43   GSRTTL   EF61   GSRTXFR  EFBB   GSRTXRP  EFD2   GSRTXWP  EFE9   HANGS    0001   HRECSIZ  0004   H_cpu    E44C   H_fio    E470   IF       0010   INTS     0002   IO_end   E377   IO_han   E319   IRQ_han  E395   IRQmsg10 E3A2   IS       0003   IU       0002   IX       0000   IY       0001   MAXHIST  0010   MAXTBL   0004   MAX_DEV  0001   MAX_S_NU 0015   MAX_TI   0009   MAX_UDP  05C0   MAX_WZ   0008   MOD_SIZE 0004   NET      0001   NUM_TSK  0459   O_INTRPT 0038   PACK_COM 0000   PACK_FIR 0080   PACK_REM 0001   PC       0005   PCRGA    EC37   PCRILLT  ECF7   PCRIMR   ED33   PCRIR    ED15   PCRMR    EC11   PCRPHY   EDEF   PCRRCR   EDAB   PCRRTR   ED8D   PCRSHA   EC9B   PCRSIMR  ED6F   PCRSIP   ECD1   PCRSIR   ED51   PCRSNM   EC65   PF_INET  0002   PF_UNIX  0001   POLPRI   FFBA   PSRCR    EE3A   PSRDHAR  EEBA   PSRDIP   EEF0   PSRDPOR  EF16   PSRFRAG  F080   PSRIMR   F062   PSRIR    EE5F   PSRKATM  F09E   PSRMR    EE1C   PSRMSS   EF34   PSRPORT  EE8C   PSRRBFS  EF8E   PSRRXRP  F02D   PSRTBFS  EFAC   PSRTOS   EF52   PSRTTL   EF70   PSRTXWP  EFF8   QFF1     0080   QUITS    0003   RAMend   3EFF   RAMorg   0400   RAMscrat 7000   RAMscren 7E00   RDSK2FB  F0D7   REJECT   0080   ROMLOorg E000   ROM_ERR  E0B5   ROM_VERS 0030   ROMstack 7FE0   RSVREG   0003   RUNPRI   0046   R_ACCEPT 000B   R_BIND   0009   R_CLOSE  0002   R_CONNEC 0008   R_DISCON 000C   R_INTRPT 0007   R_LISTEN 000A   R_OPEN   0001   R_RDFRM  0021   R_READ   0006   R_RQRD   0005   R_RQRDNB 0015   R_RQWR   0003   R_RQWRNB 0013   R_RRDFD  0022   R_RSNDTO 0023   FIO Simulation Structure             07:28:09  Jan 07, 2024   Page  104Debug Interface Routines                            R_SNDKEP 000E   R_SNDMAC 000D   R_SNDTOM 0025   R_SPCL   000F   R_WRITE  0004   R_WSNDTO 0024   S        0004   SIQPRI   FFD8   SI_CON   0001   SI_DIS   0002   SI_HAN   E3E9   SI_Q     040E   SI_Q_ptr 0444   SI_RCV   0004   SI_SOK   0010   SI_TIM   0008   SKADLN   0010   SKPRI    FFC4   SK_DGRM  0002   SK_RAW   0003   SK_STRM  0001   SNCR     0001   SNDHAR0  0006   SNDHAR1  0007   SNDHAR2  0008   SNDHAR3  0009   SNDHAR4  000A   SNDHAR5  000B   SNDIPR0  000C   SNDIPR1  000D   SNDIPR2  000E   SNDIPR3  000F   SNDPOR0  0010   SNDPOR1  0011   SNFRAG0  002D   SNFRAG1  002E   SNIMR    002C   SNIR     0002   SNKATIM  002F   SNMR     0000   SNMSSR0  0012   SNMSSR1  0013   SNPORT0  0004   SNPORT1  0005   SNRBFSZ  001E   SNRXRP0  0028   SNRXRP1  0029   SNRXRZ0  0026   SNRXRZ1  0027   SNRXWP0  002A   SNRXWP1  002B   SNSR     0003   SNTBFSZ £)ß*'©êöê)ß**&õ©ß*,#))ß*,#)êê)ß*,)()ß*,)(êê)ß*,+®©NTXWP1  0025   SPIBASE  8080   SPI_AUT  0008   SPI_CR_  0001   SPI_CS_  0040   SPI_HLD  0002   SPI_IEN  0010   SPI_IRQ  0001   SPI_RST  0020   SPI_SR_  0004   SYS_TABS 04C6   S_ACCEPT 0058   S_BIND   0048   S_CLOSE  0010   S_CONNEC 0040   S_DISCON 0060   S_INTRPT 0038   S_LISTEN 0050   S_OPEN   0008   S_READ   0030   S_RQRD   0028   S_RQWR   0018   S_RRDFRM 0080   S_RREAD  0088   S_SNDKEP 0070   S_SNDMAC 0068   S_SPCL   0078   S_WRITE  0020   S_WRQSTO 0090   S_WSNDTM 00A0   S_WSNDTO 0098   TFREE    0004   TRUN     0001   TSKSIZ   00D7   TSLEEP   0002   TSYS     0005   TWAIT    0003   U        0003   USTSIZ   00C0   V        0007   W        0006   WCACCP   0086   WCBIND   0085   WCCLOS   0010   WCCONN   0004   WCDISC   0008   WCLIST   0002   WCOPEN   0001   WCRECV   0040   WCRRQD   0081   WCSEND   0020   WCSKEP   0022   WCSNAC   0021   WCSPEC   0080   WCXMDR   0082   WFNBLK   0001   WRFB2SK  F126   WSCLSD   0000   WSCLSG   001A   WSCLWT   001C   WSESTB   0017   WSFWAI   0018   WSINIT   0013   WSLACK   001D   WSLIST   0014   WSMCRW   0042   WSRNBL   001E   WSRRQF   0081   WSSPEC   0080   WSSYNR   0016   WSSYNS   0015   WSTIMW   001B   WSUDP    0022   WSWNBL   001F   WSXMDD   0082   WZ5_name E1C1   WZBUSY   0080   WZGAR0   0001   WZGAR1   0002   WZGAR2   0003   WZGAR3   0004   WZILLT0  0013   WZILLT1  0014   WZIMR    0016   WZIR     0015   WZLCSZ   0016   WZMR     0000   WZNETOF  0370   WZPHY    002E   WZRCR    001B   WZRTR0   0019   WZRTR1   001A   WZSHAR0  0009   WZSHAR1  000A   WZSHAR2  000B   WZSHAR3  000C   WZSHAR4  000D   WZSHAR5  000E   WZSIMR   0018   WZSIPR0  000F   WZSIPR1  0010   WZSIPR2  0011   WZSIPR3  0012   WZSIR    0017   WZSIZE   002A   WZSKIO   0002   WZSKIP   0040   WZSKIS   0004   WZSKOFF  0220   WZSLCK   0001   WZSUBR0  0005   WZSUBR1  0006   WZSUBR2  0007   WZSUBR3  0008   WZUIPR0  0028   WZUIPR1  0029   WZUIPR2  002A   WZUIPR3  002B   WZUPRT0  002C   WZUPRT1  002D   WZVERS   0039   WZWLCK   0010   X        0001   Y        0002   bad_cmd  E392   bittab   E6C3   bmread   EB99   bt2num   E6B2   byterd   EB75   bytewr   EBD2   change   E494   chproc   040C   clock_ti 0455   conlb1   E76C   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   dev_addr 0000   dev_brbu 0004   dev_tab  04A0   dev_type 0002   end_vars 3EFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  E05C   fio_fsz  E05A   fio_irq  E20C   fio_msg  E276   fio_rese E1CC   fio_resp E292   fio_star E07D   fio_wait E1EF   fiointe  E275   functb   EAA9   getjo1   E4DC   getjo2   E4EB   getjo4   E4F2   getjo6   E4FB   getjo8   E4FD   getjob   E4D6   hibyta   0004   hibyts   0006   hst_cmd  0000   hst_seq  0001   hst_tty  0002   hst_val  0003   hstbuf   045A   hstptr   049A   idle     040D   int_all  E3BA   int_buf  0447   int_ptr  0453   jobpri   040B   lobyta   0005   lobyts   0007   lstram   04C6   makrd6   E555   makrdy   E540   max_trn  E05E   mod_name 0002   mod_tbl  E1BB   mod_type 0000   no_dev   E13C   FIO Simulation Structure             07:28:09  Jan 07, 2024   Page  105Debug Interface Routines                            num2bt   E6A8   nwp_strt 0000   oldorg   EB41   polext   E786   putru1   E514   putru2   E51B   putru4   E529   putru5   E538   putru6   E53C   putrun   E507   rdrqer1  E8A0   rom_bad  E0B3   rom_firq E086   rom_init E05F   rom_int  E0A8   rom_nmi  E080   rom_swi  E08D   rom_swi2 E093   rom_swi3 E09A   rom_trap E0A1   rsche2   E4AB   rsche3   E4BF   rsched   E49A   runlst   0403   sa_dat   0002   sa_fam   0000   sdev_sig E61B   send_SI  E42B   set_tabl E0F4   showrg   EADB   sin_addr 0014   sin_fam  0010   sin_port 0012   skacpt   E826   skbind   E7AF   skclin   E6E7   skclos   E6CC   skcner1  E7A5   skcner2  E792   skcner3  E7A9   skcner4  E7A1   skcner5  E79D   skcner6  E796   skconn   E719   skctcp   E641   skcudp   E64A   skdisc   EB3A   skfres   E63A   skinit   E5FD   skinthan E61A   skintrp  EB3A   sklist   E7F4   sknewp   E61C   skopen   E653   skoper1  E69E   skoper2  E6A2   skrecv   E8A5   skreqrd  E85D   skreqwr  E8C7   sksend   E908   skskep   EB3A   sksmac   EB3A   skspcl   EA82   sktest   E617   skurrd   E98F   skurrdf  E92A   skurwt   E9B9   skusnm   EA03   skusnt   EA4C   skuwr2   EA03   sleep    E57A   sleep7   E5A2   slplst   0405   spicmd   0000   spicon   0001   spiint   0456   spinit   EB41   spista   0000   spistr2  EB47   sprend   EBF0   stbinit  E0C2   sto_chk  E143   swtchu   E4CB   sys_vars 0400   tim_base 8400   tim_rest 8401   timerack E1AF   timerchk E1B5   timerin  E1A9   tsagin   000F   tscmd    0009   tsdev    000D   tsevnt   0006   tsk2rg   F0AD   tsk2rx   F0C8   tsk2tx   F0B9   tskend   049E   tskinit  E151   tsktab   049C   tslink   0000   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstval   000C   umark0   0013   umark1   0015   usp      0011   utask    0409   wakeu2   E561   wakeu3   E568   wakeu4   E56C   wakeu5   E56E   wakeup   E556   wlocip   0370   wordrd   EB87   wordwr   EBE1   wzanyp   0457   wzcmnd   0004   wzdev    EAB1   wzdevt   E62E   wzdma1   000C   wzdma2   000E   wzdprt   0012   wzdsta   0012   wzenum   0000   wzerr    0007   wzfaml   0024   wzflg    0003   wzfsta   0002   wzgwad   0008   wzhwad   000C   wzipad   0014   wzmyip   0000   wzprot   0028   wzrqln   000A   wzsbnm   0004   wzsflg   0018   wzsk1    0346   wzsk2    031C   wzsk3    02F2   wzsk4    02C8   wzsk5    029E   wzsk6    0274   wzsk7    024A   wzsk8    0220   wzsprt   0010   wzstat   0005   wztype   0026   wzuipa   001A   wzupkt   0006   wzuprt   001E   wzurms   0020   wzuwrp   0022   wzxfer   0008   xmtint   E5AF   