** this file contains all socket handlers** when a wzsocket is opened, all locations are effectively* cleared to zero, with exception of the enumeration byte*** do everything to init the system*skinit  equ     *        jsr     spinit          set SPI        ldb     #%10000000      software reset        jsr     PCRMR01      jsr     GCRMR        tstb        bmi     01b        ldb     #%01111000      power up        jsr     PCRPHY          set the PHY part        ldd     #32768        std     wzanyp          set value for Source port        rts** test if device is present*sktest  sec                     yes        rts** skinthan, fromddevice table*skinthan equ    *        rts** device signal handle*sdev_sig equ    *        rts** get a new source port*sknewp  ldd     wzanyp          else create one        incd        cmpd    #$FFF0        blo     03f        ldd     #$800003      std     wzanyp        rts** wzdevt, device test, return Z if running, NZ if not*wzdevt  pshs    a,y        ldy     fifo_us1        device info        lda     wzdsta,y        cmpa    #$ff            open        puls    a,y,pc** skfres, socket restore info*skfres  lda     wzenum,u        socket #, is remembered        trfr    A,E        clr     wzerr,u         init result        rts** skctcp, check if in TCP mode* return zero if in TCP mode, non-zero if not* U = wzsock*skctcp  pshs    d        ldd     wztype,u        SOCK_STREAM        cmpb    #SK_STRM        is TCP        puls    d,pc** skcudp, check if in UDP mode* return zero if in UDP mode, non-zero if not* U = wzsock*skcudp  pshs    d        ldd     wztype,u        SOCK_DGRAM        cmpb    #SK_DGRM        is UDP        puls    d,pc****************************************************************** here the socket is opened* X hold the TASK table* U holds the sock address*skopen  equ     *        jsr     skfres** check if DEVICE is active*        jsr     wzdevt        beq     11f        jsr     skclin          NO, close internal and don't start04      lbra    skoper1** retry, we do all things*11      lda     wzfsta,u        check if allocated by OS        bpl     04b             no, do nothi73Üïï1¥2±µê9∑±µ≤∫ê1∞∂60π3∫∂≤∑:9Üïê1∂9;Ω363ñ:ê2π0π≤ê360≥πÜê622;Ω30∂∂:Üê1∂∏1†£/§ß"™ê172ê177∫9∫∏87π:2≤ï;Ω:<∏2ê47∂29ê9∑±µ≤∫:<∏2ê ß"9∑±µ≤∫360≥πê44±<∫2îÜê622;Ω:<∏2ñ:Üê1∂∏1©•Ø©™)&ê)ß°•Ø©™)"†¶        beq     01f        cmpb    #SK_DGRM        SOCK_DGRAM        beq     21f        cmpb    #SK_RAW         SOCK_RAW        bne     skoper2* raw socket        ldb     #%00000100      MACRAW        bra     07f* dgram21      ldb     #%00000010      UDP        bra     07f* TCP socket01      ldb     #%00000001       TCP set source port in connect** set socket mode register*07      jsr     PSRMR           set socket mode register** here do the real OPEN,*        ldb     #WCOPEN         open the device        stb     wzcmnd,u        copy command        jsr     PSRCR** interrupts not expected for 'open'*21      jsr     GSRSR           get status        stb     wzstat,u        cmpb    #WSCLSD        beq     21b             wait until updated*        clra        ldb     #R_OPEN         response99      rts*skoper1 lda     #1               device not initialized        bra     12fskoper2 lda     #2              type error12      ldb     #E_SOCKET        bra     99b** convert number in bit position* B = enum, B=bit*num2bt  pshs    x        ldx     #bittab        abx        ldb     0,x        puls    x,pc** bit to nummer, offset byt one, entry should NOT be 0*bt2num  pshs    x        ldx     #bittab        clr     0,-s02      cmpb    0,x+        beq     01f        inc     0,s        bra     02b01      puls    b,x,pc* tablebittab  fcb     0        fcb     %00000001,%00000010,%00000100,%00001000        fcb     %00010000,%00100000,%01000000,%10000000***************************************************************** close the socket* X hold the task table* U holds the sock address*skclos  equ     *        jsr     skfres        ldb     #WCDISC        stb     wzcmnd,u        jsr     PSRCR           send disconnect*        bsr     skclin        clrd        std     wzfaml,u        std     wztype,u        std     wzprot,u*        clra        ldb     #R_CLOSE        response        rts** wzclin, close interal*skclin  pshs    d        ldb     #WCCLOS         do close        stb     wzcmnd,u        jsr     PSRCR** erase registers in device*        ldd     #0        jsr     PSRPORT         source port*        lda     wzfsta,u        anda    #!(WZSKIO+WZSKIS)  reset io mode and is sending        sta     wzfsta,u        ldd     #0        std     wzxfer,u        clear remaining size*91      jsr     GSRSR        stb     wzstat,u        stat = 0 (closed)*        ldd     #0        std     wzsprt,u        erase old info        std     wzipad,u        std     wzipad+2,u        std     wzdprt,u        stb     wzflg,u         clear flags*        puls    d,pc***************************************************************** connect socket* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*skconn  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt        beq     01f        jsr     skclos          NO, don't start02      lbra    skcner401      jsr     skctcp          not in tcp, illegal        bne     02b** check if socket has been set up*11      jsr     GSRSR           status        stb     wzstat,u        check if properly setup        cmpb    #WSINIT         SHOULD BE        lbne    skcner6** check the info from the connect call*        ldd     wzipad,u        check if dest IP == null        ordx    wzipad+2,IU        beq     skcner1         IP address == NULL* IP address = 0000        ldd     wzipad,u        or FFFFFFFF        incd        bne     01f        ldd     wzipad+2,u        incd        beq     skcner1         IP address = FFFFFFFF** valid IP*01      ldd     wzdprt,u        check destination port        beq     skcner5         is not set, error*        jsr     PSRDPOR         set destination port        leay    wzipad,u        load socket        jsr     PSRDIP          set destination IP** source port, create one, always unique*        jsr     sknewp          get new        std     wzsprt,u        tell us what you took        jsr     PSRPORT         source port** do the CONNECT here*        ldb     #WCCONN        stb     wzcmnd,u        jsr     PSRCR           do connect***conlb1  jsr     skfres        jsr     GSRSR           update status        stb     wzstat,u        cmpb    #WSESTB        beq     90f        cmpb    #WSCLSD        beq     skcner2        ldy     #conlb1        bra     polext*90      clra        ldb     #R_CONNECT99      rts** polexit, Y=where to return*polext  sty     tsagin,x        here to restart        ldb     #POLPRI        stb     tsprir,x        ldy     #$ffFF        rtsskcner2 ldb     #R_DISCON        bra     99bskcner6 jsr     skclin          reset open        lda     #15             not properly setup        bra     09fskcner5 lda     #14             destination port not set        bra     09fskcner4 lda     #10             device not initialized        bra     09fskcner1 lda     #11             IP address invalid        bra     09fskcner3 lda     #1309      ldb     #E_SOCKET        bra     99b***************************************************************** bind request* X hold the task table* U holds the sock address* bindt() call fills in info in the sock structure*skbind  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt        lbne    rdrqer1        jsr     skctcp          check TCP        beq     01f        jsr     skcudp          check UDP        lbne    skcner6** go on , the bind() call sets wzipad and wzsprt, this is for* a server, for a client it needs to set wzdprt* for as server IP is local, for a client IP is remote**        jsr     GSRSR           status        stb     wzstat,u        cmpb    #WSUDP          check        beq     03f        bra     04f01      jsr     GSRSR           status        stb     wzstat,u        cmpb    #WSINIT         should be04      lbne    skcner6** set the network connection data*03      jsr     sknewp        std     wzdprt,u        jsr     PSRDPOR         destination port        ldd     wzsprt,u        jsr     PSRPORT         source port*        leay    wzipad,u        jsr     PSRDIP          source IP*        clra        ldb     #R_BIND        rts****************************************************************** listen request* X hold the task table* U holds the sock address* listen() call waits for peer to connect*sklist  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** go on**        jsr     GSRSR           status        stb     wzstat,u*        cmpb    #WSCLSD         closed?        beq     80f        cmpb    #WSINIT         opened        bne     90f*        ldb     #WCLIST        stb     wzcmnd,u        jsr     PSRCR*        clra        ldb     #R_LISTEN        rts*80      clra        ldb     #R_CLOSE        rts*90      ldy     #sklist        jmp     polext***************************************************************** accept request* X hold the task table* U holds the sock address* listen() call waits for peer to connect*skacpt  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b             wrong mode** go on*        jsr     GSRSR           status        stb     wzstat,u        cmpb    #WSESTB         connected        bne     01f        jsr     GSRDPOR         fill in peer port        std     wzdprt,u        leay    wzipad,u        jsr     GSRDIP*        clra        ldb     #R_ACCEPT        rts*01      cmpb    #WSCLSD        bne     02f        clra        ldb     #R_CLOSE        rts*02      ldy     #skacpt        jmp     polext***************************************************************** read request  TCP only !!* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*skreqrd equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp          check TCP        bne     02b** go on**        jsr     GSRSR        stb     wzstat,u        update status        jsr     GSRRXRS         data available?        std     wzxfer,u        bne     70f*        lda     wztype,u        check flags        bita    #WFNBLK         non block        bne     75f*        ldb     wzstat,u17  cmpb    #WSESTB         still active        beq     20f        cmpb    #WSCLWT        beq     60f        cmpb    #WSCLSD        beq     60f*20      ldy     #skreqrd        jmp     polext*************************75      clra        ldb     #R_RQRDNB       tell no data        rts* data present70      clra        ldb     #R_RQRD        rts* close socket and return60      clra        ldb     #R_CLOSE        rtsrdrqer1 lda     #130        ldb     #E_SOCKET        rts***************************************************************** get the data  U=wzsock*skrecv  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt        lbne    rdrqer102      jsr     skctcp        bne     02b** we got info that data is present, get it* if here the main CPU already locked the fifo for us* on return D= xfreed count*        jsr     GSRRXRS         received size* D total aviable data        jsr     RDSK2FB         transfer datat to fifo        std     wzxfer,u        save it        ldb     #WCRECV        stb     wzcmnd,u        jsr     PSRCR           tell sender we took it        ldb     #R_READ         tell data in fifo        clra        rts***************************************************************** write request* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*skreqwr equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** go on**        jsr     GSRSR        stb     wzstat,u        update status        jsr     GSRTXFR         free size (remaining)        cmpd    wzrqln,u        would it fit        bhs     70f*10      ldb     wzstat,u        cmpb    #WSESTB        beq     20f        cmpb    #WSCLWT        beq     60f        cmpb    #WSCLSD        bne     20f        ldd     #0        std     wzxfer,u        bra     60f* data space70      clra        ldb     #R_RQWR        rts* data space exhausted, would block72      clra**        ldb     #R_RQWRWB        rts* close socket and return60      ldb     #R_CLOSE        rts*20      ldy     #skreqwr        jmp     polext***************************************************************** write request* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*sksend  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** we got info that data is present, get it* if here the main CPU already locked the fifo for us* on return D= xfreed count*        jsr     GSRTXFR         free size (remaining)* D = total available space        jsr     WRFB2SK         transfer from fifo to socket        std     wzxfer,u        save it        ldb     #WCSEND        stb     wzcmnd,u        jsr     PSRCR           tell sender it is coming        ldb     #R_WRITE        tell data in fifo        clra        rts**************************************************************** skurrdf, request readfrom*** X hold the task table* U holds the sock address*skurrdf equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on**        ldd     wzurms,u        check remaining size        bne     84f** no  packet data present, wait for it*        jsr     GSRSR        stb     wzstat,u        update status        jsr     GSRRXRS         data available?        std     -2,s            test D        bne     22f             keep waiting* no data yet, check socket state        ldb     wzstat,u        cmpb    #WSUDP          still active        beq     20f        cmpb    #WSCLWT        beq     60f        cmpb    #WSCLSD        beq     60f*       ldd     wzsprt,u*       jsr     PSRPORT         set source port*20      ldy     #skurrdf        jmp     polext** first data present, set wzuipa, wzuprt, wzurms*22      leay    wzuipa,u        ldd     #8              size of header        jsr     bmread          copy data** move pointer*        jsr     GSRRXRP        addd    #8        jsr     PSRRXRP         update pointer        ldb     #WCRECV        stb     wzcmnd,u        process move        jsr     PSRCR*        ldd     wzurms,u        cmpd    #MAX_UDP        max size        bhi     78f*84      clra        ldb     #R_RDFRM        rts* close socket and return60      clra        ldb     #R_CLOSE        rts*78      jsr     skclin          close        ldb     #E_SOCKET        rts**************************************************************** skurrd,  data readfrom*** X hold the task table* U holds the sock address*skurrd  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on*** transfer at most fio_fsz bytes        ldd     wzurms,u        this is leading count* D = total available data        jsr     RDSK2FB         transfer data        pshs    d               xferred count        ldd     wzurms,u        update        subd    0,s++        std     wzurms,u        new remaining*01      ldb     #WCRECV        stb     wzcmnd,u        set processed        jsr     PSRCR*        clra        ldb     #R_RRDFD        rts**************************************************************** skurwt,  request sendto*** X hold the task table* U holds the sock address*skurwt  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on**        ldd     wzdprt,u        check illegal port        lbeq    78f*        ldd     wzipad,u        ordx    wzipad+2,IU        lbeq    78f* set network registers        ldd     wzdprt,u        jsr     PSRDPOR        leay    wzipad,u        jsr     PSRDIP        ldd     wzsprt,u        bne     04f*        ldd     wzsprt,u        already set?        bne     16f        jsr    9µ∑2ª∏3≤∫72ªê9∑∫π1≤ê87π:ê9∫2;Ω9∏9::Üê9∫2;Ω:∏9::ê9≤∫0∂9∑ê92∫:π787π:òõ59π()©('©*ïò62<êπµ∫ªπ27ê92∂∞¥∑22πê56∏87∂2º:Üïï0≥:2π4∑:4∞∂9≤∫:∏67∑∏42π2Üïπµ∫π∑6ê2∏∫êπµ∫ªπ59π9µ≥92πê9≤∫9∑±µ≤∫10π≤Üê59π;Ω22ª:22ª4≤ê0±∫4ª2Üê6172ê1             no        jsr     skcudp          check open method        bne     02b*        jsr     GSRSR        stb     wzstat,u        update status        jsr     GSRTXFR         free size        cmpd    wzurms,u        bhs     10f* no space yet        ldb     wzstat,u        cmpb    #WSUDP        beq     20f        cmpb    #WSCLWT         is closing        beq     60f        cmpb    #WSCLSD         closed        beq     60f*20      ldy     #skurwt        jmp     polext          keep polling*10      ldd     wzurms,u        cmpd    #MAX_UDP        too big        bhi     78f*        clra        ldb     #R_RSNDTO        rts60      clra        ldb     #R_CLOSE        rts78      jsr     skclin          close        ldb     #E_SOCKET        rts**************************************************************** skusnt,  data sendto*** X hold the task table* U holds the sock address*skusnt  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on** transfer fifo to socket data register        ldd     wzurms,u        total data*        jsr     WRFB2SK         fifo to socket        pshs    d        ldd     wzurms,u        all loaded        subd    0,s++        std     wzurms,u        bne     01f        ldd     wzuwrp,u        is it used        jsr     PSRTXWP         set write pointer        ldb     #WCSEND        stb     wzcmnd,u        jsr     PSRCR        clra        ldb     #R_WSNDTO       data taken        rts01      clra        ldb     #R_SNDTOM       ask for more        rts***************************************************************** special function, tstval,x is indicator* X hold the task table* U holds the SPECIAL sock address (NO wz....  access!)*skspcl  equ     **        pshs    x        ldb     tstval,x        get index        cmpb    #MAXTBL        bhi     01f             illegal        aslb        ldx     #functb        ldy     b,x             get special function        beq     01f             not valid        puls    x*        jsr     0,y             do function        bne     90f*        clra        ldb     #R_SPCL        bra     99f*90      lda     #162        bra     02f*01      puls    x        lda     #16102        ldb     #E_SOCKET*99      rtsfunctb  fdb     wzdev           set device settings        fdb     wzdev        fdb     showrg        fdb     0MAXTBL  equ     (*-functb)/2** X hold the task table* U holds the special sock address*wzdev        ldb     #8        trfr    B,E        ldu     fifo_us1        device info area        leay    0,u             myip        jsr     PCRSIP          source IP        leay    4,u        jsr     PCRSNM          subnet mask        leay    8,u        jsr     PCRGA           gateway IP        leay    12,u        jsr     PCRSHA          hardware address        lda     18,u            ON/OFF        beq     01f        ldb     #%11111000     all on        bra     02f01      ldb     #%01111000     all off02      jsr     PCRPHY        clra        rts***showrg        ldb     #8        trfr    B,E             select first socket        ldu     fifo_us1        leau    32,u            skip network data area        jsr     GSRMR        stb     0,u+        jsr     GSRSR        stb     0,u+        jsr     GSRRBFS        stb     0,u+        ldb     #'=        stb     0,u+        jsr     GSRPORT        std     0,u++        jsr     GSRDPOR        std     0,u++        ldb     #'#        stb     0,u+        leay    0,u        jsr     GSRDHAR        leau    6,u        ldb     #'#        stb     0,u+        leay    0,u        jsr     GSRDIP        leau    4,u        ldb     #'=        stb     0,u+        jsr     GSRMSS        std     0,u++        jsr     GSRRXRS        std     0,u++        jsr     GSRRXRP        std     0,u++        jsr     GSRRXWP        std     0,u++        jsr     GSRFRAG        std     0,u++        ldb     #'#        stb     0,u        clra        rts* X hold the task table* U holds the sock addressskintrpskdiscsksmacskskep        lda     #255        sta     wzerr,u        ldb     #E_SOCKET        rts